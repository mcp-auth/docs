---
sidebar_position: 2
sidebar_label: 'Tutorial: Construa um gerenciador de tarefas'
---

import TabItem from '@theme/TabItem';
import Tabs from '@theme/Tabs';

import SetupOauthOrOidc from './_setup-oauth-or-oidc.mdx';
import SetupOidc from './_setup-oidc.mdx';

# Tutorial: Construa um gerenciador de tarefas

Neste tutorial, vamos construir um servidor MCP de gerenciador de tarefas com autentica√ß√£o e autoriza√ß√£o de usu√°rio.

Ap√≥s concluir este tutorial, voc√™ ter√°:

- ‚úÖ Uma compreens√£o b√°sica de como configurar controle de acesso baseado em papel (RBAC) em seu servidor MCP.
- ‚úÖ Um servidor MCP que pode gerenciar listas de tarefas pessoais.

:::note
Antes de come√ßar, recomendamos fortemente que voc√™ fa√ßa primeiro o [tutorial Quem sou eu](./whoami) caso n√£o esteja familiarizado com o servidor MCP e OAuth 2.
:::

## Vis√£o geral \{#overview}

O tutorial envolver√° os seguintes componentes:

- **Servidor MCP**: Um servidor MCP simples que usa os SDKs oficiais do MCP para lidar com requisi√ß√µes, com um servi√ßo integrado de Tarefas para gerenciar os itens de tarefas do usu√°rio.
- **MCP inspector**: Uma ferramenta visual de testes para servidores MCP. Tamb√©m atua como um cliente OAuth / OIDC para iniciar o fluxo de autoriza√ß√£o e recuperar tokens de acesso.
- **Servidor de autoriza√ß√£o**: Um provedor OAuth 2.1 ou OpenID Connect que gerencia identidades de usu√°rios e emite tokens de acesso.

Aqui est√° um diagrama de alto n√≠vel da intera√ß√£o entre esses componentes:

```mermaid
sequenceDiagram
    participant Client as MCP Inspector
    participant Server as MCP Server
    participant Auth as Servidor de Autoriza√ß√£o

    Client->>Server: Solicitar opera√ß√£o de tarefa
    Server->>Client: Retornar 401 N√£o autorizado
    Client->>Auth: Iniciar fluxo de autoriza√ß√£o
    Auth->>Auth: Completar fluxo de autoriza√ß√£o
    Auth->>Client: Redirecionar de volta com c√≥digo de autoriza√ß√£o
    Client->>Auth: Trocar c√≥digo por token de acesso
    Auth->>Client: Retornar token de acesso
    Client->>Server: Solicitar opera√ß√£o de tarefa com token de acesso
    Server->>Server: Validar token de acesso e obter escopos do usu√°rio do token de acesso
    Note over Server: Executar opera√ß√£o de tarefa
    Server->>Client: Retornar resultado da opera√ß√£o de tarefa
```

## Entenda seu servidor de autoriza√ß√£o \{#understand-your-authorization-server}

### Tokens de acesso com escopos \{#access-tokens-with-scopes}

Para implementar [controle de acesso baseado em papel (RBAC)](https://auth.wiki/rbac) em seu servidor MCP, seu servidor de autoriza√ß√£o precisa suportar a emiss√£o de tokens de acesso com escopos. Escopos representam as permiss√µes que um usu√°rio recebeu.

<Tabs groupId="provider">
<TabItem value="logto" label="Logto">

[Logto](https://logto.io) oferece suporte a RBAC por meio de seus recursos de API (conforme [RFC 8707: Indicadores de Recurso para OAuth 2.0](https://datatracker.ietf.org/doc/html/rfc8707)) e funcionalidades de pap√©is. Veja como configurar:

1. Fa√ßa login no [Logto Console](https://cloud.logto.io) (ou em seu Logto Console auto-hospedado)

2. Crie recurso de API e escopos:

   - V√° para "Recursos de API"
   - Crie um novo recurso de API chamado "Gerenciador de Tarefas"
   - Adicione os seguintes escopos:
     - `create:todos`: "Criar novos itens de tarefa"
     - `read:todos`: "Ler todos os itens de tarefa"
     - `delete:todos`: "Excluir qualquer item de tarefa"

3. Crie pap√©is (recomendado para facilitar o gerenciamento):

   - V√° para "Pap√©is"
   - Crie um papel "Admin" e atribua todos os escopos (`create:todos`, `read:todos`, `delete:todos`)
   - Crie um papel "User" e atribua apenas o escopo `create:todos`

4. Atribua permiss√µes:
   - V√° para "Usu√°rios"
   - Selecione um usu√°rio
   - Voc√™ pode:
     - Atribuir pap√©is na aba "Pap√©is" (recomendado)
     - Ou atribuir escopos diretamente na aba "Permiss√µes"

Os escopos ser√£o inclu√≠dos na reivindica√ß√£o `scope` do token de acesso JWT como uma string separada por espa√ßos.

</TabItem>
<TabItem value="oauth-oidc" label="OAuth 2.0 / OIDC">

Provedores OAuth 2.0 / OIDC normalmente suportam controle de acesso baseado em escopo. Ao implementar RBAC:

1. Defina os escopos necess√°rios em seu servidor de autoriza√ß√£o
2. Configure seu cliente para solicitar esses escopos durante o fluxo de autoriza√ß√£o
3. Certifique-se de que seu servidor de autoriza√ß√£o inclua os escopos concedidos no token de acesso
4. Os escopos geralmente s√£o inclu√≠dos na reivindica√ß√£o `scope` do token de acesso JWT

Consulte a documenta√ß√£o do seu provedor para detalhes espec√≠ficos sobre:

- Como definir e gerenciar escopos
- Como os escopos s√£o inclu√≠dos no token de acesso
- Quaisquer recursos adicionais de RBAC, como gerenciamento de pap√©is

</TabItem>
</Tabs>

### Validando tokens e verificando permiss√µes \{#validating-tokens-and-checking-permissions}

Quando seu servidor MCP recebe uma requisi√ß√£o, ele precisa:

1. Validar a assinatura e expira√ß√£o do token de acesso
2. Extrair os escopos do token validado
3. Verificar se o token possui os escopos necess√°rios para a opera√ß√£o solicitada

Por exemplo, se um usu√°rio deseja criar um novo item de tarefa, seu token de acesso deve incluir o escopo `create:todos`. Veja como funciona o fluxo:

```mermaid
sequenceDiagram
    participant Client
    participant MCP Server
    participant Auth Server

    Client->>MCP Server: Solicita√ß√£o com token de acesso

    alt Valida√ß√£o JWT
        MCP Server->>Auth Server: Buscar JWKS
        Auth Server-->>MCP Server: Retornar JWKS
        MCP Server->>MCP Server: Validar JWT localmente
    else Introspec√ß√£o de Token
        MCP Server->>Auth Server: POST /introspect<br/>(token=access_token)
        Auth Server-->>MCP Server: Retornar informa√ß√µes do token<br/>(ativo, escopo, etc.)
    end

    MCP Server->>MCP Server: Extrair & verificar escopos

    alt Possui escopos necess√°rios
        MCP Server->>Client: Permitir opera√ß√£o
    else Escopos ausentes
        MCP Server->>Client: Retornar 403 Proibido
    end
```

### Registro Din√¢mico de Cliente \{#dynamic-client-registration}

O Registro Din√¢mico de Cliente n√£o √© necess√°rio para este tutorial, mas pode ser √∫til se voc√™ quiser automatizar o processo de registro do cliente MCP com seu servidor de autoriza√ß√£o. Veja [Registro Din√¢mico de Cliente √© necess√°rio?](../../provider-list.mdx#is-dcr-required) para mais detalhes.

## Entenda RBAC no gerenciador de tarefas \{#understand-rbac-in-todo-manager}

Para fins de demonstra√ß√£o, implementaremos um sistema simples de controle de acesso baseado em papel (RBAC) em nosso servidor MCP de gerenciador de tarefas. Isso mostrar√° os princ√≠pios b√°sicos do RBAC mantendo a implementa√ß√£o direta.

:::note
Embora este tutorial demonstre o gerenciamento de escopos baseado em RBAC, √© importante observar que nem todos os provedores de autentica√ß√£o implementam o gerenciamento de escopos por meio de pap√©is. Alguns provedores podem ter suas pr√≥prias implementa√ß√µes e mecanismos √∫nicos para gerenciar controle de acesso e permiss√µes.
:::

### Ferramentas e escopos \{#tools-and-scopes}

Nosso servidor MCP de gerenciador de tarefas fornece tr√™s ferramentas principais:

- `create-todo`: Criar um novo item de tarefa
- `get-todos`: Listar todas as tarefas
- `delete-todo`: Excluir uma tarefa pelo ID

Para controlar o acesso a essas ferramentas, definimos os seguintes escopos:

- `create:todos`: Permite criar novos itens de tarefa
- `delete:todos`: Permite excluir itens de tarefa existentes
- `read:todos`: Permite consultar e recuperar a lista de todas as tarefas

### Pap√©is e permiss√µes \{#roles-and-permissions}

Definiremos dois pap√©is com diferentes n√≠veis de acesso:

| Papel  | create:todos | read:todos | delete:todos |
| ------ | ------------ | ---------- | ------------ |
| Admin  | ‚úÖ           | ‚úÖ         | ‚úÖ           |
| User   | ‚úÖ           |            |              |

- **User**: Um usu√°rio comum que pode criar itens de tarefa e visualizar ou excluir apenas suas pr√≥prias tarefas
- **Admin**: Um administrador que pode criar, visualizar e excluir todos os itens de tarefa, independentemente da propriedade

### Propriedade do recurso \{#resource-ownership}

Embora a tabela de permiss√µes acima mostre os escopos expl√≠citos atribu√≠dos a cada papel, h√° um princ√≠pio importante de propriedade de recurso a considerar:

- **Usu√°rios** n√£o possuem os escopos `read:todos` ou `delete:todos`, mas ainda podem:
  - Ler seus pr√≥prios itens de tarefa
  - Excluir seus pr√≥prios itens de tarefa
- **Admins** possuem permiss√µes totais (`read:todos` e `delete:todos`), permitindo que:
  - Visualizem todos os itens de tarefa no sistema
  - Excluam qualquer item de tarefa, independentemente da propriedade

Isso demonstra um padr√£o comum em sistemas RBAC onde a propriedade do recurso concede permiss√µes impl√≠citas aos usu√°rios para seus pr√≥prios recursos, enquanto pap√©is administrativos recebem permiss√µes expl√≠citas para todos os recursos.

:::tip Saiba mais
Para se aprofundar nos conceitos e melhores pr√°ticas de RBAC, confira [Dominando RBAC: Um Exemplo Abrangente do Mundo Real](https://blog.logto.io/mastering-rbac).
:::

## Configure a autoriza√ß√£o em seu provedor \{#configure-authorization-in-your-provider}

Para implementar o sistema de controle de acesso que descrevemos anteriormente, voc√™ precisar√° configurar seu servidor de autoriza√ß√£o para suportar os escopos necess√°rios. Veja como fazer isso com diferentes provedores:

<Tabs groupId="provider">
<TabItem value="logto" label="Logto">

[Logto](https://logto.io) oferece suporte a RBAC por meio de recursos de API e funcionalidades de pap√©is. Veja como configurar:

1. Fa√ßa login no [Logto Console](https://cloud.logto.io) (ou em seu Logto Console auto-hospedado)

2. Crie recurso de API e escopos:

   - V√° para "Recursos de API"
   - Crie um novo recurso de API chamado "Gerenciador de Tarefas" e use `https://todo.mcp-server.app` (para demonstra√ß√£o) como indicador.
   - Crie os seguintes escopos:
     - `create:todos`: "Criar novos itens de tarefa"
     - `read:todos`: "Ler todos os itens de tarefa"
     - `delete:todos`: "Excluir qualquer item de tarefa"

3. Crie pap√©is (recomendado para facilitar o gerenciamento):

   - V√° para "Pap√©is"
   - Crie um papel "Admin" e atribua todos os escopos (`create:todos`, `read:todos`, `delete:todos`)
   - Crie um papel "User" e atribua apenas o escopo `create:todos`
   - Na p√°gina de detalhes do papel "User", v√° para a aba "Geral" e defina o papel "User" como o "Papel padr√£o".

4. Gerencie pap√©is e permiss√µes dos usu√°rios:
   - Para novos usu√°rios:
     - Eles receber√£o automaticamente o papel "User" j√° que o definimos como padr√£o
   - Para usu√°rios existentes:
     - V√° para "Gerenciamento de usu√°rios"
     - Selecione um usu√°rio
     - Atribua pap√©is ao usu√°rio na aba "Pap√©is"

:::tip Gerenciamento de Pap√©is Program√°tico
Voc√™ tamb√©m pode usar a [Management API](https://docs.logto.io/integrate-logto/interact-with-management-api) do Logto para gerenciar pap√©is de usu√°rios programaticamente. Isso √© especialmente √∫til para automa√ß√£o de gerenciamento de usu√°rios ou ao construir pain√©is administrativos.
:::

Ao solicitar um token de acesso, o Logto incluir√° os escopos na reivindica√ß√£o `scope` do token com base nas permiss√µes do papel do usu√°rio.

</TabItem>
<TabItem value="keycloak" label="Keycloak">

No [Keycloak](https://www.keycloak.org), voc√™ pode configurar as permiss√µes necess√°rias usando escopos de cliente:

1. Crie escopos de cliente:

   - No seu realm, v√° para "Client scopes"
   - Crie tr√™s novos escopos de cliente:
     - `create:todos`
     - `read:todos`
     - `delete:todos`

2. Configure o cliente:

   - V√° para as configura√ß√µes do seu cliente
   - Na aba "Client scopes", adicione todos os escopos que voc√™ criou
   - Certifique-se de que o token mapper est√° configurado para incluir escopos

3. Opcional: Use pap√©is para facilitar o gerenciamento
   - Se preferir gerenciamento baseado em papel:
     - Crie pap√©is de realm para diferentes n√≠veis de acesso
     - Mapeie escopos para pap√©is
     - Atribua pap√©is aos usu√°rios
   - Caso contr√°rio, voc√™ pode atribuir escopos diretamente aos usu√°rios ou por permiss√µes no n√≠vel do cliente

O Keycloak incluir√° os escopos concedidos na reivindica√ß√£o `scope` do token de acesso.

</TabItem>
<TabItem value="oauth-or-oidc" label="OAuth 2 / OIDC">

Para provedores OAuth 2.0 ou OpenID Connect, voc√™ precisar√° configurar os escopos que representam diferentes permiss√µes. Os passos exatos depender√£o do seu provedor, mas geralmente:

1. Defina escopos:

   - Configure seu servidor de autoriza√ß√£o para suportar:
     - `create:todos`
     - `read:todos`
     - `delete:todos`

2. Configure o cliente:

   - Registre ou atualize seu cliente para solicitar esses escopos
   - Certifique-se de que os escopos est√£o inclu√≠dos no token de acesso

3. Atribua permiss√µes:
   - Use a interface do seu provedor para conceder os escopos apropriados aos usu√°rios
   - Alguns provedores podem suportar gerenciamento baseado em papel, enquanto outros podem usar atribui√ß√µes diretas de escopos
   - Consulte a documenta√ß√£o do seu provedor para a abordagem recomendada

:::tip
A maioria dos provedores incluir√° os escopos concedidos na reivindica√ß√£o `scope` do token de acesso. O formato normalmente √© uma string de escopos separados por espa√ßo.
:::

</TabItem>
</Tabs>

Ap√≥s configurar seu servidor de autoriza√ß√£o, os usu√°rios receber√£o tokens de acesso contendo seus escopos concedidos. O servidor MCP usar√° esses escopos para determinar:

- Se um usu√°rio pode criar novas tarefas (`create:todos`)
- Se um usu√°rio pode visualizar todas as tarefas (`read:todos`) ou apenas as suas pr√≥prias
- Se um usu√°rio pode excluir qualquer tarefa (`delete:todos`) ou apenas as suas pr√≥prias

## Configure o servidor MCP \{#set-up-the-mcp-server}

Usaremos os [SDKs oficiais do MCP](https://github.com/modelcontextprotocol) para criar nosso servidor MCP de gerenciador de tarefas.

### Crie um novo projeto \{#create-a-new-project}

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

```bash
mkdir mcp-server
cd mcp-server
uv init # Ou use `pipenv` ou `poetry` para criar um novo ambiente virtual
```

</TabItem>
<TabItem value="node" label="Node.js">

Configure um novo projeto Node.js:

```bash
mkdir mcp-server
cd mcp-server
npm init -y # Ou use `pnpm init`
npm pkg set type="module"
npm pkg set main="todo-manager.ts"
npm pkg set scripts.start="node --experimental-strip-types todo-manager.ts"
```

:::note
Estamos usando TypeScript em nossos exemplos, pois o Node.js v22.6.0+ suporta execu√ß√£o nativa de TypeScript usando a flag `--experimental-strip-types`. Se estiver usando JavaScript, o c√≥digo ser√° semelhante - apenas certifique-se de estar usando Node.js v22.6.0 ou superior. Veja a documenta√ß√£o do Node.js para detalhes.
:::

</TabItem>
</Tabs>

### Instale o SDK MCP e depend√™ncias \{#install-the-mcp-sdk-and-dependencies}

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

```bash
pip install "mcp[cli]" starlette uvicorn
```

Ou qualquer outro gerenciador de pacotes de sua prefer√™ncia, como `uv` ou `poetry`.

</TabItem>
<TabItem value="node" label="Node.js">

```bash
npm install @modelcontextprotocol/sdk express zod
```

Ou qualquer outro gerenciador de pacotes de sua prefer√™ncia, como `pnpm` ou `yarn`.

</TabItem>
</Tabs>

### Crie o servidor MCP \{#create-the-mcp-server}

Primeiro, vamos criar um servidor MCP b√°sico com as defini√ß√µes das ferramentas:

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

Crie um arquivo chamado `todo-manager.py` e adicione o seguinte c√≥digo:

```python
from typing import Any
from mcp.server.fastmcp import FastMCP
from starlette.applications import Starlette
from starlette.routing import Mount

mcp = FastMCP("Gerenciador de Tarefas")

@mcp.tool()
def create_todo(content: str) -> dict[str, Any]:
    """Criar uma nova tarefa."""
    return {"error": "N√£o implementado"}

@mcp.tool()
def get_todos() -> dict[str, Any]:
    """Listar todas as tarefas."""
    return {"error": "N√£o implementado"}

@mcp.tool()
def delete_todo(id: str) -> dict[str, Any]:
    """Excluir uma tarefa pelo id."""
    return {"error": "N√£o implementado"}

app = Starlette(
    routes=[Mount('/', app=mcp.sse_app())]
)
```

Execute o servidor com:

```bash
uvicorn todo_manager:app --host 0.0.0.0 --port 3001
```

</TabItem>
<TabItem value="node" label="Node.js">

:::note
Como a implementa√ß√£o atual do MCP inspector n√£o lida com fluxos de autoriza√ß√£o, usaremos a abordagem SSE para configurar o servidor MCP. Atualizaremos o c√≥digo aqui assim que o MCP inspector suportar fluxos de autoriza√ß√£o.
:::

Voc√™ tamb√©m pode usar `pnpm` ou `yarn` se preferir.

Crie um arquivo chamado `todo-manager.ts` e adicione o seguinte c√≥digo:

```ts
// todo-manager.ts

import { z } from 'zod';
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { SSEServerTransport } from '@modelcontextprotocol/sdk/server/sse.js';
import express from 'express';

// Crie um servidor MCP
const server = new McpServer({
  name: 'Gerenciador de Tarefas',
  version: '0.0.0',
});

server.tool('create-todo', 'Criar uma nova tarefa', { content: z.string() }, async ({ content }) => {
  return {
    content: [{ type: 'text', text: JSON.stringify({ error: 'N√£o implementado' }) }],
  };
});

server.tool('get-todos', 'Listar todas as tarefas', async () => {
  return {
    content: [{ type: 'text', text: JSON.stringify({ error: 'N√£o implementado' }) }],
  };
});

server.tool('delete-todo', 'Excluir uma tarefa pelo id', { id: z.string() }, async ({ id }) => {
  return {
    content: [{ type: 'text', text: JSON.stringify({ error: 'N√£o implementado' }) }],
  };
});

// Abaixo est√° o c√≥digo boilerplate da documenta√ß√£o do MCP SDK
const PORT = 3001;
const app = express();

const transports = {};

app.get('/sse', async (_req, res) => {
  const transport = new SSEServerTransport('/messages', res);
  transports[transport.sessionId] = transport;

  res.on('close', () => {
    delete transports[transport.sessionId];
  });

  await server.connect(transport);
});

app.post('/messages', async (req, res) => {
  const sessionId = String(req.query.sessionId);
  const transport = transports[sessionId];
  if (transport) {
    await transport.handlePostMessage(req, res, req.body);
  } else {
    res.status(400).send('Nenhum transporte encontrado para sessionId');
  }
});

app.listen(PORT);
```

Execute o servidor com:

```bash
npm start
```

</TabItem>
</Tabs>

## Inspecione o servidor MCP \{#inspect-the-mcp-server}

### Clone e execute o MCP inspector \{#clone-and-run-mcp-inspector}

Agora que temos o servidor MCP rodando, podemos usar o MCP inspector para ver se a ferramenta `whoami` est√° dispon√≠vel.

Devido √† limita√ß√£o da implementa√ß√£o atual, fizemos um fork do [MCP inspector](https://github.com/mcp-auth/inspector) para torn√°-lo mais flex√≠vel e escal√°vel para autentica√ß√£o e autoriza√ß√£o. Tamb√©m enviamos um pull request para o reposit√≥rio original para incluir nossas altera√ß√µes.

Para rodar o MCP inspector, voc√™ pode usar o seguinte comando (Node.js √© necess√°rio):

```bash
git clone https://github.com/mcp-auth/inspector.git
cd inspector
npm install
npm run dev
```

Depois, abra seu navegador e acesse `http://localhost:6274/` (ou outro URL exibido no terminal) para acessar o MCP inspector.

### Conecte o MCP inspector ao servidor MCP \{#connect-mcp-inspector-to-the-mcp-server}

Antes de prosseguir, verifique a seguinte configura√ß√£o no MCP inspector:

- **Tipo de Transporte**: Defina como `SSE`.
- **URL**: Defina para a URL do seu servidor MCP. No nosso caso, deve ser `http://localhost:3001/sse`.

Agora voc√™ pode clicar no bot√£o "Connect" para ver se o MCP inspector consegue se conectar ao servidor MCP. Se tudo estiver certo, voc√™ ver√° o status "Connected" no MCP inspector.

### Checkpoint: Execute as ferramentas do gerenciador de tarefas \{#checkpoint-run-todo-manager-tools}

1. No menu superior do MCP inspector, clique na aba "Tools".
2. Clique no bot√£o "List Tools".
3. Voc√™ deve ver as ferramentas `create-todo`, `get-todos` e `delete-todo` listadas na p√°gina. Clique para abrir os detalhes da ferramenta.
4. Voc√™ deve ver o bot√£o "Run Tool" no lado direito. Clique nele e insira os par√¢metros necess√°rios para executar a ferramenta.
5. Voc√™ ver√° o resultado da ferramenta com a resposta JSON `{"error": "N√£o implementado"}`.

![Primeira execu√ß√£o do MCP inspector](/docs-assets/images/tutorials/todo-manager/inspector-first-run.png)

## Integre com seu servidor de autoriza√ß√£o \{#integrate-with-your-authorization-server}

Para concluir esta se√ß√£o, h√° v√°rias considera√ß√µes a serem feitas:

<details>
<summary>**A URL do emissor do seu servidor de autoriza√ß√£o**</summary>

Geralmente √© a URL base do seu servidor de autoriza√ß√£o, como `https://auth.example.com`. Alguns provedores podem ter um caminho como `https://example.logto.app/oidc`, ent√£o verifique a documenta√ß√£o do seu provedor.

</details>

<details>
<summary>**Como recuperar os metadados do servidor de autoriza√ß√£o**</summary>

- Se seu servidor de autoriza√ß√£o estiver em conformidade com o [OAuth 2.0 Authorization Server Metadata](https://datatracker.ietf.org/doc/html/rfc8414) ou [OpenID Connect Discovery](https://openid.net/specs/openid-connect-discovery-1_0.html), voc√™ pode usar as utilidades integradas do MCP Auth para buscar os metadados automaticamente.
- Se seu servidor de autoriza√ß√£o n√£o estiver em conformidade com esses padr√µes, voc√™ precisar√° especificar manualmente a URL dos metadados ou endpoints na configura√ß√£o do servidor MCP. Consulte a documenta√ß√£o do seu provedor para os endpoints espec√≠ficos.

</details>

<details>
<summary>**Como registrar o MCP inspector como cliente em seu servidor de autoriza√ß√£o**</summary>

- Se seu servidor de autoriza√ß√£o suporta [Registro Din√¢mico de Cliente](https://datatracker.ietf.org/doc/html/rfc7591), voc√™ pode pular esta etapa, pois o MCP inspector se registrar√° automaticamente como cliente.
- Se seu servidor de autoriza√ß√£o n√£o suporta Registro Din√¢mico de Cliente, voc√™ precisar√° registrar manualmente o MCP inspector como cliente em seu servidor de autoriza√ß√£o.

</details>

<details>
<summary>**Entenda os par√¢metros de solicita√ß√£o de token**</summary>

Ao solicitar tokens de acesso de diferentes servidores de autoriza√ß√£o, voc√™ encontrar√° v√°rias abordagens para especificar o recurso alvo e as permiss√µes. Aqui est√£o os principais padr√µes:

- **Baseado em indicador de recurso**:

  - Usa o par√¢metro `resource` para especificar a API alvo (veja [RFC 8707: Indicadores de Recurso para OAuth 2.0](https://datatracker.ietf.org/doc/html/rfc8707))
  - Comum em implementa√ß√µes modernas de OAuth 2.0
  - Exemplo de requisi√ß√£o:
    ```json
    {
      "resource": "https://todo.mcp-server.app",
      "scope": "create:todos read:todos"
    }
    ```
  - O servidor emite tokens vinculados especificamente ao recurso solicitado

- **Baseado em audi√™ncia**:

  - Usa o par√¢metro `audience` para especificar o destinat√°rio pretendido do token
  - Semelhante aos indicadores de recurso, mas com sem√¢nticas diferentes
  - Exemplo de requisi√ß√£o:
    ```json
    {
      "audience": "todo-api",
      "scope": "create:todos read:todos"
    }
    ```

- **Baseado apenas em escopo**:
  - Depende apenas de escopos sem par√¢metros de recurso/audi√™ncia
  - Abordagem tradicional do OAuth 2.0
  - Exemplo de requisi√ß√£o:
    ```json
    {
      "scope": "todo-api:create todo-api:read openid profile"
    }
    ```
  - Frequentemente usa escopos prefixados para namespacing de permiss√µes
  - Comum em implementa√ß√µes mais simples de OAuth 2.0

:::tip Melhores Pr√°ticas

- Verifique a documenta√ß√£o do seu provedor para os par√¢metros suportados
- Alguns provedores suportam m√∫ltiplas abordagens simultaneamente
- Indicadores de recurso fornecem melhor seguran√ßa por restri√ß√£o de audi√™ncia
- Considere usar indicadores de recurso quando dispon√≠veis para melhor controle de acesso
  :::

</details>

Embora cada provedor possa ter requisitos espec√≠ficos, os passos a seguir ir√£o gui√°-lo no processo de integra√ß√£o do MCP inspector e do servidor MCP com configura√ß√µes espec√≠ficas do provedor.

### Registre o MCP inspector como cliente \{#register-mcp-inspector-as-a-client}

<Tabs groupId="provider">
<TabItem value="logto" label="Logto">

Integrar o gerenciador de tarefas com o [Logto](https://logto.io) √© simples, pois √© um provedor OpenID Connect que suporta indicadores de recurso e escopos, permitindo proteger sua API de tarefas com `https://todo.mcp-server.app` como indicador de recurso.

Como o Logto ainda n√£o suporta Registro Din√¢mico de Cliente, voc√™ precisar√° registrar manualmente o MCP inspector como cliente em seu tenant Logto:

1. Abra seu MCP inspector, clique no bot√£o "OAuth Configuration". Copie o valor **Redirect URL (auto-populated)**, que deve ser algo como `http://localhost:6274/oauth/callback`.
2. Fa√ßa login no [Logto Console](https://cloud.logto.io) (ou em seu Logto Console auto-hospedado).
3. Navegue at√© a aba "Applications", clique em "Create application". No final da p√°gina, clique em "Create app without framework".
4. Preencha os detalhes do aplicativo e clique em "Create application":
   - **Selecione um tipo de aplicativo**: Escolha "Single-page application".
   - **Nome do aplicativo**: Insira um nome para seu aplicativo, por exemplo, "MCP Inspector".
5. Na se√ß√£o "Settings / Redirect URIs", cole o valor **Redirect URL (auto-populated)** copiado do MCP inspector. Depois clique em "Save changes" na barra inferior.
6. No card superior, voc√™ ver√° o valor "App ID". Copie-o.
7. Volte ao MCP inspector e cole o valor "App ID" na se√ß√£o "OAuth Configuration" em "Client ID".
8. Insira o valor `{"scope": "create:todos read:todos delete:todos", "resource": "https://todo.mcp-server.app"}` no campo "Auth Params". Isso garantir√° que o token de acesso retornado pelo Logto contenha os escopos necess√°rios para acessar o gerenciador de tarefas.

</TabItem>
<TabItem value="oauth-oidc" label="OAuth 2.0 / OIDC">

:::note
Este √© um guia gen√©rico de integra√ß√£o com provedores OAuth 2.0 / OpenID Connect. Ambos seguem passos semelhantes, pois OIDC √© constru√≠do sobre OAuth 2.0. Consulte a documenta√ß√£o do seu provedor para detalhes espec√≠ficos.
:::

Se seu provedor suporta Registro Din√¢mico de Cliente, voc√™ pode ir direto ao passo 8 abaixo para configurar o MCP inspector; caso contr√°rio, ser√° necess√°rio registrar manualmente o MCP inspector como cliente:

1. Abra seu MCP inspector, clique no bot√£o "OAuth Configuration". Copie o valor **Redirect URL (auto-populated)**, que deve ser algo como `http://localhost:6274/oauth/callback`.

2. Fa√ßa login no console do seu provedor.

3. Navegue at√© a se√ß√£o "Applications" ou "Clients" e crie um novo aplicativo ou cliente.

4. Se seu provedor exigir um tipo de cliente, selecione "Single-page application" ou "Public client".

5. Ap√≥s criar o aplicativo, ser√° necess√°rio configurar o redirect URI. Cole o valor **Redirect URL (auto-populated)** copiado do MCP inspector.

6. Encontre o "Client ID" ou "Application ID" do novo aplicativo e copie-o.

7. Volte ao MCP inspector e cole o valor "Client ID" na se√ß√£o "OAuth Configuration" em "Client ID".

8. Insira o seguinte valor no campo "Auth Params" para solicitar os escopos necess√°rios para opera√ß√µes de tarefas:

```json
{ "scope": "create:todos read:todos delete:todos" }
```

</TabItem>
</Tabs>

### Configure o MCP auth \{#set-up-mcp-auth}

No seu projeto do servidor MCP, voc√™ precisa instalar o SDK MCP Auth e configur√°-lo para usar os metadados do seu servidor de autoriza√ß√£o.

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

Primeiro, instale o pacote `mcpauth`:

```bash
pip install mcpauth
```

Ou qualquer outro gerenciador de pacotes de sua prefer√™ncia, como `uv` ou `poetry`.

</TabItem>
<TabItem value="node" label="Node.js">

Primeiro, instale o pacote `mcp-auth`:

```bash
npm install mcp-auth
```

</TabItem>
</Tabs>

O MCP Auth requer os metadados do servidor de autoriza√ß√£o para poder inicializar. Dependendo do seu provedor:

<Tabs groupId="provider">

<TabItem value="logto" label="Logto">

A URL do emissor pode ser encontrada na p√°gina de detalhes do seu aplicativo no Logto Console, na se√ß√£o "Endpoints & Credentials / Issuer endpoint". Deve ser algo como `https://meu-projeto.logto.app/oidc`.

<SetupOidc />

</TabItem>

<TabItem value="oauth-oidc" label="OAuth 2.0 / OIDC">

Para provedores OAuth 2.0, voc√™ precisar√°:

1. Verificar a documenta√ß√£o do seu provedor para a URL do servidor de autoriza√ß√£o (geralmente chamada de issuer URL ou base URL)
2. Alguns provedores podem expor isso em `https://{seu-dominio}/.well-known/oauth-authorization-server`
3. Procurar no console administrativo do seu provedor em configura√ß√µes OAuth/API

<SetupOauthOrOidc />

</TabItem>

</Tabs>

<Tabs groupId="sdk">

<TabItem value="python" label="Python">

Atualize o `todo-manager.py` para incluir a configura√ß√£o do MCP Auth:

```python
from mcpauth import MCPAuth
from mcpauth.config import AuthServerType
from mcpauth.utils import fetch_server_config

auth_issuer = '<issuer-endpoint>'  # Substitua pelo endpoint do seu emissor
auth_server_config = fetch_server_config(auth_issuer, type=AuthServerType.OIDC)
mcp_auth = MCPAuth(server=auth_server_config)
```

</TabItem>
<TabItem value="node" label="Node.js">

Atualize o `todo-manager.ts` para incluir a configura√ß√£o do MCP Auth:

```ts
// todo-manager.ts

import { MCPAuth, fetchServerConfig } from 'mcp-auth';

const authIssuer = '<issuer-endpoint>'; // Substitua pelo endpoint do seu emissor
const mcpAuth = new MCPAuth({
  server: await fetchServerConfig(authIssuer, { type: 'oidc' }),
});
```

</TabItem>
</Tabs>

### Atualize o servidor MCP \{#update-mcp-server}

Estamos quase l√°! √â hora de atualizar o servidor MCP para aplicar a rota e middleware do MCP Auth, depois implementar o controle de acesso baseado em permiss√µes para as ferramentas do gerenciador de tarefas com base nos escopos do usu√°rio.

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

```python
@mcp.tool()
def create_todo(content: str) -> dict[str, Any]:
    """Criar uma nova tarefa."""
    return (
        mcp_auth.auth_info.scopes
        if mcp_auth.auth_info # Isso ser√° preenchido pelo middleware Bearer auth
        else {"error": "N√£o autenticado"}
    )

# ...

bearer_auth = Middleware(mcp_auth.bearer_auth_middleware("jwt"))
app = Starlette(
    routes=[
        # Adicione a rota de metadados (`/.well-known/oauth-authorization-server`)
        mcp_auth.metadata_route(),
        # Proteja o servidor MCP com o middleware Bearer auth
        Mount('/', app=mcp.sse_app(), middleware=[bearer_auth]),
    ],
)
```

</TabItem>
<TabItem value="node" label="Node.js">

```js
server.tool(
  'create-todo',
  'Criar uma nova tarefa',
  { content: z.string() },
  async ({ content, authInfo }) => {
    return {
      content: [
        { type: 'text', text: JSON.stringify(authInfo?.scopes ?? { error: 'N√£o autenticado' }) },
      ],
    };
  }
);

// ...

app.use(mcpAuth.delegatedRouter());
app.use(mcpAuth.bearerAuth('jwt'));
```

</TabItem>
</Tabs>

Em seguida, vamos implementar as ferramentas espec√≠ficas.

Primeiro, vamos criar um servi√ßo simples de tarefas para fornecer opera√ß√µes b√°sicas de CRUD para gerenciar itens de tarefas em mem√≥ria.

<Tabs groupId="sdk">
<TabItem value="python" label="Python">
```python
# service.py

"""
Um servi√ßo simples de Tarefas para fins de demonstra√ß√£o.
Usa uma lista em mem√≥ria para armazenar tarefas.
"""

from datetime import datetime
from typing import List, Optional, Dict, Any
import random
import string

class Todo:
"""Representa um item de tarefa."""

    def __init__(self, id: str, content: str, owner_id: str, created_at: str):
        self.id = id
        self.content = content
        self.owner_id = owner_id
        self.created_at = created_at

    def to_dict(self) -> Dict[str, Any]:
        """Converte a tarefa para dicion√°rio para serializa√ß√£o JSON."""
        return {
            "id": self.id,
            "content": self.content,
            "ownerId": self.owner_id,
            "createdAt": self.created_at
        }

class TodoService:
"""Um servi√ßo simples de Tarefas para fins de demonstra√ß√£o."""

    def __init__(self):
        self._todos: List[Todo] = []

    def get_all_todos(self, owner_id: Optional[str] = None) -> List[Dict[str, Any]]:
        """
        Obt√©m todas as tarefas, opcionalmente filtradas por owner_id.

        Args:
            owner_id: Se fornecido, retorna apenas tarefas deste usu√°rio

        Returns:
            Lista de dicion√°rios de tarefas
        """
        if owner_id:
            filtered_todos = [todo for todo in self._todos if todo.owner_id == owner_id]
            return [todo.to_dict() for todo in filtered_todos]
        return [todo.to_dict() for todo in self._todos]

    def get_todo_by_id(self, todo_id: str) -> Optional[Todo]:
        """
        Obt√©m uma tarefa pelo ID.

        Args:
            todo_id: O ID da tarefa a ser recuperada

        Returns:
            Objeto Todo se encontrado, None caso contr√°rio
        """
        for todo in self._todos:
            if todo.id == todo_id:
                return todo
        return None

    def create_todo(self, content: str, owner_id: str) -> Dict[str, Any]:
        """
        Cria uma nova tarefa.

        Args:
            content: O conte√∫do da tarefa
            owner_id: O ID do usu√°rio dono da tarefa

        Returns:
            Dicion√°rio da tarefa criada
        """
        todo = Todo(
            id=self._generate_id(),
            content=content,
            owner_id=owner_id,
            created_at=datetime.now().isoformat()
        )
        self._todos.append(todo)
        return todo.to_dict()

    def delete_todo(self, todo_id: str) -> Optional[Dict[str, Any]]:
        """
        Exclui uma tarefa pelo ID.

        Args:
            todo_id: O ID da tarefa a ser exclu√≠da

        Returns:
            Dicion√°rio da tarefa exclu√≠da se encontrada, None caso contr√°rio
        """
        for i, todo in enumerate(self._todos):
            if todo.id == todo_id:
                deleted_todo = self._todos.pop(i)
                return deleted_todo.to_dict()
        return None

    def _generate_id(self) -> str:
        """Gera um ID aleat√≥rio para uma tarefa."""
        return ''.join(random.choices(string.ascii_lowercase + string.digits, k=8))

````


</TabItem>
<TabItem value="node" label="Node.js">

```ts
// todo-service.ts

type Todo = {
  id: string;
  content: string;
  ownerId: string;
  createdAt: string;
};

/**
 * Um servi√ßo simples de Tarefas para fins de demonstra√ß√£o.
 * Usa um array em mem√≥ria para armazenar tarefas
 */
export class TodoService {
  private readonly todos: Todo[] = [];

  getAllTodos(ownerId?: string): Todo[] {
    if (ownerId) {
      return this.todos.filter((todo) => todo.ownerId === ownerId);
    }
    return this.todos;
  }

  getTodoById(id: string): Todo | undefined {
    return this.todos.find((todo) => todo.id === id);
  }

  createTodo({ content, ownerId }: { content: string; ownerId: string }): Todo {
    const todo: Todo = {
      id: this.genId(),
      content,
      ownerId,
      createdAt: new Date().toISOString(),
    };

    // eslint-disable-next-line @silverhand/fp/no-mutating-methods
    this.todos.push(todo);
    return todo;
  }

  deleteTodo(id: string): Todo | undefined {
    const index = this.todos.findIndex((todo) => todo.id === id);

    if (index === -1) {
      return undefined;
    }

    // eslint-disable-next-line @silverhand/fp/no-mutating-methods
    const [deleted] = this.todos.splice(index, 1);
    return deleted;
  }

  private genId(): string {
    return Math.random().toString(36).slice(2, 10);
  }
}
````

</TabItem>
</Tabs>

ent√£o na camada de ferramentas, vamos determinar se as opera√ß√µes s√£o permitidas com base nos escopos do usu√°rio:

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

```python
# todo-manager.py

from typing import Any, Optional
from mcpauth.errors import MCPAuthBearerAuthError

def assert_user_id(auth_info: Optional[dict]) -> str:
    """Extrai e valida o ID do usu√°rio do auth info."""
    subject = auth_info.get('subject') if auth_info else None
    if not subject:
        raise ValueError('Informa√ß√£o de autentica√ß√£o inv√°lida')
    return subject

def has_required_scopes(user_scopes: list[str], required_scopes: list[str]) -> bool:
    """Verifica se o usu√°rio possui todos os escopos necess√°rios."""
    return all(scope in user_scopes for scope in required_scopes)

# Crie uma inst√¢ncia do TodoService
todo_service = TodoService()

@mcp.tool()
def create_todo(content: str) -> dict[str, Any]:
    """Criar uma nova tarefa.

    Apenas usu√°rios com o escopo 'create:todos' podem criar tarefas.
    """
    # Obter informa√ß√µes de autentica√ß√£o
    auth_info = mcp_auth.auth_info

    # Validar ID do usu√°rio
    try:
        user_id = assert_user_id(auth_info)
    except ValueError as e:
        return {"error": str(e)}

    # Verificar se o usu√°rio possui as permiss√µes necess√°rias
    if not has_required_scopes(auth_info.scopes if auth_info else [], ['create:todos']):
        raise MCPAuthBearerAuthError('missing_required_scopes')

    # Criar nova tarefa
    created_todo = todo_service.create_todo(content=content, owner_id=user_id)

    # Retornar a tarefa criada
    return created_todo.__dict__

# ...
```

Voc√™ pode conferir nosso [c√≥digo de exemplo](https://github.com/mcp-auth/python/tree/master/samples/server) para todas as outras implementa√ß√µes detalhadas.

</TabItem>
<TabItem value="node" label="Node.js">

```ts
// todo-manager.ts

// ... outros imports
import assert from 'node:assert';
import { type AuthInfo } from '@modelcontextprotocol/sdk/server/auth/types.js';
import { TodoService } from './todo-service.js';

const todoService = new TodoService();

const assertUserId = (authInfo?: AuthInfo) => {
  const { subject } = authInfo ?? {};
  assert(subject, 'Informa√ß√£o de autentica√ß√£o inv√°lida');
  return subject;
};

/**
 * Verifica se o usu√°rio possui todos os escopos necess√°rios para uma opera√ß√£o
 */
const hasRequiredScopes = (userScopes: string[], requiredScopes: string[]): boolean => {
  return requiredScopes.every((scope) => userScopes.includes(scope));
};

server.tool(
  'create-todo',
  'Criar uma nova tarefa',
  { content: z.string() },
  ({ content }: { content: string }, { authInfo }) => {
    const userId = assertUserId(authInfo);

    /**
     * Apenas usu√°rios com o escopo 'create:todos' podem criar tarefas
     */
    if (!hasRequiredScopes(authInfo?.scopes ?? [], ['create:todos'])) {
      throw new MCPAuthBearerAuthError('missing_required_scopes');
    }

    const createdTodo = todoService.createTodo({ content, ownerId: userId });

    return {
      content: [{ type: 'text', text: JSON.stringify(createdTodo) }],
    };
  }
);

// ...
```

Voc√™ pode conferir nosso [c√≥digo de exemplo](https://github.com/mcp-auth/js/tree/master/packages/sample-servers/src/todo-manager) para todas as outras implementa√ß√µes detalhadas.

</TabItem>
</Tabs>

## Checkpoint: Execute as ferramentas `todo-manager` \{#checkpoint-run-the-todo-manager-tools}

Reinicie seu servidor MCP e abra o MCP inspector no navegador. Ao clicar no bot√£o "Connect", voc√™ ser√° redirecionado para a p√°gina de login do seu servidor de autoriza√ß√£o.

Depois de fazer login e retornar ao MCP inspector, repita as a√ß√µes do checkpoint anterior para executar as ferramentas do gerenciador de tarefas. Desta vez, voc√™ poder√° usar essas ferramentas com sua identidade de usu√°rio autenticada. O comportamento das ferramentas depender√° dos pap√©is e permiss√µes atribu√≠dos ao seu usu√°rio:

- Se voc√™ estiver logado como **User** (com apenas o escopo `create:todos`):

  - Voc√™ pode criar novas tarefas usando a ferramenta `create-todo`
  - Voc√™ s√≥ poder√° visualizar e excluir suas pr√≥prias tarefas
  - N√£o poder√° ver ou excluir tarefas de outros usu√°rios

- Se estiver logado como **Admin** (com todos os escopos: `create:todos`, `read:todos`, `delete:todos`):
  - Voc√™ pode criar novas tarefas
  - Pode visualizar todas as tarefas do sistema usando a ferramenta `get-todos`
  - Pode excluir qualquer tarefa usando a ferramenta `delete-todo`, independentemente de quem a criou

Voc√™ pode testar esses diferentes n√≠veis de permiss√£o:

1. Saindo da sess√£o atual (clique no bot√£o "Disconnect" no MCP inspector)
2. Fazendo login com outra conta de usu√°rio que tenha pap√©is/permiss√µes diferentes
3. Tentando as mesmas ferramentas novamente para observar como o comportamento muda de acordo com as permiss√µes do usu√°rio

Isso demonstra como o controle de acesso baseado em papel (RBAC) funciona na pr√°tica, onde diferentes usu√°rios t√™m diferentes n√≠veis de acesso √† funcionalidade do sistema.

![Resultado da ferramenta do gerenciador de tarefas no MCP inspector](/docs-assets/images/tutorials/todo-manager/result.png)

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

:::info
Confira o [reposit√≥rio do MCP Auth Python SDK](https://github.com/mcp-auth/python/blob/master/samples/server/todo-manager/server.py) para o c√≥digo completo do servidor MCP (vers√£o OIDC).
:::

</TabItem>
<TabItem value="node" label="Node.js">

:::info
Confira o [reposit√≥rio do MCP Auth Node.js SDK](https://github.com/mcp-auth/js/blob/master/packages/sample-servers/src) para o c√≥digo completo do servidor MCP (vers√£o OIDC).
:::

</TabItem>
</Tabs>

## Notas finais \{#closing-notes}

üéä Parab√©ns! Voc√™ concluiu com sucesso o tutorial. Vamos recapitular o que fizemos:

- Configura√ß√£o de um servidor MCP b√°sico com ferramentas de gerenciamento de tarefas (`create-todo`, `get-todos`, `delete-todo`)
- Implementa√ß√£o de controle de acesso baseado em papel (RBAC) com diferentes n√≠veis de permiss√£o para usu√°rios e administradores
- Integra√ß√£o do servidor MCP com um servidor de autoriza√ß√£o usando MCP Auth
- Configura√ß√£o do MCP Inspector para autenticar usu√°rios e usar tokens de acesso com escopos para chamar ferramentas

N√£o deixe de conferir outros tutoriais e a documenta√ß√£o para aproveitar ao m√°ximo o MCP Auth.
---
sidebar_position: 2
sidebar_label: 'Tutorial: Construa um gerenciador de tarefas'
---

import TabItem from '@theme/TabItem';
import Tabs from '@theme/Tabs';


# Tutorial: Construa um gerenciador de tarefas

Neste tutorial, vamos construir um servidor MCP de gerenciador de tarefas com autentica√ß√£o e autoriza√ß√£o de usu√°rio. Seguindo a especifica√ß√£o MCP mais recente, nosso servidor MCP atuar√° como um **Servidor de Recursos (Resource Server)** OAuth 2.0 que valida tokens de acesso e aplica permiss√µes baseadas em escopo.

Ap√≥s concluir este tutorial, voc√™ ter√°:

- ‚úÖ Uma compreens√£o b√°sica de como configurar controle de acesso baseado em papel (RBAC) em seu servidor MCP.
- ‚úÖ Um servidor MCP que atua como um Servidor de Recursos, consumindo tokens de acesso emitidos por um Servidor de Autoriza√ß√£o.
- ‚úÖ Uma implementa√ß√£o funcional de aplica√ß√£o de permiss√µes baseadas em escopo para opera√ß√µes de tarefas.

## Vis√£o geral \{#overview}

O tutorial envolver√° os seguintes componentes:

- **Cliente MCP (MCP Inspector)**: Uma ferramenta visual de testes para servidores MCP que atua como um cliente OAuth 2.0/OIDC. Ele inicia o fluxo de autoriza√ß√£o com o servidor de autoriza√ß√£o e obt√©m tokens de acesso para autenticar requisi√ß√µes ao servidor MCP.
- **Servidor de Autoriza√ß√£o**: Um provedor OAuth 2.1 ou OpenID Connect que gerencia identidades de usu√°rios, autentica usu√°rios e emite tokens de acesso com escopos apropriados para clientes autorizados.
- **Servidor MCP (Servidor de Recursos)**: De acordo com a especifica√ß√£o MCP mais recente, o servidor MCP atua como um Servidor de Recursos no framework OAuth 2.0. Ele valida tokens de acesso emitidos pelo servidor de autoriza√ß√£o e aplica permiss√µes baseadas em escopo para opera√ß√µes de tarefas.

Esta arquitetura segue o fluxo padr√£o do OAuth 2.0 onde:
- O **MCP Inspector** solicita recursos protegidos em nome do usu√°rio
- O **Servidor de Autoriza√ß√£o** autentica o usu√°rio e emite tokens de acesso
- O **Servidor MCP** valida tokens e serve recursos protegidos com base nas permiss√µes concedidas

Aqui est√° um diagrama de alto n√≠vel da intera√ß√£o entre esses componentes:

```mermaid
sequenceDiagram
  autonumber
  participant Client as MCP Inspector<br/>(Cliente OAuth)
  participant RS as Servidor MCP<br/>(Servidor de Recursos)
  participant AS as Servidor de Autoriza√ß√£o

  Client->>RS: Requisi√ß√£o MCP (sem token)
  RS-->>Client: 401 N√£o autorizado (WWW-Authenticate)
  Note over Client: Extrair URL resource_metadata<br/>do cabe√ßalho WWW-Authenticate

  Client->>RS: GET /.well-known/oauth-protected-resource (resource_metadata)
  RS-->>Client: Metadados do recurso protegido<br/>(inclui URL do servidor de autoriza√ß√£o)

  Client->>AS: GET /.well-known/oauth-authorization-server
  AS-->>Client: Metadados do servidor de autoriza√ß√£o
  Client->>AS: Autoriza√ß√£o OAuth (login & consentimento)
  AS-->>Client: Token de acesso

  Client->>RS: Requisi√ß√£o MCP (Authorization: Bearer <token>)
  RS->>RS: Validar se o token de acesso √© v√°lido e autorizado
  RS-->>Client: Resposta MCP
```

## Entenda seu servidor de autoriza√ß√£o \{#understand-your-authorization-server}

### Tokens de acesso com escopos \{#access-tokens-with-scopes}

Para implementar [controle de acesso baseado em papel (RBAC)](https://auth.wiki/rbac) em seu servidor MCP, seu servidor de autoriza√ß√£o precisa suportar a emiss√£o de tokens de acesso com escopos. Escopos representam as permiss√µes que um usu√°rio recebeu.

<Tabs groupId="provider">
<TabItem value="logto" label="Logto">

[Logto](https://logto.io) oferece suporte a RBAC por meio de seus recursos de API (conforme [RFC 8707: Resource Indicators for OAuth 2.0](https://datatracker.ietf.org/doc/html/rfc8707)) e funcionalidades de pap√©is. Veja como configurar:

1. Fa√ßa login no [Logto Console](https://cloud.logto.io) (ou em seu Logto Console auto-hospedado)

2. Crie recurso de API e escopos:

   - V√° para "Recursos de API"
   - Crie um novo recurso de API chamado "Todo Manager"
   - Adicione os seguintes escopos:
     - `create:todos`: "Criar novos itens de tarefa"
     - `read:todos`: "Ler todos os itens de tarefa"
     - `delete:todos`: "Excluir qualquer item de tarefa"

3. Crie pap√©is (recomendado para facilitar o gerenciamento):

   - V√° para "Pap√©is"
   - Crie um papel "Admin" e atribua todos os escopos (`create:todos`, `read:todos`, `delete:todos`)
   - Crie um papel "User" e atribua apenas o escopo `create:todos`

4. Atribua permiss√µes:
   - V√° para "Usu√°rios"
   - Selecione um usu√°rio
   - Voc√™ pode:
     - Atribuir pap√©is na aba "Pap√©is" (recomendado)
     - Ou atribuir escopos diretamente na aba "Permiss√µes"

Os escopos ser√£o inclu√≠dos na reivindica√ß√£o `scope` do token de acesso JWT como uma string separada por espa√ßos.

</TabItem>
<TabItem value="oauth-oidc" label="OAuth 2.0 / OIDC">

Provedores OAuth 2.0 / OIDC normalmente suportam controle de acesso baseado em escopo. Ao implementar RBAC:

1. Defina os escopos necess√°rios em seu servidor de autoriza√ß√£o
2. Configure seu cliente para solicitar esses escopos durante o fluxo de autoriza√ß√£o
3. Certifique-se de que seu servidor de autoriza√ß√£o inclua os escopos concedidos no token de acesso
4. Os escopos geralmente s√£o inclu√≠dos na reivindica√ß√£o `scope` do token de acesso JWT

Consulte a documenta√ß√£o do seu provedor para detalhes espec√≠ficos sobre:

- Como definir e gerenciar escopos
- Como os escopos s√£o inclu√≠dos no token de acesso
- Quaisquer recursos adicionais de RBAC, como gerenciamento de pap√©is

</TabItem>
</Tabs>

### Validando tokens e verificando permiss√µes \{#validating-tokens-and-checking-permissions}

De acordo com a especifica√ß√£o MCP mais recente, o servidor MCP atua como um **Servidor de Recursos (Resource Server)** no framework OAuth 2.0. Como Servidor de Recursos, o servidor MCP tem as seguintes responsabilidades:

1. **Valida√ß√£o de Token**: Verificar a autenticidade e integridade dos tokens de acesso recebidos dos clientes MCP
2. **Aplica√ß√£o de Escopo**: Extrair e validar os escopos do token de acesso para determinar quais opera√ß√µes o cliente est√° autorizado a executar
3. **Prote√ß√£o de Recursos**: Servir apenas recursos protegidos (executar ferramentas) quando o cliente apresentar tokens v√°lidos com permiss√µes suficientes

Quando seu servidor MCP recebe uma requisi√ß√£o, ele executa o seguinte processo de valida√ß√£o:

1. Extrai o token de acesso do cabe√ßalho `Authorization` (formato Bearer token)
2. Valida a assinatura e expira√ß√£o do token de acesso
3. Extrai os escopos e informa√ß√µes do usu√°rio do token validado
4. Verifica se o token possui os escopos necess√°rios para a opera√ß√£o solicitada

Por exemplo, se um usu√°rio quiser criar um novo item de tarefa, seu token de acesso deve incluir o escopo `create:todos`. Veja como funciona o fluxo de valida√ß√£o do Servidor de Recursos:

```mermaid
sequenceDiagram
    participant Client as Cliente MCP
    participant Server as Servidor MCP<br/>(Servidor de Recursos)
    participant Auth as Servidor de Autoriza√ß√£o

    Client->>Server: Requisi√ß√£o com token de acesso<br/>(Authorization: Bearer <token>)

    alt Valida√ß√£o JWT (Preferencial)
        Server->>Auth: Buscar JWKS (se n√£o estiver em cache)
        Auth-->>Server: Retornar JWKS
        Server->>Server: Validar assinatura e reivindica√ß√µes do JWT localmente
    else Introspec√ß√£o de Token (Alternativa)
        Server->>Auth: POST /introspect<br/>(token=access_token)
        Auth-->>Server: Retornar informa√ß√µes do token<br/>(active, scope, user_id, etc.)
    end

    Server->>Server: Extrair escopos e contexto do usu√°rio<br/>do token validado

    alt Possui escopos necess√°rios
        Server->>Server: Executar opera√ß√£o solicitada
        Server->>Client: Retornar resultado da opera√ß√£o
    else Faltam escopos necess√°rios
        Server->>Client: Retornar 403 Proibido<br/>(erro insufficient_scope)
    end
```

### Registro Din√¢mico de Cliente \{#dynamic-client-registration}

O Registro Din√¢mico de Cliente n√£o √© necess√°rio para este tutorial, mas pode ser √∫til se voc√™ quiser automatizar o processo de registro do cliente MCP com seu servidor de autoriza√ß√£o. Veja [O Registro Din√¢mico de Cliente √© necess√°rio?](/provider-list#is-dcr-required) para mais detalhes.

## Entenda o RBAC no gerenciador de tarefas \{#understand-rbac-in-todo-manager}

Para fins de demonstra√ß√£o, implementaremos um sistema simples de controle de acesso baseado em papel (RBAC) em nosso servidor MCP de gerenciador de tarefas. Isso mostrar√° os princ√≠pios b√°sicos do RBAC mantendo a implementa√ß√£o direta.

:::note
Embora este tutorial demonstre o gerenciamento de escopos baseado em RBAC, √© importante observar que nem todos os provedores de autentica√ß√£o implementam o gerenciamento de escopos por meio de pap√©is. Alguns provedores podem ter suas pr√≥prias implementa√ß√µes e mecanismos exclusivos para gerenciar controle de acesso e permiss√µes.
:::

### Ferramentas e escopos \{#tools-and-scopes}

Nosso servidor MCP de gerenciador de tarefas fornece tr√™s ferramentas principais:

- `create-todo`: Criar um novo item de tarefa
- `get-todos`: Listar todas as tarefas
- `delete-todo`: Excluir uma tarefa pelo ID

Para controlar o acesso a essas ferramentas, definimos os seguintes escopos:

- `create:todos`: Permite criar novos itens de tarefa
- `delete:todos`: Permite excluir itens de tarefa existentes
- `read:todos`: Permite consultar e recuperar a lista de todos os itens de tarefa

### Pap√©is e permiss√µes \{#roles-and-permissions}

Definiremos dois pap√©is com diferentes n√≠veis de acesso:

| Papel | create:todos | read:todos | delete:todos |
| ----- | ------------ | ---------- | ------------ |
| Admin | ‚úÖ           | ‚úÖ         | ‚úÖ           |
| User  | ‚úÖ           |            |              |

- **User**: Um usu√°rio comum que pode criar tarefas e visualizar ou excluir apenas suas pr√≥prias tarefas
- **Admin**: Um administrador que pode criar, visualizar e excluir todas as tarefas, independentemente da propriedade

### Propriedade do recurso \{#resource-ownership}

Embora a tabela de permiss√µes acima mostre os escopos expl√≠citos atribu√≠dos a cada papel, h√° um princ√≠pio importante de propriedade de recurso a considerar:

- **Usu√°rios** n√£o possuem os escopos `read:todos` ou `delete:todos`, mas ainda podem:
  - Ler seus pr√≥prios itens de tarefa
  - Excluir seus pr√≥prios itens de tarefa
- **Admins** possuem permiss√µes totais (`read:todos` e `delete:todos`), permitindo que:
  - Visualizem todas as tarefas do sistema
  - Excluam qualquer tarefa, independentemente da propriedade

Isso demonstra um padr√£o comum em sistemas RBAC onde a propriedade do recurso concede permiss√µes impl√≠citas aos usu√°rios para seus pr√≥prios recursos, enquanto pap√©is administrativos recebem permiss√µes expl√≠citas para todos os recursos.

:::tip Saiba mais
Para se aprofundar nos conceitos e melhores pr√°ticas de RBAC, confira [Dominando RBAC: Um Exemplo Abrangente do Mundo Real](https://blog.logto.io/mastering-rbac).
:::

## Configure a autoriza√ß√£o em seu provedor \{#configure-authorization-in-your-provider}

Para implementar o sistema de controle de acesso que descrevemos anteriormente, voc√™ precisar√° configurar seu servidor de autoriza√ß√£o para suportar os escopos necess√°rios. Veja como fazer isso com diferentes provedores:

<Tabs groupId="provider">
<TabItem value="logto" label="Logto">

[Logto](https://logto.io) oferece suporte a RBAC por meio de recursos de API e funcionalidades de pap√©is. Veja como configurar:

1. Fa√ßa login no [Logto Console](https://cloud.logto.io) (ou em seu Logto Console auto-hospedado)

2. Crie recurso de API e escopos:

   - V√° para "Recursos de API"
   - Crie um novo recurso de API chamado "Todo Manager" usando `http://localhost:3001` como indicador de recurso.
     - **Importante**: O indicador de recurso deve corresponder √† URL do seu servidor MCP. Para este tutorial, usamos `http://localhost:3001` j√° que nosso servidor MCP roda na porta 3001. Em produ√ß√£o, use a URL real do seu servidor MCP (por exemplo, `https://seu-servidor-mcp.exemplo.com`).
   - Crie os seguintes escopos:
     - `create:todos`: "Criar novos itens de tarefa"
     - `read:todos`: "Ler todos os itens de tarefa"
     - `delete:todos`: "Excluir qualquer item de tarefa"

3. Crie pap√©is (recomendado para facilitar o gerenciamento):

   - V√° para "Pap√©is"
   - Crie um papel "Admin" e atribua todos os escopos (`create:todos`, `read:todos`, `delete:todos`)
   - Crie um papel "User" e atribua apenas o escopo `create:todos`
   - Na p√°gina de detalhes do papel "User", v√° para a aba "Geral" e defina o papel "User" como o "Papel padr√£o".

4. Gerencie pap√©is e permiss√µes dos usu√°rios:
   - Para novos usu√°rios:
     - Eles receber√£o automaticamente o papel "User" j√° que o definimos como papel padr√£o
   - Para usu√°rios existentes:
     - V√° para "Gerenciamento de usu√°rios"
     - Selecione um usu√°rio
     - Atribua pap√©is para o usu√°rio na aba "Pap√©is"

:::tip Gerenciamento de Pap√©is Program√°tico
Voc√™ tamb√©m pode usar a [Management API](https://docs.logto.io/integrate-logto/interact-with-management-api) do Logto para gerenciar pap√©is de usu√°rios programaticamente. Isso √© especialmente √∫til para gerenciamento automatizado de usu√°rios ou ao construir pain√©is administrativos.
:::

Ao solicitar um token de acesso, o Logto incluir√° os escopos na reivindica√ß√£o `scope` do token com base nas permiss√µes do papel do usu√°rio.

</TabItem>
<TabItem value="oauth-or-oidc" label="OAuth 2 / OIDC">

Para provedores OAuth 2.0 ou OpenID Connect, voc√™ precisar√° configurar os escopos que representam diferentes permiss√µes. Os passos exatos depender√£o do seu provedor, mas geralmente:

1. Defina escopos:

   - Configure seu servidor de autoriza√ß√£o para suportar:
     - `create:todos`
     - `read:todos`
     - `delete:todos`

2. Configure o cliente:

   - Registre ou atualize seu cliente para solicitar esses escopos
   - Certifique-se de que os escopos estejam inclu√≠dos no token de acesso

3. Atribua permiss√µes:
   - Use a interface do seu provedor para conceder escopos apropriados aos usu√°rios
   - Alguns provedores podem suportar gerenciamento baseado em pap√©is, enquanto outros podem usar atribui√ß√µes diretas de escopos
   - Consulte a documenta√ß√£o do seu provedor para a abordagem recomendada

:::tip
A maioria dos provedores incluir√° os escopos concedidos na reivindica√ß√£o `scope` do token de acesso. O formato geralmente √© uma string de escopos separados por espa√ßo.
:::

</TabItem>
</Tabs>

Ap√≥s configurar seu servidor de autoriza√ß√£o, os usu√°rios receber√£o tokens de acesso contendo seus escopos concedidos. O servidor MCP usar√° esses escopos para determinar:

- Se um usu√°rio pode criar novas tarefas (`create:todos`)
- Se um usu√°rio pode visualizar todas as tarefas (`read:todos`) ou apenas as suas pr√≥prias
- Se um usu√°rio pode excluir qualquer tarefa (`delete:todos`) ou apenas as suas pr√≥prias

## Configure o servidor MCP \{#set-up-the-mcp-server}

Usaremos os [SDKs oficiais MCP](https://github.com/modelcontextprotocol) para criar nosso servidor MCP de gerenciador de tarefas.

### Crie um novo projeto \{#create-a-new-project}

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

Configure um novo projeto Python:

```bash
mkdir mcp-todo-server
cd mcp-todo-server

# Inicialize um novo projeto Python
uv init

# Crie um novo ambiente virtual usando uv
uv venv

# Ative o ambiente virtual (opcional ao usar 'uv run')
source .venv/bin/activate
```

:::note
Este projeto usa `uv` para gerenciamento de pacotes, mas voc√™ pode usar outros gerenciadores como `pip`, `poetry` ou `conda` se preferir.
:::

</TabItem>
<TabItem value="node" label="Node.js">

Configure um novo projeto Node.js:

```bash
mkdir mcp-server
cd mcp-server
npm init -y # Ou use `pnpm init`
npm pkg set type="module"
npm pkg set main="todo-manager.ts"
npm pkg set scripts.start="node --experimental-strip-types todo-manager.ts"
```

:::note
Estamos usando TypeScript em nossos exemplos, pois o Node.js v22.6.0+ suporta execu√ß√£o nativa de TypeScript usando a flag `--experimental-strip-types`. Se voc√™ estiver usando JavaScript, o c√≥digo ser√° semelhante - apenas certifique-se de usar Node.js v22.6.0 ou superior. Veja a documenta√ß√£o do Node.js para detalhes.
:::

</TabItem>
</Tabs>

### Instale o MCP SDK e depend√™ncias \{#install-the-mcp-sdk-and-dependencies}

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

Instale as depend√™ncias necess√°rias:

```bash
uv add "mcp[cli]" uvicorn starlette
```

</TabItem>
<TabItem value="node" label="Node.js">

```bash
npm install @modelcontextprotocol/sdk express zod
```

Ou qualquer outro gerenciador de pacotes de sua prefer√™ncia, como `pnpm` ou `yarn`.

</TabItem>
</Tabs>

### Crie o servidor MCP \{#create-the-mcp-server}

Primeiro, vamos criar um servidor MCP b√°sico com as defini√ß√µes das ferramentas:

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

Crie um arquivo chamado `server.py` e adicione o seguinte c√≥digo:

```python
# server.py

import contextlib
from typing import Any
from mcp.server.fastmcp import FastMCP
from starlette.applications import Starlette
from starlette.routing import Mount

# Inicialize o servidor FastMCP
mcp = FastMCP(name="Todo Manager", stateless_http=True, streamable_http_path='/')

@mcp.tool()
def create_todo(content: str) -> dict[str, Any]:
    """Cria uma nova tarefa. Requer escopo 'create:todos'."""
    return {"error": "Not implemented"}

@mcp.tool()
def get_todos() -> dict[str, Any]:
    """Lista tarefas. Usu√°rios com escopo 'read:todos' podem ver todas as tarefas."""
    return {"error": "Not implemented"}

@mcp.tool()
def delete_todo(id: str) -> dict[str, Any]:
    """Exclui uma tarefa pelo id. Usu√°rios podem excluir suas pr√≥prias tarefas."""
    return {"error": "Not implemented"}

@contextlib.asynccontextmanager
async def lifespan(app: Starlette):
    async with contextlib.AsyncExitStack() as stack:
        await stack.enter_async_context(mcp.session_manager.run())
        yield

# Crie o app
app = Starlette(
    routes=[
        Mount("/", app=mcp.streamable_http_app()),
    ],
    lifespan=lifespan,
)
```

Execute o servidor com:

```bash
# Inicie o servidor Todo Manager usando uvicorn
uvicorn server:app --host 127.0.0.1 --port 3001

# Ou usando uv:
# uv run uvicorn server:app --host 127.0.0.1 --port 3001
```

</TabItem>
<TabItem value="node" label="Node.js">

Crie um arquivo chamado `todo-manager.ts` e adicione o seguinte c√≥digo:

```ts
// todo-manager.ts

import { z } from 'zod';
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { StreamableHTTPServerTransport } from '@modelcontextprotocol/sdk/server/streamableHttp.js';
import express, { type Request, type Response } from 'express';

// Crie um servidor MCP
const server = new McpServer({
  name: 'Todo Manager',
  version: '0.0.0',
});

server.tool('create-todo', 'Criar uma nova tarefa', { content: z.string() }, async ({ content }) => {
  return {
    content: [{ type: 'text', text: JSON.stringify({ error: 'Not implemented' }) }],
  };
});

server.tool('get-todos', 'Listar todas as tarefas', async () => {
  return {
    content: [{ type: 'text', text: JSON.stringify({ error: 'Not implemented' }) }],
  };
});

server.tool('delete-todo', 'Excluir uma tarefa pelo id', { id: z.string() }, async ({ id }) => {
  return {
    content: [{ type: 'text', text: JSON.stringify({ error: 'Not implemented' }) }],
  };
});

// Abaixo est√° o c√≥digo boilerplate da documenta√ß√£o do MCP SDK
const PORT = 3001;
const app = express();

app.post('/', async (request: Request, response: Response) => {
  // Em modo stateless, crie uma nova inst√¢ncia de transporte e servidor para cada requisi√ß√£o
  // para garantir isolamento completo. Uma √∫nica inst√¢ncia causaria colis√£o de IDs de requisi√ß√£o
  // quando m√∫ltiplos clientes conectam simultaneamente.

  try {
    const transport: StreamableHTTPServerTransport = new StreamableHTTPServerTransport({
      sessionIdGenerator: undefined,
    });
    response.on('close', async () => {
      console.log('Request closed');
      await transport.close();
      await server.close();
    });
    await server.connect(transport);
    await transport.handleRequest(request, response, request.body);
  } catch (error) {
    console.error('Error handling MCP request:', error);
    if (!response.headersSent) {
      response.status(500).json({
        jsonrpc: '2.0',
        error: {
          code: -32_603,
          message: 'Internal server error',
        },
        id: null,
      });
    }
  }
});

// Notifica√ß√µes SSE n√£o suportadas em modo stateless
app.get('/', async (request: Request, response: Response) => {
  console.log('Received GET MCP request');
  response.writeHead(405).end(
    JSON.stringify({
      jsonrpc: '2.0',
      error: {
        code: -32_000,
        message: 'Method not allowed.',
      },
      id: null,
    })
  );
});

// Encerramento de sess√£o n√£o necess√°rio em modo stateless
app.delete('/', async (request: Request, response: Response) => {
  console.log('Received DELETE MCP request');
  response.writeHead(405).end(
    JSON.stringify({
      jsonrpc: '2.0',
      error: {
        code: -32_000,
        message: 'Method not allowed.',
      },
      id: null,
    })
  );
});

app.listen(PORT);
```

Execute o servidor com:

```bash
npm start
```

</TabItem>
</Tabs>

## Inspecione o servidor MCP \{#inspect-the-mcp-server}

### Clone e execute o MCP inspector \{#clone-and-run-mcp-inspector}

Agora que temos o servidor MCP rodando, podemos usar o MCP inspector para ver se as ferramentas est√£o dispon√≠veis.

O MCP inspector oficial v0.16.2 possui alguns bugs que afetam a funcionalidade de autentica√ß√£o. Para resolver esses problemas, criamos uma [vers√£o corrigida do MCP inspector](https://github.com/mcp-auth/inspector/tree/patch/0.16.2-fixes) que inclui corre√ß√µes necess√°rias para fluxos de autentica√ß√£o OAuth/OIDC. Tamb√©m enviamos pull requests para o reposit√≥rio oficial para contribuir com essas corre√ß√µes.

Para executar o MCP inspector, use o seguinte comando (Node.js √© necess√°rio):

```bash
git clone https://github.com/mcp-auth/inspector.git -b patch/0.16.2-fixes
cd inspector
npm install
npm run dev
```

O MCP inspector abrir√° automaticamente em seu navegador padr√£o, ou voc√™ pode acess√°-lo manualmente clicando no link exibido no terminal (certifique-se de clicar no link que inclui o par√¢metro `MCP_PROXY_AUTH_TOKEN`, como `http://localhost:6274/?MCP_PROXY_AUTH_TOKEN=458ae4a4...acab1907`).

### Conecte o MCP inspector ao servidor MCP \{#connect-mcp-inspector-to-the-mcp-server}

Antes de prosseguir, verifique a seguinte configura√ß√£o no MCP inspector:

- **Tipo de Transporte**: Defina como `Streamable HTTP`.
- **URL**: Defina para a URL do seu servidor MCP. No nosso caso, deve ser `http://localhost:3001`.

Agora voc√™ pode clicar no bot√£o "Connect" para ver se o MCP inspector consegue conectar ao servidor MCP. Se tudo estiver certo, voc√™ ver√° o status "Connected" no MCP inspector.

### Checkpoint: Execute as ferramentas do gerenciador de tarefas \{#checkpoint-run-todo-manager-tools}

1. No menu superior do MCP inspector, clique na aba "Tools".
2. Clique no bot√£o "List Tools".
3. Voc√™ deve ver as ferramentas `create-todo`, `get-todos` e `delete-todo` listadas na p√°gina. Clique para abrir os detalhes da ferramenta.
4. Voc√™ deve ver o bot√£o "Run Tool" no lado direito. Clique nele e insira os par√¢metros necess√°rios para executar a ferramenta.
5. Voc√™ ver√° o resultado da ferramenta com a resposta JSON `{"error": "Not implemented"}`.

![Primeira execu√ß√£o do MCP inspector](/docs-assets/images/tutorials/todo-manager/inspector-first-run.png)

## Integre com seu servidor de autoriza√ß√£o \{#integrate-with-your-authorization-server}

Para concluir esta se√ß√£o, h√° v√°rias considera√ß√µes a serem feitas:

<details>
<summary>**A URL do emissor do seu servidor de autoriza√ß√£o**</summary>

Geralmente √© a URL base do seu servidor de autoriza√ß√£o, como `https://auth.exemplo.com`. Alguns provedores podem ter um caminho como `https://exemplo.logto.app/oidc`, ent√£o verifique a documenta√ß√£o do seu provedor.

</details>

<details>
<summary>**Como recuperar os metadados do servidor de autoriza√ß√£o**</summary>

- Se seu servidor de autoriza√ß√£o estiver em conformidade com o [OAuth 2.0 Authorization Server Metadata](https://datatracker.ietf.org/doc/html/rfc8414) ou [OpenID Connect Discovery](https://openid.net/specs/openid-connect-discovery-1_0.html), voc√™ pode usar as utilidades integradas do MCP Auth para buscar os metadados automaticamente.
- Se seu servidor de autoriza√ß√£o n√£o estiver em conformidade com esses padr√µes, voc√™ precisar√° especificar manualmente a URL dos metadados ou endpoints na configura√ß√£o do servidor MCP. Consulte a documenta√ß√£o do seu provedor para os endpoints espec√≠ficos.

</details>

<details>
<summary>**Como registrar o MCP inspector como cliente em seu servidor de autoriza√ß√£o**</summary>

- Se seu servidor de autoriza√ß√£o suporta [Registro Din√¢mico de Cliente](https://datatracker.ietf.org/doc/html/rfc7591), voc√™ pode pular esta etapa, pois o MCP inspector se registrar√° automaticamente como cliente.
- Se seu servidor de autoriza√ß√£o n√£o suporta Registro Din√¢mico de Cliente, voc√™ precisar√° registrar manualmente o MCP inspector como cliente em seu servidor de autoriza√ß√£o.

</details>

<details>
<summary>**Entenda os par√¢metros de requisi√ß√£o de token**</summary>

Ao solicitar tokens de acesso de diferentes servidores de autoriza√ß√£o, voc√™ encontrar√° v√°rias abordagens para especificar o recurso alvo e permiss√µes. Aqui est√£o os principais padr√µes:

- **Baseado em indicador de recurso**:

  - Usa o par√¢metro `resource` para especificar a API alvo (veja [RFC 8707: Resource Indicators for OAuth 2.0](https://datatracker.ietf.org/doc/html/rfc8707))
  - Comum em implementa√ß√µes modernas de OAuth 2.0
  - Exemplo de requisi√ß√£o:
    ```json
    {
      "resource": "http://localhost:3001",
      "scope": "create:todos read:todos"
    }
    ```
  - O servidor emite tokens vinculados especificamente ao recurso solicitado

- **Baseado em audi√™ncia**:

  - Usa o par√¢metro `audience` para especificar o destinat√°rio pretendido do token
  - Semelhante a indicadores de recurso, mas com sem√¢nticas diferentes
  - Exemplo de requisi√ß√£o:
    ```json
    {
      "audience": "todo-api",
      "scope": "create:todos read:todos"
    }
    ```

- **Baseado apenas em escopo**:
  - Depende apenas de escopos sem par√¢metros de recurso/audi√™ncia
  - Abordagem tradicional do OAuth 2.0
  - Exemplo de requisi√ß√£o:
    ```json
    {
      "scope": "todo-api:create todo-api:read openid profile"
    }
    ```
  - Frequentemente usa escopos prefixados para namespacing de permiss√µes
  - Comum em implementa√ß√µes OAuth 2.0 mais simples

:::tip Boas Pr√°ticas

- Verifique a documenta√ß√£o do seu provedor para par√¢metros suportados
- Alguns provedores suportam m√∫ltiplas abordagens simultaneamente
- Indicadores de recurso fornecem melhor seguran√ßa por restri√ß√£o de audi√™ncia
- Considere usar indicadores de recurso quando dispon√≠veis para melhor controle de acesso
  :::

</details>

Embora cada provedor possa ter seus pr√≥prios requisitos espec√≠ficos, os passos a seguir ir√£o gui√°-lo no processo de integra√ß√£o do MCP inspector e do servidor MCP com configura√ß√µes espec√≠ficas do provedor.

### Registre o MCP inspector como cliente \{#register-mcp-inspector-as-a-client}

<Tabs groupId="provider">
<TabItem value="logto" label="Logto">

Integrar o gerenciador de tarefas com o [Logto](https://logto.io) √© simples, pois √© um provedor OpenID Connect que suporta indicadores de recurso e escopos, permitindo proteger sua API de tarefas com `http://localhost:3001` como indicador de recurso.

Como o Logto ainda n√£o suporta Registro Din√¢mico de Cliente, voc√™ precisar√° registrar manualmente o MCP inspector como cliente em seu tenant Logto:

1. Abra seu MCP inspector, v√° para a configura√ß√£o de Autentica√ß√£o e clique em "OAuth2.0 Flow". Copie o valor **Redirect URI**, que deve ser algo como `http://localhost:6274/oauth/callback`.
2. Fa√ßa login no [Logto Console](https://cloud.logto.io) (ou em seu Logto Console auto-hospedado).
3. Navegue at√© a aba "Aplica√ß√µes", clique em "Criar aplica√ß√£o". No final da p√°gina, clique em "Criar app sem framework".
4. Preencha os detalhes da aplica√ß√£o e clique em "Criar aplica√ß√£o":
   - **Selecione um tipo de aplica√ß√£o**: Escolha "Aplica√ß√£o de p√°gina √∫nica".
   - **Nome da aplica√ß√£o**: Insira um nome para sua aplica√ß√£o, por exemplo, "MCP Inspector".
5. Na se√ß√£o "Configura√ß√µes / Redirect URIs", cole o valor **Redirect URI** copiado do MCP inspector. Depois clique em "Salvar altera√ß√µes" na barra inferior.
6. No cart√£o superior, voc√™ ver√° o valor "App ID". Copie-o.
7. Volte ao MCP inspector e cole o valor "App ID" na configura√ß√£o de Autentica√ß√£o em "OAuth2.0 Flow" no campo "Client ID".
8. No campo "Scope", insira: `create:todos read:todos delete:todos`. Isso garantir√° que o token de acesso retornado pelo Logto contenha os escopos necess√°rios para acessar o gerenciador de tarefas.

</TabItem>
<TabItem value="oauth-oidc" label="OAuth 2.0 / OIDC">

:::note
Este √© um guia gen√©rico de integra√ß√£o com provedores OAuth 2.0 / OpenID Connect. Ambos seguem passos semelhantes, pois OIDC √© constru√≠do sobre OAuth 2.0. Consulte a documenta√ß√£o do seu provedor para detalhes espec√≠ficos.
:::

Se seu provedor suporta Registro Din√¢mico de Cliente, voc√™ pode ir diretamente para o passo 8 abaixo para configurar o MCP inspector; caso contr√°rio, ser√° necess√°rio registrar manualmente o MCP inspector como cliente:

1. Abra seu MCP inspector, v√° para a configura√ß√£o de Autentica√ß√£o e clique em "OAuth2.0 Flow". Copie o valor **Redirect URI**, que deve ser algo como `http://localhost:6274/oauth/callback`.

2. Fa√ßa login no console do seu provedor.

3. Navegue at√© a se√ß√£o "Aplica√ß√µes" ou "Clientes" e crie uma nova aplica√ß√£o ou cliente.

4. Se seu provedor exigir um tipo de cliente, selecione "Aplica√ß√£o de p√°gina √∫nica" ou "Cliente p√∫blico".

5. Ap√≥s criar a aplica√ß√£o, voc√™ precisar√° configurar o redirect URI. Cole o valor **Redirect URI** copiado do MCP inspector.

6. Encontre o "Client ID" ou "Application ID" da nova aplica√ß√£o criada e copie-o.

7. Volte ao MCP inspector e cole o valor "Client ID" na configura√ß√£o de Autentica√ß√£o em "OAuth2.0 Flow" no campo "Client ID".

8. No campo "Scope", insira os seguintes escopos para solicitar as permiss√µes necess√°rias para opera√ß√µes de tarefas:

```text
create:todos read:todos delete:todos
```

</TabItem>
</Tabs>

### Configure o MCP Auth \{#set-up-mcp-auth}

Primeiro, instale o SDK MCP Auth em seu projeto do servidor MCP.

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

```bash
uv add mcpauth==0.2.0b1
```

</TabItem>
<TabItem value="node" label="Node.js">

```bash
npm install mcp-auth@0.2.0-beta.1
```

</TabItem>
</Tabs>

Agora precisamos inicializar o MCP Auth em seu servidor MCP. Isso envolve dois passos principais:

1. **Buscar metadados do servidor de autoriza√ß√£o**: Usado para a verifica√ß√£o posterior do MCP Auth dos tokens de acesso emitidos pelo Servidor de Autoriza√ß√£o, e para incluir o identificador do emissor do servidor de autentica√ß√£o nos metadados do recurso
2. **Configurar metadados do recurso protegido**: Definir o identificador do recurso do seu servidor MCP e os escopos suportados

#### Passo 1: Buscar metadados do servidor de autoriza√ß√£o \{#step-1-fetch-authorization-server-metadata\}

De acordo com a especifica√ß√£o OAuth / OIDC, podemos recuperar os metadados do servidor de autoriza√ß√£o com base na URL do emissor do servidor de autoriza√ß√£o.

<Tabs groupId="provider">

<TabItem value="logto" label="Logto">

No Logto, voc√™ pode encontrar a URL do emissor na p√°gina de detalhes da aplica√ß√£o dentro do Logto Console, na se√ß√£o "Endpoints & Credentials / Issuer endpoint". Deve ser algo como `https://meu-projeto.logto.app/oidc`.

</TabItem>

<TabItem value="oauth-oidc" label="OAuth 2.0 / OIDC">

Para provedores OAuth 2.0, voc√™ precisar√°:

1. Verificar a documenta√ß√£o do seu provedor para a URL do servidor de autoriza√ß√£o (geralmente chamada de issuer URL ou base URL)
2. Alguns provedores podem expor isso em `https://{seu-dominio}/.well-known/oauth-authorization-server`
3. Procurar no console de administra√ß√£o do seu provedor em configura√ß√µes OAuth/API

</TabItem>

</Tabs>

Agora, busque os metadados do servidor de autoriza√ß√£o usando a fun√ß√£o utilit√°ria do MCP Auth para recuperar a configura√ß√£o do servidor:

<Tabs groupId="sdk">

<TabItem value="python" label="Python">
```python
from mcpauth import MCPAuth
from mcpauth.config import AuthServerType
from mcpauth.utils import fetch_server_config

issuer_url = "<issuer-url>"  # Substitua pela URL do emissor do seu servidor de autoriza√ß√£o

# Buscar configura√ß√£o do servidor de autoriza√ß√£o
auth_server_config = fetch_server_config(issuer_url, AuthServerType.OIDC) # ou AuthServerType.OAUTH
```

</TabItem>
<TabItem value="node" label="Node.js">
```js
import { MCPAuth, fetchServerConfig } from 'mcp-auth';

const issuerUrl = '<issuer-url>'; // Substitua pela URL do emissor do seu servidor de autoriza√ß√£o

// Buscar configura√ß√£o do servidor de autoriza√ß√£o (OIDC Discovery)
const authServerConfig = await fetchServerConfig(issuerUrl, { type: 'oidc' }); // ou { type: 'oauth' }
```

</TabItem>
</Tabs>

Se precisar de formas alternativas de buscar metadados do servidor de autoriza√ß√£o ou quiser personalizar a configura√ß√£o, consulte [outras formas de configurar metadados do servidor de autoriza√ß√£o](/docs/configure-server/mcp-auth#other-ways).

#### Passo 2: Configure os metadados do recurso protegido \{#step-2-configure-protected-resource-metadata}

Em seguida, vamos configurar os Metadados do Recurso Protegido ao construir a inst√¢ncia MCP Auth. Posteriormente, o servidor MCP expor√° os metadados do recurso configurados no MCP Auth.

<Tabs groupId="sdk">

<TabItem value="python" label="Python">
```python
# server.py

# outros imports...
from mcpauth.types import ResourceServerConfig, ResourceServerMetadata

# Defina o identificador do recurso para este servidor MCP
resource_id = "http://localhost:3001"

mcp_auth = MCPAuth(
    protected_resources=ResourceServerConfig(
        metadata=ResourceServerMetadata(
            resource=resource_id,
            # Metadados do servidor de autoriza√ß√£o buscados no passo anterior
            authorization_servers=[auth_server_config],
            # Escopos que este servidor MCP entende
            scopes_supported=[
                "create:todos",
                "read:todos",
                "delete:todos"
            ]
        )
    )
)
```
</TabItem>

<TabItem value="node" label="Node.js">
```js
// todo-manager.ts

// Defina o identificador do recurso para este servidor MCP
const resourceId = 'http://localhost:3001';

// Configure o MCP Auth com os metadados do recurso protegido
const mcpAuth = new MCPAuth({
  protectedResources: {
    metadata: {
      resource: resourceId,
      // Metadados do servidor de autoriza√ß√£o buscados no passo anterior
      authorizationServers: [authServerConfig],
      // Escopos que este servidor MCP entende
      scopesSupported: [
        "create:todos",
        "read:todos",
        "delete:todos"
      ]
    }
  }
});
```
</TabItem>

</Tabs>

### Atualize o servidor MCP \{#update-mcp-server}

Estamos quase l√°! √â hora de atualizar o servidor MCP para aplicar a rota e fun√ß√£o middleware do MCP Auth, depois implementar o controle de acesso baseado em permiss√µes para as ferramentas do gerenciador de tarefas com base nos escopos do usu√°rio.

Agora, aplique as rotas de metadados do recurso protegido para que clientes MCP possam recuperar os metadados esperados do recurso do servidor MCP.

<Tabs groupId="sdk">
<TabItem value="python" label="Python">
```python
# server.py

# ..outros c√≥digos

app = Starlette(
    routes=[
        # Configure rotas de Metadados do Recurso Protegido
        # Isso exp√µe metadados sobre este servidor de recursos para clientes OAuth
        *mcp_auth.resource_metadata_router().routes,
        Mount("/", app=mcp.streamable_http_app()),
    ],
    lifespan=lifespan,
)
```
</TabItem>
<TabItem value="node" label="Node.js">

```ts
// todo-manager.ts

// Configure rotas de Metadados do Recurso Protegido
// Isso exp√µe metadados sobre este servidor de recursos para clientes OAuth
app.use(mcpAuth.protectedResourceMetadataRouter());

```
</TabItem>
</Tabs>

Em seguida, aplicaremos o middleware MCP Auth ao servidor MCP. Este middleware ir√° lidar com autentica√ß√£o e autoriza√ß√£o para requisi√ß√µes recebidas, garantindo que apenas usu√°rios autorizados possam acessar as ferramentas do gerenciador de tarefas.

<Tabs groupId="sdk">
<TabItem value="python" label="Python">
```python
# server.py

# outros imports...
from starlette.middleware import Middleware

# outros c√≥digos...

# Crie o middleware
bearer_auth = Middleware(mcp_auth.bearer_auth_middleware('jwt', resource=resource_id, audience=resource_id))

app = Starlette(
    routes=[
        *mcp_auth.resource_metadata_router().routes,
        # Aplique o middleware MCP Auth
        Mount("/", app=mcp.streamable_http_app(), middleware=[bearer_auth]),
    ],
    lifespan=lifespan,
)
```
</TabItem>
<TabItem value="node" label="Node.js">

```ts
// todo-manager.ts

app.use(mcpAuth.protectedResourceMetadataRouter());

// Aplique o middleware MCP Auth
app.use(
  mcpAuth.bearerAuth('jwt', {
    resource: resourceId,
    audience: resourceId,
  })
);
```
</TabItem>
</Tabs>

Neste ponto, podemos atualizar as ferramentas do gerenciador de tarefas para aproveitar o middleware MCP Auth para autentica√ß√£o e autoriza√ß√£o.

Vamos atualizar a implementa√ß√£o das ferramentas.

<Tabs groupId="sdk">
<TabItem value="python" label="Python">
```python
# server.py

# outros imports...

from typing import Any, List, Optional
from mcpauth.exceptions import MCPAuthBearerAuthException, BearerAuthExceptionCode
from mcpauth.types import AuthInfo, ResourceServerConfig, ResourceServerMetadata

# Ser√° mencionado na pr√≥xima se√ß√£o
from service import TodoService

def assert_user_id(auth_info: Optional[AuthInfo]) -> str:
    """Garante que auth_info contenha um ID de usu√°rio v√°lido e o retorna."""
    if not auth_info or not auth_info.subject:
        raise Exception("Invalid auth info")
    return auth_info.subject

def has_required_scopes(user_scopes: List[str], required_scopes: List[str]) -> bool:
    """Verifica se o usu√°rio possui todos os escopos necess√°rios."""
    return all(scope in user_scopes for scope in required_scopes)

# Crie a inst√¢ncia do TodoService
todo_service = TodoService()

@mcp.tool()
def create_todo(content: str) -> dict[str, Any]:
    """Cria uma nova tarefa. Requer escopo 'create:todos'."""
    auth_info = mcp_auth.auth_info
    user_id = assert_user_id(auth_info)
    
    # Apenas usu√°rios com escopo 'create:todos' podem criar tarefas
    user_scopes = auth_info.scopes if auth_info else []
    if not has_required_scopes(user_scopes, ["create:todos"]):
        raise MCPAuthBearerAuthException(BearerAuthExceptionCode.MISSING_REQUIRED_SCOPES)
    
    created_todo = todo_service.create_todo(content=content, owner_id=user_id)
    return created_todo

@mcp.tool()
def get_todos() -> dict[str, Any]:
    """
    Lista tarefas. Usu√°rios com escopo 'read:todos' podem ver todas as tarefas,
    caso contr√°rio, s√≥ podem ver suas pr√≥prias tarefas.
    """
    auth_info = mcp_auth.auth_info
    user_id = assert_user_id(auth_info)
    
    # Se o usu√°rio tem escopo 'read:todos', pode acessar todas as tarefas
    # Se n√£o, pode acessar apenas suas pr√≥prias tarefas
    user_scopes = auth_info.scopes if auth_info else []
    todo_owner_id = None if has_required_scopes(user_scopes, ["read:todos"]) else user_id
    
    todos = todo_service.get_all_todos(todo_owner_id)
    return {"todos": todos}

@mcp.tool()
def delete_todo(id: str) -> dict[str, Any]:
    """
    Exclui uma tarefa pelo id. Usu√°rios podem excluir suas pr√≥prias tarefas.
    Usu√°rios com escopo 'delete:todos' podem excluir qualquer tarefa.
    """
    auth_info = mcp_auth.auth_info
    user_id = assert_user_id(auth_info)
    
    todo = todo_service.get_todo_by_id(id)
    
    if not todo:
        return {"error": "Failed to delete todo"}
    
    # Usu√°rios s√≥ podem excluir suas pr√≥prias tarefas
    # Usu√°rios com escopo 'delete:todos' podem excluir qualquer tarefa
    user_scopes = auth_info.scopes if auth_info else []
    if todo.owner_id != user_id and not has_required_scopes(user_scopes, ["delete:todos"]):
        return {"error": "Failed to delete todo"}
    
    deleted_todo = todo_service.delete_todo(id)
    
    if deleted_todo:
        return {
            "message": f"Todo {id} deleted",
            "details": deleted_todo
        }
    else:
        return {"error": "Failed to delete todo"}
```
</TabItem>

<TabItem value="node" label="Node.js">
```js
// todo-manager.ts

// outros imports...
import assert from 'node:assert';
import { fetchServerConfig, MCPAuth, MCPAuthBearerAuthError } from 'mcp-auth';
import { type AuthInfo } from '@modelcontextprotocol/sdk/server/auth/types.js';

// Ser√° mencionado na pr√≥xima se√ß√£o
import { TodoService } from './todo-service.js';

const assertUserId = (authInfo?: AuthInfo) => {
  const { subject } = authInfo ?? {};
  assert(subject, 'Invalid auth info');
  return subject;
};

const hasRequiredScopes = (userScopes: string[], requiredScopes: string[]): boolean => {
  return requiredScopes.every((scope) => userScopes.includes(scope));
};

const todoService = new TodoService();

server.tool(
  'create-todo',
  'Criar uma nova tarefa',
  { content: z.string() },
  ({ content }: { content: string }, { authInfo }) => {
    const userId = assertUserId(authInfo);

    /**
     * Apenas usu√°rios com escopo 'create:todos' podem criar tarefas
     */
    if (!hasRequiredScopes(authInfo?.scopes ?? [], ['create:todos'])) {
      throw new MCPAuthBearerAuthError('missing_required_scopes');
    }

    const createdTodo = todoService.createTodo({ content, ownerId: userId });

    return {
      content: [{ type: 'text', text: JSON.stringify(createdTodo) }],
    };
  }
);

server.tool('get-todos', 'Listar todas as tarefas', ({ authInfo }) => {
  const userId = assertUserId(authInfo);

  /**
   * Se o usu√°rio tem escopo 'read:todos', pode acessar todas as tarefas (todoOwnerId = undefined)
   * Se n√£o, pode acessar apenas suas pr√≥prias tarefas (todoOwnerId = userId)
   */
  const todoOwnerId = hasRequiredScopes(authInfo?.scopes ?? [], ['read:todos'])
    ? undefined
    : userId;

  const todos = todoService.getAllTodos(todoOwnerId);

  return {
    content: [{ type: 'text', text: JSON.stringify(todos) }],
  };
});

server.tool(
  'delete-todo',
  'Excluir uma tarefa pelo id',
  { id: z.string() },
  ({ id }: { id: string }, { authInfo }) => {
    const userId = assertUserId(authInfo);

    const todo = todoService.getTodoById(id);

    if (!todo) {
      return {
        content: [{ type: 'text', text: JSON.stringify({ error: 'Failed to delete todo' }) }],
      };
    }

    /**
     * Usu√°rios s√≥ podem excluir suas pr√≥prias tarefas
     * Usu√°rios com escopo 'delete:todos' podem excluir qualquer tarefa
     */
    if (todo.ownerId !== userId && !hasRequiredScopes(authInfo?.scopes ?? [], ['delete:todos'])) {
      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify({ error: 'Failed to delete todo' }),
          },
        ],
      };
    }

    const deletedTodo = todoService.deleteTodo(id);

    return {
      content: [
        {
          type: 'text',
          text: JSON.stringify({
            message: `Todo ${id} deleted`,
            details: deletedTodo,
          }),
        },
      ],
    };
  }
);
```
</TabItem>
</Tabs>

Agora, crie o "servi√ßo de tarefas" usado no c√≥digo acima para implementar a funcionalidade relacionada:

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

Crie o arquivo `service.py` para o servi√ßo de tarefas:

```python
"""
Um servi√ßo simples de tarefas para fins de demonstra√ß√£o.
Usa uma lista em mem√≥ria para armazenar tarefas.
"""

from datetime import datetime
from typing import List, Optional, Dict, Any
import random
import string

class Todo:
    """Representa um item de tarefa."""
    
    def __init__(self, id: str, content: str, owner_id: str, created_at: str):
        self.id = id
        self.content = content
        self.owner_id = owner_id
        self.created_at = created_at
    
    def to_dict(self) -> Dict[str, Any]:
        """Converte a tarefa para dicion√°rio para serializa√ß√£o JSON."""
        return {
            "id": self.id,
            "content": self.content,
            "ownerId": self.owner_id,
            "createdAt": self.created_at
        }


class TodoService:
    """Um servi√ßo simples de tarefas para fins de demonstra√ß√£o."""
    
    def __init__(self):
        self._todos: List[Todo] = []
    
    def get_all_todos(self, owner_id: Optional[str] = None) -> List[Dict[str, Any]]:
        """
        Obt√©m todas as tarefas, opcionalmente filtradas por owner_id.
        
        Args:
            owner_id: Se fornecido, retorna apenas tarefas deste usu√°rio
            
        Returns:
            Lista de dicion√°rios de tarefas
        """
        if owner_id:
            filtered_todos = [todo for todo in self._todos if todo.owner_id == owner_id]
            return [todo.to_dict() for todo in filtered_todos]
        return [todo.to_dict() for todo in self._todos]
    
    def get_todo_by_id(self, todo_id: str) -> Optional[Todo]:
        """
        Obt√©m uma tarefa pelo ID.
        
        Args:
            todo_id: O ID da tarefa a ser recuperada
            
        Returns:
            Objeto Todo se encontrado, None caso contr√°rio
        """
        for todo in self._todos:
            if todo.id == todo_id:
                return todo
        return None
    
    def create_todo(self, content: str, owner_id: str) -> Dict[str, Any]:
        """
        Cria uma nova tarefa.
        
        Args:
            content: O conte√∫do da tarefa
            owner_id: O ID do usu√°rio dono da tarefa
            
        Returns:
            Representa√ß√£o em dicion√°rio da tarefa criada
        """
        todo = Todo(
            id=self._generate_id(),
            content=content,
            owner_id=owner_id,
            created_at=datetime.now().isoformat()
        )
        self._todos.append(todo)
        return todo.to_dict()
    
    def delete_todo(self, todo_id: str) -> Optional[Dict[str, Any]]:
        """
        Exclui uma tarefa pelo ID.
        
        Args:
            todo_id: O ID da tarefa a ser exclu√≠da
            
        Returns:
            Representa√ß√£o em dicion√°rio da tarefa exclu√≠da se encontrada, None caso contr√°rio
        """
        for i, todo in enumerate(self._todos):
            if todo.id == todo_id:
                deleted_todo = self._todos.pop(i)
                return deleted_todo.to_dict()
        return None
    
    def _generate_id(self) -> str:
        """Gera um ID aleat√≥rio para uma tarefa."""
        return ''.join(random.choices(string.ascii_lowercase + string.digits, k=8))
```

</TabItem>
<TabItem value="node" label="Node.js">

Crie o arquivo `todo-service.ts` para o servi√ßo de tarefas:

```ts
// todo-service.ts

type Todo = {
  id: string;
  content: string;
  ownerId: string;
  createdAt: string;
};

/**
 * Um servi√ßo simples de tarefas para fins de demonstra√ß√£o.
 * Usa um array em mem√≥ria para armazenar tarefas
 */
export class TodoService {
  private readonly todos: Todo[] = [];

  getAllTodos(ownerId?: string): Todo[] {
    if (ownerId) {
      return this.todos.filter((todo) => todo.ownerId === ownerId);
    }
    return this.todos;
  }

  getTodoById(id: string): Todo | undefined {
    return this.todos.find((todo) => todo.id === id);
  }

  createTodo({ content, ownerId }: { content: string; ownerId: string }): Todo {
    const todo: Todo = {
      id: this.genId(),
      content,
      ownerId,
      createdAt: new Date().toISOString(),
    };

    // eslint-disable-next-line @silverhand/fp/no-mutating-methods
    this.todos.push(todo);
    return todo;
  }

  deleteTodo(id: string): Todo | undefined {
    const index = this.todos.findIndex((todo) => todo.id === id);

    if (index === -1) {
      return undefined;
    }

    // eslint-disable-next-line @silverhand/fp/no-mutating-methods
    const [deleted] = this.todos.splice(index, 1);
    return deleted;
  }

  private genId(): string {
    return Math.random().toString(36).slice(2, 10);
  }
}
```

</TabItem>
</Tabs>

üéâ Parab√©ns! Implementamos com sucesso um servidor MCP completo com autentica√ß√£o e autoriza√ß√£o!

Voc√™ tamb√©m pode conferir nosso c√≥digo de exemplo como refer√™ncia:

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

:::info
Confira o [reposit√≥rio MCP Auth Python SDK](https://github.com/mcp-auth/python/tree/master/samples/current/todo-manager) para o c√≥digo completo do servidor MCP (vers√£o OIDC).
:::

</TabItem>
<TabItem value="node" label="Node.js">

:::info
Confira o [reposit√≥rio MCP Auth Node.js SDK](https://github.com/mcp-auth/js/blob/master/packages/sample-servers/src) para o c√≥digo completo do servidor MCP (vers√£o OIDC).
:::

</TabItem>
</Tabs>

## Checkpoint: Execute as ferramentas `todo-manager` \{#checkpoint-run-the-todo-manager-tools}

Reinicie seu servidor MCP e abra o MCP inspector no navegador. Ao clicar no bot√£o "Connect", voc√™ deve ser redirecionado para a p√°gina de login do seu servidor de autoriza√ß√£o.

Depois de fazer login e retornar ao MCP inspector, repita as a√ß√µes do checkpoint anterior para executar as ferramentas do gerenciador de tarefas. Desta vez, voc√™ poder√° usar essas ferramentas com sua identidade de usu√°rio autenticada. O comportamento das ferramentas depender√° dos pap√©is e permiss√µes atribu√≠dos ao seu usu√°rio:

- Se voc√™ estiver logado como **User** (com apenas o escopo `create:todos`):

  - Pode criar novas tarefas usando a ferramenta `create-todo`
  - S√≥ pode visualizar e excluir suas pr√≥prias tarefas
  - N√£o poder√° ver ou excluir tarefas de outros usu√°rios

- Se estiver logado como **Admin** (com todos os escopos: `create:todos`, `read:todos`, `delete:todos`):
  - Pode criar novas tarefas
  - Pode visualizar todas as tarefas do sistema usando a ferramenta `get-todos`
  - Pode excluir qualquer tarefa usando a ferramenta `delete-todo`, independentemente de quem a criou

Voc√™ pode testar esses diferentes n√≠veis de permiss√£o:

1. Saindo da sess√£o atual (clique no bot√£o "Disconnect" no MCP inspector)
2. Fazendo login com outra conta de usu√°rio que tenha pap√©is/permiss√µes diferentes
3. Testando novamente as ferramentas para observar como o comportamento muda de acordo com as permiss√µes do usu√°rio

Isso demonstra como o controle de acesso baseado em papel (RBAC) funciona na pr√°tica, onde diferentes usu√°rios t√™m diferentes n√≠veis de acesso √† funcionalidade do sistema.

![Resultado da ferramenta do gerenciador de tarefas no MCP inspector](/docs-assets/images/tutorials/todo-manager/result.png)

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

:::info
Confira o [reposit√≥rio MCP Auth Python SDK](https://github.com/mcp-auth/python) para o c√≥digo completo do servidor MCP (vers√£o OIDC).
:::

</TabItem>
<TabItem value="node" label="Node.js">

:::info
Confira o [reposit√≥rio MCP Auth Node.js SDK](https://github.com/mcp-auth/js/blob/master/packages/sample-servers/src) para o c√≥digo completo do servidor MCP (vers√£o OIDC).
:::

</TabItem>
</Tabs>

## Notas finais \{#closing-notes}

üéä Parab√©ns! Voc√™ concluiu com sucesso o tutorial. Vamos recapitular o que fizemos:

- Configura√ß√£o de um servidor MCP b√°sico com ferramentas de gerenciamento de tarefas (`create-todo`, `get-todos`, `delete-todo`)
- Implementa√ß√£o de controle de acesso baseado em papel (RBAC) com diferentes n√≠veis de permiss√£o para usu√°rios e administradores
- Integra√ß√£o do servidor MCP com um servidor de autoriza√ß√£o usando MCP Auth
- Configura√ß√£o do MCP Inspector para autenticar usu√°rios e usar tokens de acesso com escopos para chamar ferramentas

N√£o deixe de conferir outros tutoriais e a documenta√ß√£o para aproveitar ao m√°ximo o MCP Auth.
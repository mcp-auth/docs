---
sidebar_position: 2
sidebar_label: 'Tutorial: Baue einen Todo-Manager'
---

import TabItem from '@theme/TabItem';
import Tabs from '@theme/Tabs';

import SetupOauthOrOidc from './_setup-oauth-or-oidc.mdx';
import SetupOidc from './_setup-oidc.mdx';

# Tutorial: Baue einen Todo-Manager

In diesem Tutorial bauen wir einen Todo-Manager-MCP-Server mit Benutzer-Authentifizierung (Authentifizierung) und Autorisierung (Autorisierung).

Nach Abschluss dieses Tutorials hast du:

- ‚úÖ Ein grundlegendes Verst√§ndnis davon, wie du rollenbasierte Zugangskontrolle (RBAC) in deinem MCP-Server einrichtest.
- ‚úÖ Einen MCP-Server, der pers√∂nliche Todo-Listen verwalten kann.

:::note
Bevor du startest, empfehlen wir dir dringend, zuerst das [Who am I Tutorial](./whoami) durchzugehen, falls du mit dem MCP-Server und OAuth 2 nicht vertraut bist.
:::

## √úberblick \{#overview}

Das Tutorial umfasst folgende Komponenten:

- **MCP-Server**: Ein einfacher MCP-Server, der die offiziellen MCP-SDKs verwendet, um Anfragen zu bearbeiten, mit einem integrierten Todo-Service zur Verwaltung der Todo-Eintr√§ge der Benutzer.
- **MCP Inspector**: Ein visuelles Test-Tool f√ºr MCP-Server. Es agiert auch als OAuth / OIDC-Client, um den Autorisierungsfluss zu starten und Zugangstokens abzurufen.
- **Autorisierungsserver**: Ein OAuth 2.1- oder OpenID Connect-Anbieter, der Benutzeridentit√§ten verwaltet und Zugangstokens ausstellt.

Hier ist ein √úberblicksdiagramm √ºber die Interaktion dieser Komponenten:

```mermaid
sequenceDiagram
    participant Client as MCP Inspector
    participant Server as MCP Server
    participant Auth as Autorisierungsserver

    Client->>Server: Todo-Operation anfordern
    Server->>Client: 401 Nicht autorisiert zur√ºckgeben
    Client->>Auth: Autorisierungsfluss starten
    Auth->>Auth: Autorisierungsfluss abschlie√üen
    Auth->>Client: Mit Autorisierungscode zur√ºckleiten
    Client->>Auth: Code gegen Zugangstoken austauschen
    Auth->>Client: Zugangstoken zur√ºckgeben
    Client->>Server: Todo-Operation mit Zugangstoken anfordern
    Server->>Server: Zugangstoken validieren und Benutzer-Berechtigungen aus Zugangstoken holen
    Note over Server: Todo-Operation ausf√ºhren
    Server->>Client: Ergebnis der Todo-Operation zur√ºckgeben
```

## Verstehe deinen Autorisierungsserver \{#understand-your-authorization-server}

### Zugangstokens mit Berechtigungen (Scopes) \{#access-tokens-with-scopes}

Um [rollenbasierte Zugangskontrolle (RBAC)](https://auth.wiki/rbac) in deinem MCP-Server zu implementieren, muss dein Autorisierungsserver das Ausstellen von Zugangstokens mit Berechtigungen (Scopes) unterst√ºtzen. Berechtigungen repr√§sentieren die Rechte, die einem Benutzer gew√§hrt wurden.

<Tabs groupId="provider">
<TabItem value="logto" label="Logto">

[Logto](https://logto.io) bietet RBAC-Unterst√ºtzung √ºber seine API-Ressourcen (gem√§√ü [RFC 8707: Resource Indicators for OAuth 2.0](https://datatracker.ietf.org/doc/html/rfc8707)) und Rollenfunktionen. So richtest du es ein:

1. Melde dich bei der [Logto Console](https://cloud.logto.io) (oder deiner selbst gehosteten Logto Console) an.

2. Erstelle API-Ressource und Berechtigungen:

   - Gehe zu "API-Ressourcen"
   - Erstelle eine neue API-Ressource mit dem Namen "Todo Manager"
   - F√ºge folgende Berechtigungen hinzu:
     - `create:todos`: "Neue Todo-Eintr√§ge erstellen"
     - `read:todos`: "Alle Todo-Eintr√§ge lesen"
     - `delete:todos`: "Beliebigen Todo-Eintrag l√∂schen"

3. Erstelle Rollen (empfohlen f√ºr einfachere Verwaltung):

   - Gehe zu "Rollen"
   - Erstelle eine "Admin"-Rolle und weise alle Berechtigungen zu (`create:todos`, `read:todos`, `delete:todos`)
   - Erstelle eine "User"-Rolle und weise nur die Berechtigung `create:todos` zu

4. Berechtigungen zuweisen:
   - Gehe zu "Benutzer"
   - W√§hle einen Benutzer aus
   - Du kannst entweder:
     - Rollen im Tab "Rollen" zuweisen (empfohlen)
     - Oder direkt Berechtigungen im Tab "Berechtigungen" zuweisen

Die Berechtigungen werden im `scope`-Anspruch des JWT-Zugangstokens als durch Leerzeichen getrennte Zeichenkette enthalten sein.

</TabItem>
<TabItem value="asgardeo" label="Asgardeo">
    [Asgardeo](https://wso2.com/asgardeo) unterst√ºtzt rollenbasierte Zugangskontrolle (RBAC) und feingranulare Autorisierung mit API-Ressourcen und Berechtigungen. So konfigurierst du es:

    1. Melde dich bei der [Asgardeo Console](https://console.asgardeo.io) an

    2. Definiere deine API-Ressource und Berechtigungen:
        - Gehe zu **API Resources**
        - Klicke auf **"New API Resource"**
        - Setze den **Identifier** auf `https://todo.mcp-server.app` (oder deine gew√ºnschte URL)
        - Der **Display Name** ist `Todo Manager`
        - F√ºge folgende Berechtigungen hinzu:
            - `create:todos` : "Neue Todo-Eintr√§ge erstellen"
            - `read:todos` : "Alle Todo-Eintr√§ge lesen"
            - `delete:todos` : "Beliebigen Todo-Eintrag l√∂schen"
        - Erstelle die Ressource

    3. Erstelle Rollen:
        - Nutze **User Management > Roles**, um Rollen zu erstellen und Berechtigungen direkt zuzuweisen.
        - Klicke auf **New Role**
        - Gib den Rollennamen an (z. B. `Admin` oder `User`) im Bereich **Basic Details**
        - Setze die Zielgruppe der Rolle auf `Application` und w√§hle die **MCP Inspector Application** als **Assigned Application**
        - Im Bereich **Permission Selection** w√§hle die zuvor erstellte API-Ressource (z. B. `Todo Manager`)
        - W√§hle die Berechtigungen aus, die du dieser Rolle zuweisen m√∂chtest (z. B. `create:todos`, `read:todos`, `delete:todos`)
        - Klicke auf **Finish**, um die Rolle zu erstellen

    Falls du die Anwendung bereits erstellt hast:
        - Navigiere zu **Application > MCP Inspector Application > Roles tab**
        - W√§hle **Application Role** als Zielgruppentyp, dann klicke auf **New Role**
        - Erstelle eine `Admin`-Rolle und f√ºge alle drei Berechtigungen hinzu
        - Erstelle eine `User`-Rolle und f√ºge nur die Berechtigung `create:todos` hinzu

    4. Weisen Sie Rollen Benutzern zu:
        - Gehe zu **User Management > Roles**
        - W√§hle die erstellte Rolle (z. B. `Admin` oder `User`) und gehe zum Tab **Users**
        - W√§hle **Assign User** und w√§hle die Benutzer aus, denen du diese Rolle zuweisen m√∂chtest, und speichere.

    Die Berechtigungen werden im `scope`-Anspruch des JWT-Zugangstokens als durch Leerzeichen getrennte Zeichenkette enthalten sein.

</TabItem>
<TabItem value="oauth-oidc" label="OAuth 2.0 / OIDC">

OAuth 2.0 / OIDC-Anbieter unterst√ºtzen in der Regel berechtigungsbasierte Zugangskontrolle. Bei der Implementierung von RBAC:

1. Definiere die ben√∂tigten Berechtigungen in deinem Autorisierungsserver
2. Konfiguriere deinen Client so, dass diese Berechtigungen w√§hrend des Autorisierungsflusses angefordert werden
3. Stelle sicher, dass dein Autorisierungsserver die gew√§hrten Berechtigungen im Zugangstoken einschlie√üt
4. Die Berechtigungen werden normalerweise im `scope`-Anspruch des JWT-Zugangstokens enthalten

Sieh in der Dokumentation deines Anbieters nach, wie:

- Berechtigungen definiert und verwaltet werden
- Berechtigungen im Zugangstoken enthalten sind
- Zus√§tzliche RBAC-Funktionen wie Rollenverwaltung funktionieren

</TabItem>
</Tabs>

### Tokens validieren und Berechtigungen pr√ºfen \{#validating-tokens-and-checking-permissions}

Wenn dein MCP-Server eine Anfrage erh√§lt, muss er:

1. Die Signatur und das Ablaufdatum des Zugangstokens validieren
2. Die Berechtigungen aus dem validierten Token extrahieren
3. Pr√ºfen, ob das Token die erforderlichen Berechtigungen f√ºr die angeforderte Operation enth√§lt

Wenn ein Benutzer z. B. einen neuen Todo-Eintrag erstellen m√∂chte, muss sein Zugangstoken die Berechtigung `create:todos` enthalten. So funktioniert der Ablauf:

```mermaid
sequenceDiagram
    participant Client
    participant MCP Server
    participant Auth Server

    Client->>MCP Server: Anfrage mit Zugangstoken

    alt JWT-Validierung
        MCP Server->>Auth Server: JWKS abrufen
        Auth Server-->>MCP Server: JWKS zur√ºckgeben
        MCP Server->>MCP Server: JWT lokal validieren
    else Token-Introspektion
        MCP Server->>Auth Server: POST /introspect<br/>(token=access_token)
        Auth Server-->>MCP Server: Token-Info zur√ºckgeben<br/>(active, scope, etc.)
    end

    MCP Server->>MCP Server: Berechtigungen extrahieren & pr√ºfen

    alt Hat erforderliche Berechtigungen
        MCP Server->>Client: Operation erlauben
    else Fehlende Berechtigungen
        MCP Server->>Client: 403 Verboten zur√ºckgeben
    end
```

### Dynamische Client-Registrierung \{#dynamic-client-registration}

Die dynamische Client-Registrierung ist f√ºr dieses Tutorial nicht erforderlich, kann aber n√ºtzlich sein, wenn du den MCP-Client-Registrierungsprozess mit deinem Autorisierungsserver automatisieren m√∂chtest. Siehe [Ist Dynamic Client Registration erforderlich?](../../provider-list.mdx#is-dcr-required) f√ºr weitere Details.

## Verstehe RBAC im Todo-Manager \{#understand-rbac-in-todo-manager}

Zu Demonstrationszwecken implementieren wir ein einfaches rollenbasiertes Zugangskontrollsystem (RBAC) in unserem Todo-Manager-MCP-Server. Das zeigt dir die Grundprinzipien von RBAC bei √ºberschaubarer Implementierung.

:::note
Auch wenn dieses Tutorial RBAC-basierte Berechtigungsverwaltung demonstriert, ist es wichtig zu wissen, dass nicht alle Authentifizierungsanbieter die Berechtigungsverwaltung √ºber Rollen implementieren. Manche Anbieter haben eigene Mechanismen zur Verwaltung von Zugangskontrolle und Berechtigungen.
:::

### Tools und Berechtigungen \{#tools-and-scopes}

Unser Todo-Manager-MCP-Server stellt drei Haupttools bereit:

- `create-todo`: Einen neuen Todo-Eintrag erstellen
- `get-todos`: Alle Todos auflisten
- `delete-todo`: Ein Todo anhand der ID l√∂schen

Um den Zugriff auf diese Tools zu steuern, definieren wir folgende Berechtigungen:

- `create:todos`: Erlaubt das Erstellen neuer Todo-Eintr√§ge
- `delete:todos`: Erlaubt das L√∂schen bestehender Todo-Eintr√§ge
- `read:todos`: Erlaubt das Abfragen und Abrufen aller Todo-Eintr√§ge

### Rollen und Berechtigungen \{#roles-and-permissions}

Wir definieren zwei Rollen mit unterschiedlichen Zugriffsrechten:

| Rolle  | create:todos | read:todos | delete:todos |
| ------ | ------------ | ---------- | ------------ |
| Admin  | ‚úÖ           | ‚úÖ         | ‚úÖ           |
| User   | ‚úÖ           |            |              |

- **User**: Ein normaler Benutzer, der Todo-Eintr√§ge erstellen und nur seine eigenen Todos ansehen oder l√∂schen kann
- **Admin**: Ein Administrator, der alle Todo-Eintr√§ge erstellen, ansehen und l√∂schen kann, unabh√§ngig vom Eigent√ºmer

### Ressourcenbesitz \{#resource-ownership}

Obwohl die obige Berechtigungstabelle die explizit zugewiesenen Berechtigungen pro Rolle zeigt, gibt es ein wichtiges Prinzip des Ressourcenbesitzes:

- **User** haben nicht die Berechtigungen `read:todos` oder `delete:todos`, k√∂nnen aber trotzdem:
  - Ihre eigenen Todo-Eintr√§ge lesen
  - Ihre eigenen Todo-Eintr√§ge l√∂schen
- **Admins** haben volle Berechtigungen (`read:todos` und `delete:todos`) und k√∂nnen daher:
  - Alle Todo-Eintr√§ge im System ansehen
  - Jeden Todo-Eintrag l√∂schen, unabh√§ngig vom Eigent√ºmer

Das zeigt ein h√§ufiges Muster in RBAC-Systemen, bei dem der Besitz einer Ressource implizite Berechtigungen f√ºr eigene Ressourcen gew√§hrt, w√§hrend administrative Rollen explizite Berechtigungen f√ºr alle Ressourcen erhalten.

:::tip Mehr erfahren
Um tiefer in RBAC-Konzepte und Best Practices einzutauchen, siehe [Mastering RBAC: A Comprehensive Real-World Example](https://blog.logto.io/mastering-rbac).
:::

## Autorisierung beim Anbieter konfigurieren \{#configure-authorization-in-your-provider}

Um das oben beschriebene Zugangskontrollsystem zu implementieren, musst du deinen Autorisierungsserver so konfigurieren, dass er die erforderlichen Berechtigungen unterst√ºtzt. So geht es bei verschiedenen Anbietern:

<Tabs groupId="provider">
<TabItem value="logto" label="Logto">

[Logto](https://logto.io) bietet RBAC-Unterst√ºtzung √ºber seine API-Ressourcen und Rollenfunktionen. So richtest du es ein:

1. Melde dich bei der [Logto Console](https://cloud.logto.io) (oder deiner selbst gehosteten Logto Console) an.

2. Erstelle API-Ressource und Berechtigungen:

   - Gehe zu "API-Ressourcen"
   - Erstelle eine neue API-Ressource mit dem Namen "Todo Manager" und verwende `https://todo.mcp-server.app` (zu Demo-Zwecken) als Indikator.
   - Erstelle folgende Berechtigungen:
     - `create:todos`: "Neue Todo-Eintr√§ge erstellen"
     - `read:todos`: "Alle Todo-Eintr√§ge lesen"
     - `delete:todos`: "Beliebigen Todo-Eintrag l√∂schen"

3. Erstelle Rollen (empfohlen f√ºr einfachere Verwaltung):

   - Gehe zu "Rollen"
   - Erstelle eine "Admin"-Rolle und weise alle Berechtigungen zu (`create:todos`, `read:todos`, `delete:todos`)
   - Erstelle eine "User"-Rolle und weise nur die Berechtigung `create:todos` zu
   - Im Detailbereich der "User"-Rolle wechsle zum Tab "Allgemein" und setze die "User"-Rolle als "Standardrolle".

4. Benutzerrollen und Berechtigungen verwalten:
   - F√ºr neue Benutzer:
     - Sie erhalten automatisch die "User"-Rolle, da wir sie als Standardrolle gesetzt haben
   - F√ºr bestehende Benutzer:
     - Gehe zu "Benutzerverwaltung"
     - W√§hle einen Benutzer aus
     - Weise dem Benutzer Rollen im Tab "Rollen" zu

:::tip Programmatische Rollenverwaltung
Du kannst auch die [Management API](https://docs.logto.io/integrate-logto/interact-with-management-api) von Logto verwenden, um Benutzerrollen programmatisch zu verwalten. Das ist besonders n√ºtzlich f√ºr automatisierte Benutzerverwaltung oder beim Bau von Admin-Panels.
:::

Beim Anfordern eines Zugangstokens wird Logto die Berechtigungen im `scope`-Anspruch des Tokens basierend auf den Rollenberechtigungen des Benutzers einf√ºgen.

</TabItem>
<TabItem value="keycloak" label="Keycloak">

In [Keycloak](https://www.keycloak.org) kannst du die erforderlichen Berechtigungen mit Client-Scopes einrichten:

1. Erstelle Client-Scopes:

   - Gehe in deinem Realm zu "Client scopes"
   - Erstelle drei neue Client-Scopes:
     - `create:todos`
     - `read:todos`
     - `delete:todos`

2. Konfiguriere den Client:

   - Gehe zu deinen Client-Einstellungen
   - Im Tab "Client scopes" f√ºge alle erstellten Scopes hinzu
   - Stelle sicher, dass der Token-Mapper so konfiguriert ist, dass die Scopes enthalten sind

3. Optional: Rollen f√ºr einfachere Verwaltung nutzen
   - Wenn du rollenbasierte Verwaltung bevorzugst:
     - Erstelle Realm-Rollen f√ºr verschiedene Zugriffsebenen
     - Mappe Scopes auf Rollen
     - Weise Rollen Benutzern zu
   - Alternativ kannst du Scopes direkt Benutzern oder √ºber clientseitige Berechtigungen zuweisen

Keycloak wird die gew√§hrten Scopes im `scope`-Anspruch des Zugangstokens enthalten.

</TabItem>
<TabItem value="asgardeo" label="Asgardeo">

[Asgardeo](https://wso2.com/asgardeo) unterst√ºtzt rollenbasierte Zugangskontrolle (RBAC) und feingranulare Autorisierung mit API-Ressourcen und Berechtigungen. So konfigurierst du es:

1. Melde dich bei der [Asgardeo Console](https://console.asgardeo.io) an

2. Definiere deine API-Ressource und Berechtigungen:
    - Gehe zu **API Resources**
    - Klicke auf **"New API Resource"**
    - Setze den **Identifier** auf `https://todo.mcp-server.app` (oder deine gew√ºnschte URL)
    - Der **Display Name** ist `Todo Manager`
    - F√ºge folgende Berechtigungen hinzu:
        - `create:todos` : "Neue Todo-Eintr√§ge erstellen"
        - `read:todos` : "Alle Todo-Eintr√§ge lesen"
        - `delete:todos` : "Beliebigen Todo-Eintrag l√∂schen"
    - Erstelle die Ressource

3. Erstelle Rollen:
    - Nutze **User Management > Roles**, um Rollen zu erstellen und Berechtigungen direkt zuzuweisen.
    - Klicke auf **New Role**
    - Gib den Rollennamen an (z. B. `Admin` oder `User`) im Bereich **Basic Details**
    - Setze die Zielgruppe der Rolle auf `Application` und w√§hle die **MCP Inspector Application** als **Assigned Application**
    - Im Bereich **Permission Selection** w√§hle die zuvor erstellte API-Ressource (z. B. `Todo Manager`)
    - W√§hle die Berechtigungen aus, die du dieser Rolle zuweisen m√∂chtest (z. B. `create:todos`, `read:todos`, `delete:todos`)
    - Klicke auf **Finish**, um die Rolle zu erstellen

    Falls du die Anwendung bereits erstellt hast:
    - Navigiere zu **Application > MCP Inspector Application > Roles tab**
    - W√§hle **Application Role** als Zielgruppentyp, dann klicke auf **New Role**
    - Erstelle eine `Admin`-Rolle und f√ºge alle drei Berechtigungen hinzu
    - Erstelle eine `User`-Rolle und f√ºge nur die Berechtigung `create:todos` hinzu

4. Weisen Sie Rollen Benutzern zu:
    - Gehe zu **User Management > Roles**
    - W√§hle die erstellte Rolle (z. B. `Admin` oder `User`) und gehe zum Tab **Users**
    - W√§hle **Assign User** und w√§hle die Benutzer aus, denen du diese Rolle zuweisen m√∂chtest, und speichere.

Die Berechtigungen werden im `scope`-Anspruch des JWT-Zugangstokens als durch Leerzeichen getrennte Zeichenkette enthalten sein.
Nach der Konfiguration deines Autorisierungsservers erhalten Benutzer Zugangstokens mit ihren gew√§hrten Berechtigungen. Der MCP-Server verwendet diese Berechtigungen, um zu bestimmen:

Ob ein Benutzer neue Todos erstellen darf (`create:todos`)
Ob ein Benutzer alle Todos (`read:todos`) oder nur seine eigenen sehen darf
Ob ein Benutzer beliebige Todos (`delete:todos`) oder nur seine eigenen l√∂schen darf

Weitere Details zur Konfiguration von Asgardeo findest du hier:
- [API Resources Guide](https://wso2.com/asgardeo/docs/guides/authorization/api-authorization)
- [Role Management](https://wso2.com/asgardeo/docs/guides/users/manage-roles)
</TabItem>
<TabItem value="oauth-or-oidc" label="OAuth 2 / OIDC">

F√ºr OAuth 2.0- oder OpenID Connect-Anbieter musst du die Berechtigungen konfigurieren, die verschiedene Rechte repr√§sentieren. Die genauen Schritte h√§ngen von deinem Anbieter ab, aber im Allgemeinen:

1. Berechtigungen definieren:

   - Konfiguriere deinen Autorisierungsserver so, dass er unterst√ºtzt:
     - `create:todos`
     - `read:todos`
     - `delete:todos`

2. Client konfigurieren:

   - Registriere oder aktualisiere deinen Client, um diese Berechtigungen anzufordern
   - Stelle sicher, dass die Berechtigungen im Zugangstoken enthalten sind

3. Berechtigungen zuweisen:
   - Verwende die Oberfl√§che deines Anbieters, um Benutzern die passenden Berechtigungen zu gew√§hren
   - Manche Anbieter unterst√ºtzen rollenbasierte Verwaltung, andere direkte Berechtigungszuweisungen
   - Sieh in der Dokumentation deines Anbieters nach, was empfohlen wird

:::tip
Die meisten Anbieter werden die gew√§hrten Berechtigungen im `scope`-Anspruch des Zugangstokens enthalten. Das Format ist typischerweise eine durch Leerzeichen getrennte Zeichenkette der Scope-Werte.
:::

</TabItem>
</Tabs>

Nach der Konfiguration deines Autorisierungsservers erhalten Benutzer Zugangstokens mit ihren gew√§hrten Berechtigungen. Der MCP-Server verwendet diese Berechtigungen, um zu bestimmen:

- Ob ein Benutzer neue Todos erstellen darf (`create:todos`)
- Ob ein Benutzer alle Todos (`read:todos`) oder nur seine eigenen sehen darf
- Ob ein Benutzer beliebige Todos (`delete:todos`) oder nur seine eigenen l√∂schen darf

## MCP-Server einrichten \{#set-up-the-mcp-server}

Wir verwenden die [offiziellen MCP-SDKs](https://github.com/modelcontextprotocol), um unseren Todo-Manager-MCP-Server zu erstellen.

### Neues Projekt erstellen \{#create-a-new-project}

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

```bash
mkdir mcp-server
cd mcp-server
uv init # Oder verwende `pipenv` oder `poetry`, um eine neue virtuelle Umgebung zu erstellen
```

</TabItem>
<TabItem value="node" label="Node.js">

Lege ein neues Node.js-Projekt an:

```bash
mkdir mcp-server
cd mcp-server
npm init -y # Oder verwende `pnpm init`
npm pkg set type="module"
npm pkg set main="todo-manager.ts"
npm pkg set scripts.start="node --experimental-strip-types todo-manager.ts"
```

:::note
Wir verwenden TypeScript in unseren Beispielen, da Node.js v22.6.0+ TypeScript nativ mit dem Flag `--experimental-strip-types` unterst√ºtzt. Wenn du JavaScript verwendest, ist der Code √§hnlich ‚Äì stelle nur sicher, dass du Node.js v22.6.0 oder neuer nutzt. Siehe Node.js-Dokumentation f√ºr Details.
:::

</TabItem>
</Tabs>

### MCP SDK und Abh√§ngigkeiten installieren \{#install-the-mcp-sdk-and-dependencies}

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

```bash
pip install "mcp[cli]" starlette uvicorn
```

Oder einen anderen Paketmanager deiner Wahl, wie `uv` oder `poetry`.

</TabItem>
<TabItem value="node" label="Node.js">

```bash
npm install @modelcontextprotocol/sdk express zod
```

Oder einen anderen Paketmanager deiner Wahl, wie `pnpm` oder `yarn`.

</TabItem>
</Tabs>

### MCP-Server erstellen \{#create-the-mcp-server}

Erstelle zun√§chst einen grundlegenden MCP-Server mit den Tool-Definitionen:

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

Erstelle eine Datei namens `todo-manager.py` und f√ºge folgenden Code hinzu:

```python
from typing import Any
from mcp.server.fastmcp import FastMCP
from starlette.applications import Starlette
from starlette.routing import Mount

mcp = FastMCP("Todo Manager")

@mcp.tool()
def create_todo(content: str) -> dict[str, Any]:
    """Neues Todo erstellen."""
    return {"error": "Not implemented"}

@mcp.tool()
def get_todos() -> dict[str, Any]:
    """Alle Todos auflisten."""
    return {"error": "Not implemented"}

@mcp.tool()
def delete_todo(id: str) -> dict[str, Any]:
    """Todo anhand der ID l√∂schen."""
    return {"error": "Not implemented"}

app = Starlette(
    routes=[Mount('/', app=mcp.sse_app())]
)
```

Starte den Server mit:

```bash
uvicorn todo_manager:app --host 0.0.0.0 --port 3001
```

</TabItem>
<TabItem value="node" label="Node.js">

:::note
Da die aktuelle MCP Inspector-Implementierung keine Autorisierungsfl√ºsse unterst√ºtzt, verwenden wir den SSE-Ansatz, um den MCP-Server einzurichten. Wir aktualisieren den Code hier, sobald der MCP Inspector Autorisierungsfl√ºsse unterst√ºtzt.
:::

Du kannst auch `pnpm` oder `yarn` verwenden, wenn du m√∂chtest.

Erstelle eine Datei namens `todo-manager.ts` und f√ºge folgenden Code hinzu:

```ts
// todo-manager.ts

import { z } from 'zod';
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { SSEServerTransport } from '@modelcontextprotocol/sdk/server/sse.js';
import express from 'express';

// MCP-Server erstellen
const server = new McpServer({
  name: 'Todo Manager',
  version: '0.0.0',
});

server.tool('create-todo', 'Neues Todo erstellen', { content: z.string() }, async ({ content }) => {
  return {
    content: [{ type: 'text', text: JSON.stringify({ error: 'Not implemented' }) }],
  };
});

server.tool('get-todos', 'Alle Todos auflisten', async () => {
  return {
    content: [{ type: 'text', text: JSON.stringify({ error: 'Not implemented' }) }],
  };
});

server.tool('delete-todo', 'Todo anhand der ID l√∂schen', { id: z.string() }, async ({ id }) => {
  return {
    content: [{ type: 'text', text: JSON.stringify({ error: 'Not implemented' }) }],
  };
});

// Boilerplate-Code aus der MCP SDK-Dokumentation
const PORT = 3001;
const app = express();

const transports = {};

app.get('/sse', async (_req, res) => {
  const transport = new SSEServerTransport('/messages', res);
  transports[transport.sessionId] = transport;

  res.on('close', () => {
    delete transports[transport.sessionId];
  });

  await server.connect(transport);
});

app.post('/messages', async (req, res) => {
  const sessionId = String(req.query.sessionId);
  const transport = transports[sessionId];
  if (transport) {
    await transport.handlePostMessage(req, res, req.body);
  } else {
    res.status(400).send('No transport found for sessionId');
  }
});

app.listen(PORT);
```

Starte den Server mit:

```bash
npm start
```

</TabItem>
</Tabs>

## MCP-Server inspizieren \{#inspect-the-mcp-server}

### MCP Inspector klonen und starten \{#clone-and-run-mcp-inspector}

Jetzt, da der MCP-Server l√§uft, k√∂nnen wir den MCP Inspector verwenden, um zu pr√ºfen, ob das `whoami`-Tool verf√ºgbar ist.

Aufgrund der aktuellen Implementierung haben wir den [MCP Inspector](https://github.com/mcp-auth/inspector) geforkt, um ihn flexibler und skalierbarer f√ºr Authentifizierung und Autorisierung zu machen. Wir haben auch einen Pull Request an das Original-Repository gesendet, um unsere √Ñnderungen einzubringen.

Um den MCP Inspector zu starten, verwende folgenden Befehl (Node.js erforderlich):

```bash
git clone https://github.com/mcp-auth/inspector.git
cd inspector
npm install
npm run dev
```

√ñffne dann deinen Browser und gehe zu `http://localhost:6274/` (oder die im Terminal angezeigte URL), um den MCP Inspector zu nutzen.

### MCP Inspector mit MCP-Server verbinden \{#connect-mcp-inspector-to-the-mcp-server}

Bevor wir fortfahren, pr√ºfe folgende Konfiguration im MCP Inspector:

- **Transport-Typ**: Setze auf `SSE`.
- **URL**: Setze auf die URL deines MCP-Servers. In unserem Fall sollte es `http://localhost:3001/sse` sein.

Jetzt kannst du auf den "Connect"-Button klicken, um zu sehen, ob der MCP Inspector eine Verbindung zum MCP-Server herstellen kann. Wenn alles in Ordnung ist, solltest du den Status "Connected" im MCP Inspector sehen.

### Checkpoint: Todo-Manager-Tools ausf√ºhren \{#checkpoint-run-todo-manager-tools}

1. Klicke im oberen Men√º des MCP Inspectors auf den Tab "Tools".
2. Klicke auf den Button "List Tools".
3. Du solltest die Tools `create-todo`, `get-todos` und `delete-todo` auf der Seite sehen. Klicke darauf, um die Tool-Details zu √∂ffnen.
4. Du solltest rechts den Button "Run Tool" sehen. Klicke darauf und gib die erforderlichen Parameter ein, um das Tool auszuf√ºhren.
5. Du solltest das Tool-Ergebnis mit der JSON-Antwort `{"error": "Not implemented"}` sehen.

![MCP Inspector erster Start](/docs-assets/images/tutorials/todo-manager/inspector-first-run.png)

## Mit deinem Autorisierungsserver integrieren \{#integrate-with-your-authorization-server}

F√ºr diesen Abschnitt gibt es einige √úberlegungen:

<details>
<summary>**Die Issuer-URL deines Autorisierungsservers**</summary>

Dies ist normalerweise die Basis-URL deines Autorisierungsservers, z. B. `https://auth.example.com`. Manche Anbieter haben einen Pfad wie `https://example.logto.app/oidc`, pr√ºfe daher die Dokumentation deines Anbieters.

</details>

<details>
<summary>**Wie du die Metadaten des Autorisierungsservers abrufst**</summary>

- Wenn dein Autorisierungsserver dem [OAuth 2.0 Authorization Server Metadata](https://datatracker.ietf.org/doc/html/rfc8414) oder [OpenID Connect Discovery](https://openid.net/specs/openid-connect-discovery-1_0.html) entspricht, kannst du die eingebauten Utilities von MCP Auth verwenden, um die Metadaten automatisch abzurufen.
- Wenn dein Autorisierungsserver diese Standards nicht erf√ºllt, musst du die Metadaten-URL oder Endpunkte manuell in der MCP-Server-Konfiguration angeben. Pr√ºfe die Dokumentation deines Anbieters f√ºr die spezifischen Endpunkte.

</details>

<details>
<summary>**Wie du den MCP Inspector als Client in deinem Autorisierungsserver registrierst**</summary>

- Wenn dein Autorisierungsserver [Dynamic Client Registration](https://datatracker.ietf.org/doc/html/rfc7591) unterst√ºtzt, kannst du diesen Schritt √ºberspringen, da der MCP Inspector sich automatisch als Client registriert.
- Wenn dein Autorisierungsserver keine Dynamic Client Registration unterst√ºtzt, musst du den MCP Inspector manuell als Client in deinem Autorisierungsserver registrieren.

</details>

<details>
<summary>**Token-Request-Parameter verstehen**</summary>

Beim Anfordern von Zugangstokens von verschiedenen Autorisierungsservern gibt es verschiedene Ans√§tze, um die Zielressource und Berechtigungen anzugeben. Hier die Hauptmuster:

- **Ressourcenindikator-basiert**:

  - Verwendet den Parameter `resource`, um die Ziel-API anzugeben (siehe [RFC 8707: Resource Indicators for OAuth 2.0](https://datatracker.ietf.org/doc/html/rfc8707))
  - H√§ufig in modernen OAuth 2.0-Implementierungen
  - Beispielanfrage:
    ```json
    {
      "resource": "https://todo.mcp-server.app",
      "scope": "create:todos read:todos"
    }
    ```
  - Der Server stellt Tokens aus, die speziell an die angeforderte Ressource gebunden sind

- **Audience-basiert**:

  - Verwendet den Parameter `audience`, um den beabsichtigten Token-Empf√§nger anzugeben
  - √Ñhnlich wie Ressourcenindikatoren, aber mit anderer Semantik
  - Beispielanfrage:
    ```json
    {
      "audience": "todo-api",
      "scope": "create:todos read:todos"
    }
    ```

- **Rein berechtigungsbasiert**:
  - Verwendet ausschlie√ülich Berechtigungen ohne resource/audience-Parameter
  - Traditioneller OAuth 2.0-Ansatz
  - Beispielanfrage:
    ```json
    {
      "scope": "todo-api:create todo-api:read openid profile"
    }
    ```
  - Oft werden Pr√§fixe verwendet, um Berechtigungen zu gruppieren
  - H√§ufig in einfacheren OAuth 2.0-Implementierungen

:::tip Best Practices

- Pr√ºfe die Dokumentation deines Anbieters auf unterst√ºtzte Parameter
- Manche Anbieter unterst√ºtzen mehrere Ans√§tze gleichzeitig
- Ressourcenindikatoren bieten bessere Sicherheit durch Audience-Beschr√§nkung
- Nutze Ressourcenindikatoren, wenn verf√ºgbar, f√ºr bessere Zugangskontrolle
  :::

</details>

Auch wenn jeder Anbieter eigene Anforderungen hat, f√ºhren dich die folgenden Schritte durch die Integration des MCP Inspectors und MCP Servers mit anbieter-spezifischen Konfigurationen.

### MCP Inspector als Client registrieren \{#register-mcp-inspector-as-a-client}

<Tabs groupId="provider">
<TabItem value="logto" label="Logto">

Die Integration des Todo-Managers mit [Logto](https://logto.io) ist einfach, da es ein OpenID Connect-Anbieter ist, der Ressourcenindikatoren und Berechtigungen unterst√ºtzt. So kannst du deine Todo-API mit `https://todo.mcp-server.app` als Ressourcenindikator absichern.

Da Logto noch keine Dynamic Client Registration unterst√ºtzt, musst du den MCP Inspector manuell als Client in deinem Logto-Tenant registrieren:

1. √ñffne deinen MCP Inspector, klicke auf den Button "OAuth Configuration". Kopiere den **Redirect URL (auto-populated)**-Wert, z. B. `http://localhost:6274/oauth/callback`.
2. Melde dich bei der [Logto Console](https://cloud.logto.io) (oder deiner selbst gehosteten Logto Console) an.
3. Navigiere zum Tab "Applications", klicke auf "Create application". Unten auf der Seite klicke auf "Create app without framework".
4. F√ºlle die Anwendungsdetails aus und klicke auf "Create application":
   - **W√§hle einen Anwendungstyp**: "Single-page application"
   - **Anwendungsname**: z. B. "MCP Inspector"
5. Im Bereich "Settings / Redirect URIs" f√ºge den kopierten **Redirect URL (auto-populated)**-Wert ein. Klicke dann unten auf "Save changes".
6. Im oberen Bereich siehst du den Wert "App ID". Kopiere ihn.
7. Gehe zur√ºck zum MCP Inspector und f√ºge den "App ID"-Wert im Bereich "OAuth Configuration" unter "Client ID" ein.
8. Gib `{"scope": "create:todos read:todos delete:todos", "resource": "https://todo.mcp-server.app"}` im Feld "Auth Params" ein. So wird sichergestellt, dass das von Logto zur√ºckgegebene Zugangstoken die notwendigen Berechtigungen f√ºr den Zugriff auf den Todo-Manager enth√§lt.

</TabItem>
<TabItem value="asgardeo" label="Asgardeo">

    W√§hrend Asgardeo die dynamische Client-Registrierung √ºber eine Standard-API unterst√ºtzt, ist der Endpunkt gesch√ºtzt und erfordert ein Zugangstoken mit den notwendigen Berechtigungen. In diesem Tutorial registrieren wir den Client manuell √ºber die Asgardeo Console.

    :::note
    Wenn du noch kein Asgardeo-Konto hast, kannst du dich [kostenlos registrieren](https://asgardeo.io).
    :::

    So konfigurierst du Asgardeo f√ºr den MCP Inspector:

    1. Melde dich bei der [Asgardeo Console](https://console.asgardeo.io) an und w√§hle deine Organisation aus.

    2. Erstelle eine neue Anwendung:
    - Gehe zu **Applications** ‚Üí **New Application**
    - W√§hle **Single-Page Application**
    - Gib einen Anwendungsnamen wie `MCP Inspector` ein
    - Im Feld **Authorized Redirect URLs** f√ºge die aus dem MCP Inspector kopierte **Redirect URL** ein (z. B.: `http://localhost:6274/oauth/callback`)
    - Klicke auf **Create**

    3. Protokolleinstellungen konfigurieren:
    - Im Tab **Protocol**:
    - Kopiere die automatisch generierte **Client ID**
    - Stelle sicher, dass du auf `JWT` f√ºr den `Token Type` im Bereich **Access Token** umstellst
    - Klicke auf **Update**

    4. Im MCP Inspector:
    - √ñffne den Bereich **OAuth Configuration**
    - F√ºge die kopierte **Client ID** ein
    - Gib Folgendes im Feld **Auth Params** ein, um die notwendigen Berechtigungen anzufordern:

    ```json
    { "scope": "openid profile email" }
    ```
</TabItem>
<TabItem value="oauth-oidc" label="OAuth 2.0 / OIDC">

:::note
Dies ist eine generische Anleitung zur Integration eines OAuth 2.0 / OpenID Connect-Anbieters. Beide folgen √§hnlichen Schritten, da OIDC auf OAuth 2.0 aufbaut. Pr√ºfe die Dokumentation deines Anbieters f√ºr Details.
:::

Wenn dein Anbieter Dynamic Client Registration unterst√ºtzt, kannst du direkt zu Schritt 8 unten gehen, um den MCP Inspector zu konfigurieren; andernfalls musst du den MCP Inspector manuell als Client registrieren:

1. √ñffne deinen MCP Inspector, klicke auf den Button "OAuth Configuration". Kopiere den **Redirect URL (auto-populated)**-Wert, z. B. `http://localhost:6274/oauth/callback`.

2. Melde dich in der Konsole deines Anbieters an.

3. Navigiere zum Bereich "Applications" oder "Clients" und erstelle eine neue Anwendung oder einen neuen Client.

4. Falls dein Anbieter einen Client-Typ verlangt, w√§hle "Single-page application" oder "Public client".

5. Nach dem Erstellen der Anwendung musst du die Redirect URI konfigurieren. F√ºge den kopierten **Redirect URL (auto-populated)**-Wert ein.

6. Finde die "Client ID" oder "Application ID" der neu erstellten Anwendung und kopiere sie.

7. Gehe zur√ºck zum MCP Inspector und f√ºge die "Client ID" im Bereich "OAuth Configuration" unter "Client ID" ein.

8. Gib folgenden Wert im Feld "Auth Params" ein, um die notwendigen Berechtigungen f√ºr Todo-Operationen anzufordern:

```json
{ "scope": "create:todos read:todos delete:todos" }
```

</TabItem>
</Tabs>

### MCP Auth einrichten \{#set-up-mcp-auth}

In deinem MCP-Server-Projekt musst du das MCP Auth SDK installieren und so konfigurieren, dass es die Metadaten deines Autorisierungsservers verwendet.

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

Installiere zuerst das `mcpauth`-Paket:

```bash
pip install mcpauth
```

Oder einen anderen Paketmanager deiner Wahl, wie `uv` oder `poetry`.

</TabItem>
<TabItem value="node" label="Node.js">

Installiere zuerst das `mcp-auth`-Paket:

```bash
npm install mcp-auth
```

</TabItem>
</Tabs>

MCP Auth ben√∂tigt die Metadaten des Autorisierungsservers zur Initialisierung. Je nach Anbieter:

<Tabs groupId="provider">

<TabItem value="logto" label="Logto">

Die Issuer-URL findest du auf der Anwendungsdetailseite in der Logto Console im Bereich "Endpoints & Credentials / Issuer endpoint". Sie sieht etwa so aus: `https://my-project.logto.app/oidc`.

<SetupOidc />

</TabItem>

<TabItem value="asgardeo" label="Asgardeo">

    Die Issuer-URL findest du in der Asgardeo Console. Navigiere zur erstellten Anwendung und √∂ffne den Tab **Info**. Das Feld **Issuer** wird dort angezeigt und sieht etwa so aus:
    `https://api.asgardeo.io/t/<your-organization-name>/oauth2/token`

    <SetupOidc />

</TabItem>

<TabItem value="oauth-oidc" label="OAuth 2.0 / OIDC">

F√ºr OAuth 2.0-Anbieter musst du:

1. In der Dokumentation deines Anbieters nach der URL des Autorisierungsservers suchen (oft als Issuer-URL oder Basis-URL bezeichnet)
2. Manche Anbieter stellen dies unter `https://{your-domain}/.well-known/oauth-authorization-server` bereit
3. Im Admin-Bereich deines Anbieters unter OAuth/API-Einstellungen nachsehen

<SetupOauthOrOidc />

</TabItem>

</Tabs>

<Tabs groupId="sdk">

<TabItem value="python" label="Python">

Aktualisiere die `todo-manager.py`, um die MCP Auth-Konfiguration einzubinden:

```python
from mcpauth import MCPAuth
from mcpauth.config import AuthServerType
from mcpauth.utils import fetch_server_config

auth_issuer = '<issuer-endpoint>'  # Ersetze durch deinen Issuer-Endpunkt
auth_server_config = fetch_server_config(auth_issuer, type=AuthServerType.OIDC)
mcp_auth = MCPAuth(server=auth_server_config)
```

</TabItem>
<TabItem value="node" label="Node.js">

Aktualisiere die `todo-manager.ts`, um die MCP Auth-Konfiguration einzubinden:

```ts
// todo-manager.ts

import { MCPAuth, fetchServerConfig } from 'mcp-auth';

const authIssuer = '<issuer-endpoint>'; // Ersetze durch deinen Issuer-Endpunkt
const mcpAuth = new MCPAuth({
  server: await fetchServerConfig(authIssuer, { type: 'oidc' }),
});
```

</TabItem>
</Tabs>

### MCP-Server aktualisieren \{#update-mcp-server}

Fast geschafft! Jetzt aktualisieren wir den MCP-Server, um die MCP Auth-Route und Middleware-Funktion anzuwenden und die berechtigungsbasierte Zugangskontrolle f√ºr die Todo-Manager-Tools basierend auf den Benutzerberechtigungen zu implementieren.

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

```python
@mcp.tool()
def create_todo(content: str) -> dict[str, Any]:
    """Neues Todo erstellen."""
    return (
        mcp_auth.auth_info.scopes
        if mcp_auth.auth_info # Wird durch die Bearer-Auth-Middleware bef√ºllt
        else {"error": "Nicht authentifiziert"}
    )

# ...

bearer_auth = Middleware(mcp_auth.bearer_auth_middleware("jwt"))
app = Starlette(
    routes=[
        # Metadaten-Route hinzuf√ºgen (`/.well-known/oauth-authorization-server`)
        mcp_auth.metadata_route(),
        # MCP-Server mit Bearer-Auth-Middleware sch√ºtzen
        Mount('/', app=mcp.sse_app(), middleware=[bearer_auth]),
    ],
)
```

</TabItem>
<TabItem value="node" label="Node.js">

```js
server.tool(
  'create-todo',
  'Neues Todo erstellen',
  { content: z.string() },
  async ({ content, authInfo }) => {
    return {
      content: [
        { type: 'text', text: JSON.stringify(authInfo?.scopes ?? { error: 'Nicht authentifiziert' }) },
      ],
    };
  }
);

// ...

app.use(mcpAuth.delegatedRouter());
app.use(mcpAuth.bearerAuth('jwt'));
```

</TabItem>
</Tabs>

Als N√§chstes implementieren wir die spezifischen Tools.

Zuerst erstellen wir einen einfachen Todo-Service, der grundlegende CRUD-Operationen f√ºr die Verwaltung von Todo-Eintr√§gen im Speicher bereitstellt.

<Tabs groupId="sdk">
<TabItem value="python" label="Python">
```python
# service.py

"""
Ein einfacher Todo-Service zu Demonstrationszwecken.
Verwendet eine In-Memory-Liste zur Speicherung der Todos.
"""

from datetime import datetime
from typing import List, Optional, Dict, Any
import random
import string

class Todo:
"""Repr√§sentiert einen Todo-Eintrag."""

    def __init__(self, id: str, content: str, owner_id: str, created_at: str):
        self.id = id
        self.content = content
        self.owner_id = owner_id
        self.created_at = created_at

    def to_dict(self) -> Dict[str, Any]:
        """Todo in ein Dictionary f√ºr die JSON-Serialisierung umwandeln."""
        return {
            "id": self.id,
            "content": self.content,
            "ownerId": self.owner_id,
            "createdAt": self.created_at
        }

class TodoService:
"""Ein einfacher Todo-Service zu Demonstrationszwecken."""

    def __init__(self):
        self._todos: List[Todo] = []

    def get_all_todos(self, owner_id: Optional[str] = None) -> List[Dict[str, Any]]:
        """
        Alle Todos abrufen, optional gefiltert nach owner_id.

        Args:
            owner_id: Falls angegeben, nur Todos dieses Benutzers zur√ºckgeben

        Returns:
            Liste von Todo-Dictionaries
        """
        if owner_id:
            filtered_todos = [todo for todo in self._todos if todo.owner_id == owner_id]
            return [todo.to_dict() for todo in filtered_todos]
        return [todo.to_dict() for todo in self._todos]

    def get_todo_by_id(self, todo_id: str) -> Optional[Todo]:
        """
        Ein Todo anhand seiner ID abrufen.

        Args:
            todo_id: Die ID des abzurufenden Todos

        Returns:
            Todo-Objekt, falls gefunden, sonst None
        """
        for todo in self._todos:
            if todo.id == todo_id:
                return todo
        return None

    def create_todo(self, content: str, owner_id: str) -> Dict[str, Any]:
        """
        Ein neues Todo erstellen.

        Args:
            content: Der Inhalt des Todos
            owner_id: Die ID des Benutzers, dem dieses Todo geh√∂rt

        Returns:
            Dictionary-Darstellung des erstellten Todos
        """
        todo = Todo(
            id=self._generate_id(),
            content=content,
            owner_id=owner_id,
            created_at=datetime.now().isoformat()
        )
        self._todos.append(todo)
        return todo.to_dict()

    def delete_todo(self, todo_id: str) -> Optional[Dict[str, Any]]:
        """
        Ein Todo anhand seiner ID l√∂schen.

        Args:
            todo_id: Die ID des zu l√∂schenden Todos

        Returns:
            Dictionary-Darstellung des gel√∂schten Todos, falls gefunden, sonst None
        """
        for i, todo in enumerate(self._todos):
            if todo.id == todo_id:
                deleted_todo = self._todos.pop(i)
                return deleted_todo.to_dict()
        return None

    def _generate_id(self) -> str:
        """Eine zuf√§llige ID f√ºr ein Todo generieren."""
        return ''.join(random.choices(string.ascii_lowercase + string.digits, k=8))

````


</TabItem>
<TabItem value="node" label="Node.js">

```ts
// todo-service.ts

type Todo = {
  id: string;
  content: string;
  ownerId: string;
  createdAt: string;
};

/**
 * Ein einfacher Todo-Service zu Demonstrationszwecken.
 * Verwendet ein In-Memory-Array zur Speicherung der Todos
 */
export class TodoService {
  private readonly todos: Todo[] = [];

  getAllTodos(ownerId?: string): Todo[] {
    if (ownerId) {
      return this.todos.filter((todo) => todo.ownerId === ownerId);
    }
    return this.todos;
  }

  getTodoById(id: string): Todo | undefined {
    return this.todos.find((todo) => todo.id === id);
  }

  createTodo({ content, ownerId }: { content: string; ownerId: string }): Todo {
    const todo: Todo = {
      id: this.genId(),
      content,
      ownerId,
      createdAt: new Date().toISOString(),
    };

    // eslint-disable-next-line @silverhand/fp/no-mutating-methods
    this.todos.push(todo);
    return todo;
  }

  deleteTodo(id: string): Todo | undefined {
    const index = this.todos.findIndex((todo) => todo.id === id);

    if (index === -1) {
      return undefined;
    }

    // eslint-disable-next-line @silverhand/fp/no-mutating-methods
    const [deleted] = this.todos.splice(index, 1);
    return deleted;
  }

  private genId(): string {
    return Math.random().toString(36).slice(2, 10);
  }
}
````

</TabItem>
</Tabs>

Dann bestimmen wir in der Tool-Schicht, ob Operationen basierend auf den Benutzerberechtigungen erlaubt sind:

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

```python
# todo-manager.py

from typing import Any, Optional
from mcpauth.errors import MCPAuthBearerAuthError

def assert_user_id(auth_info: Optional[dict]) -> str:
    """Benutzer-ID aus den Auth-Informationen extrahieren und validieren."""
    subject = auth_info.get('subject') if auth_info else None
    if not subject:
        raise ValueError('Ung√ºltige Auth-Informationen')
    return subject

def has_required_scopes(user_scopes: list[str], required_scopes: list[str]) -> bool:
    """Pr√ºfen, ob der Benutzer alle erforderlichen Berechtigungen hat."""
    return all(scope in user_scopes for scope in required_scopes)

# Instanz von TodoService erstellen
todo_service = TodoService()

@mcp.tool()
def create_todo(content: str) -> dict[str, Any]:
    """Neues Todo erstellen.

    Nur Benutzer mit der Berechtigung 'create:todos' k√∂nnen Todos erstellen.
    """
    # Authentifizierungsinformationen abrufen
    auth_info = mcp_auth.auth_info

    # Benutzer-ID validieren
    try:
        user_id = assert_user_id(auth_info)
    except ValueError as e:
        return {"error": str(e)}

    # Pr√ºfen, ob der Benutzer die erforderlichen Berechtigungen hat
    if not has_required_scopes(auth_info.scopes if auth_info else [], ['create:todos']):
        raise MCPAuthBearerAuthError('missing_required_scopes')

    # Neues Todo erstellen
    created_todo = todo_service.create_todo(content=content, owner_id=user_id)

    # Das erstellte Todo zur√ºckgeben
    return created_todo.__dict__

# ...
```

Du findest unseren [Beispielcode](https://github.com/mcp-auth/python/tree/master/samples/server) f√ºr alle weiteren Implementierungsdetails.

</TabItem>
<TabItem value="node" label="Node.js">

```ts
// todo-manager.ts

// ... weitere Importe
import assert from 'node:assert';
import { type AuthInfo } from '@modelcontextprotocol/sdk/server/auth/types.js';
import { TodoService } from './todo-service.js';

const todoService = new TodoService();

const assertUserId = (authInfo?: AuthInfo) => {
  const { subject } = authInfo ?? {};
  assert(subject, 'Ung√ºltige Auth-Informationen');
  return subject;
};

/**
 * Pr√ºfen, ob der Benutzer alle erforderlichen Berechtigungen f√ºr eine Operation hat
 */
const hasRequiredScopes = (userScopes: string[], requiredScopes: string[]): boolean => {
  return requiredScopes.every((scope) => userScopes.includes(scope));
};

server.tool(
  'create-todo',
  'Neues Todo erstellen',
  { content: z.string() },
  ({ content }: { content: string }, { authInfo }) => {
    const userId = assertUserId(authInfo);

    /**
     * Nur Benutzer mit der Berechtigung 'create:todos' k√∂nnen Todos erstellen
     */
    if (!hasRequiredScopes(authInfo?.scopes ?? [], ['create:todos'])) {
      throw new MCPAuthBearerAuthError('missing_required_scopes');
    }

    const createdTodo = todoService.createTodo({ content, ownerId: userId });

    return {
      content: [{ type: 'text', text: JSON.stringify(createdTodo) }],
    };
  }
);

// ...
```

Du findest unseren [Beispielcode](https://github.com/mcp-auth/js/tree/master/packages/sample-servers/src/todo-manager) f√ºr alle weiteren Implementierungsdetails.

</TabItem>
</Tabs>

## Checkpoint: Die `todo-manager`-Tools ausf√ºhren \{#checkpoint-run-the-todo-manager-tools}

Starte deinen MCP-Server neu und √∂ffne den MCP Inspector im Browser. Wenn du auf den "Connect"-Button klickst, solltest du zur Anmeldeseite deines Autorisierungsservers weitergeleitet werden.

Nachdem du dich angemeldet hast und zur√ºck im MCP Inspector bist, wiederhole die Aktionen aus dem vorherigen Checkpoint, um die Todo-Manager-Tools auszuf√ºhren. Diesmal kannst du die Tools mit deiner authentifizierten Benutzeridentit√§t nutzen. Das Verhalten der Tools h√§ngt von den Rollen und Berechtigungen ab, die deinem Benutzer zugewiesen sind:

- Wenn du als **User** angemeldet bist (nur mit `create:todos`-Berechtigung):

  - Du kannst neue Todos mit dem Tool `create-todo` erstellen
  - Du kannst nur deine eigenen Todos ansehen und l√∂schen
  - Du kannst keine Todos anderer Benutzer sehen oder l√∂schen

- Wenn du als **Admin** angemeldet bist (mit allen Berechtigungen: `create:todos`, `read:todos`, `delete:todos`):
  - Du kannst neue Todos erstellen
  - Du kannst alle Todos im System mit dem Tool `get-todos` ansehen
  - Du kannst beliebige Todos mit dem Tool `delete-todo` l√∂schen, unabh√§ngig davon, wer sie erstellt hat

Du kannst diese unterschiedlichen Berechtigungsstufen testen, indem du:

1. Die aktuelle Sitzung abmeldest (klicke auf "Disconnect" im MCP Inspector)
2. Dich mit einem anderen Benutzerkonto anmeldest, das andere Rollen/Berechtigungen hat
3. Die gleichen Tools erneut ausprobierst, um zu sehen, wie sich das Verhalten je nach Benutzerberechtigungen √§ndert

Das zeigt, wie rollenbasierte Zugangskontrolle (RBAC) in der Praxis funktioniert, wobei verschiedene Benutzer unterschiedliche Zugriffsebenen auf die Funktionen des Systems haben.

![MCP Inspector Todo-Manager-Tool-Ergebnis](/docs-assets/images/tutorials/todo-manager/result.png)

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

:::info
Sieh dir das [MCP Auth Python SDK Repository](https://github.com/mcp-auth/python/blob/master/samples/server/todo-manager/server.py) f√ºr den vollst√§ndigen Code des MCP-Servers (OIDC-Version) an.
:::

</TabItem>
<TabItem value="node" label="Node.js">

:::info
Sieh dir das [MCP Auth Node.js SDK Repository](https://github.com/mcp-auth/js/blob/master/packages/sample-servers/src) f√ºr den vollst√§ndigen Code des MCP-Servers (OIDC-Version) an.
:::

</TabItem>
</Tabs>

## Abschlie√üende Hinweise \{#closing-notes}

üéä Gl√ºckwunsch! Du hast das Tutorial erfolgreich abgeschlossen. Lass uns zusammenfassen, was wir gemacht haben:

- Einen grundlegenden MCP-Server mit Todo-Management-Tools (`create-todo`, `get-todos`, `delete-todo`) eingerichtet
- Rollenbasierte Zugangskontrolle (RBAC) mit unterschiedlichen Berechtigungsstufen f√ºr Benutzer und Admins implementiert
- Den MCP-Server mit einem Autorisierungsserver √ºber MCP Auth integriert
- Den MCP Inspector so konfiguriert, dass Benutzer authentifiziert werden und Zugangstokens mit Berechtigungen zum Aufrufen der Tools verwendet werden

Sieh dir auch andere Tutorials und die Dokumentation an, um das Beste aus MCP Auth herauszuholen.

---
sidebar_position: 2
sidebar_label: 'Tutorial: Baue einen Todo-Manager'
---

import TabItem from '@theme/TabItem';
import Tabs from '@theme/Tabs';


# Tutorial: Baue einen Todo-Manager

In diesem Tutorial bauen wir einen Todo-Manager-MCP-Server mit Benutzer-Authentifizierung und -Autorisierung. Nach der neuesten MCP-Spezifikation agiert unser MCP-Server als OAuth 2.0 **Ressourcenserver (Resource Server)**, der Zugangstokens validiert und berechtigungsbasierte Berechtigungen durchsetzt.

Nach Abschluss dieses Tutorials hast du:

- ‚úÖ Ein grundlegendes Verst√§ndnis, wie du rollenbasierte Zugangskontrolle (RBAC) in deinem MCP-Server einrichtest.
- ‚úÖ Einen MCP-Server, der als Ressourcenserver agiert und Zugangstokens verwendet, die von einem Autorisierungsserver ausgegeben werden.
- ‚úÖ Eine funktionierende Implementierung der durch Berechtigungen gesteuerten Zugriffskontrolle f√ºr Todo-Operationen.

## √úberblick \{#overview}

Das Tutorial umfasst folgende Komponenten:

- **MCP-Client (MCP Inspector)**: Ein visuelles Test-Tool f√ºr MCP-Server, das als OAuth 2.0/OIDC-Client agiert. Es startet den Autorisierungs-Flow mit dem Autorisierungsserver und erh√§lt Zugangstokens, um Anfragen an den MCP-Server zu authentifizieren.
- **Autorisierungsserver**: Ein OAuth 2.1- oder OpenID Connect-Anbieter, der Benutzeridentit√§ten verwaltet, Benutzer authentifiziert und Zugangstokens mit passenden Berechtigungen an autorisierte Clients ausgibt.
- **MCP-Server (Ressourcenserver)**: Nach der neuesten MCP-Spezifikation agiert der MCP-Server als Ressourcenserver im OAuth 2.0-Framework. Er validiert Zugangstokens, die vom Autorisierungsserver ausgegeben wurden, und erzwingt berechtigungsbasierte Berechtigungen f√ºr Todo-Operationen.

Diese Architektur folgt dem Standard-OAuth 2.0-Flow, bei dem:
- Der **MCP Inspector** gesch√ºtzte Ressourcen im Namen des Benutzers anfordert
- Der **Autorisierungsserver** den Benutzer authentifiziert und Zugangstokens ausgibt
- Der **MCP-Server** Tokens validiert und gesch√ºtzte Ressourcen basierend auf gew√§hrten Berechtigungen bereitstellt

Hier ist ein √úberblicksdiagramm der Interaktion zwischen diesen Komponenten:

```mermaid
sequenceDiagram
  autonumber
  participant Client as MCP Inspector<br/>(OAuth-Client)
  participant RS as MCP-Server<br/>(Ressourcenserver)
  participant AS as Autorisierungsserver

  Client->>RS: MCP-Anfrage (kein Token)
  RS-->>Client: 401 Nicht autorisiert (WWW-Authenticate)
  Note over Client: Ressourcen-Metadaten-URL<br/>aus dem WWW-Authenticate-Header extrahieren

  Client->>RS: GET /.well-known/oauth-protected-resource (resource_metadata)
  RS-->>Client: Gesch√ºtzte Ressourcen-Metadaten<br/>(enth√§lt Autorisierungsserver-URL)

  Client->>AS: GET /.well-known/oauth-authorization-server
  AS-->>Client: Autorisierungsserver-Metadaten
  Client->>AS: OAuth-Autorisierung (Login & Zustimmung)
  AS-->>Client: Zugangstoken

  Client->>RS: MCP-Anfrage (Authorization: Bearer <token>)
  RS->>RS: Zugangstoken validieren (g√ºltig und autorisiert)
  RS-->>Client: MCP-Antwort
```

## Verstehe deinen Autorisierungsserver \{#understand-your-authorization-server}

### Zugangstokens mit Berechtigungen (Scopes) \{#access-tokens-with-scopes}

Um [rollenbasierte Zugangskontrolle (RBAC)](https://auth.wiki/rbac) in deinem MCP-Server zu implementieren, muss dein Autorisierungsserver das Ausstellen von Zugangstokens mit Berechtigungen unterst√ºtzen. Berechtigungen (Scopes) repr√§sentieren die Rechte, die einem Benutzer gew√§hrt wurden.

<Tabs groupId="provider">
<TabItem value="logto" label="Logto">

[Logto](https://logto.io) bietet RBAC-Unterst√ºtzung durch seine API-Ressourcen (gem√§√ü [RFC 8707: Resource Indicators for OAuth 2.0](https://datatracker.ietf.org/doc/html/rfc8707)) und Rollenfunktionen. So richtest du es ein:

1. Melde dich bei der [Logto Console](https://cloud.logto.io) (oder deiner selbst gehosteten Logto Console) an.

2. Erstelle API-Ressource und Berechtigungen:

   - Gehe zu "API-Ressourcen"
   - Erstelle eine neue API-Ressource namens "Todo Manager"
   - F√ºge folgende Berechtigungen hinzu:
     - `create:todos`: "Neue Todo-Eintr√§ge erstellen"
     - `read:todos`: "Alle Todo-Eintr√§ge lesen"
     - `delete:todos`: "Beliebigen Todo-Eintrag l√∂schen"

3. Erstelle Rollen (empfohlen f√ºr einfachere Verwaltung):

   - Gehe zu "Rollen"
   - Erstelle eine "Admin"-Rolle und weise alle Berechtigungen zu (`create:todos`, `read:todos`, `delete:todos`)
   - Erstelle eine "User"-Rolle und weise nur die Berechtigung `create:todos` zu

4. Berechtigungen zuweisen:
   - Gehe zu "Benutzer"
   - W√§hle einen Benutzer aus
   - Du kannst entweder:
     - Rollen im Tab "Rollen" zuweisen (empfohlen)
     - Oder direkt Berechtigungen im Tab "Berechtigungen" zuweisen

Die Berechtigungen werden im `scope`-Anspruch des JWT-Zugangstokens als durch Leerzeichen getrennte Zeichenkette enthalten sein.

</TabItem>
<TabItem value="oauth-oidc" label="OAuth 2.0 / OIDC">

OAuth 2.0 / OIDC-Anbieter unterst√ºtzen in der Regel berechtigungsbasierte Zugangskontrolle. Bei der Implementierung von RBAC:

1. Definiere die ben√∂tigten Berechtigungen in deinem Autorisierungsserver
2. Konfiguriere deinen Client so, dass diese Berechtigungen w√§hrend des Autorisierungs-Flows angefordert werden
3. Stelle sicher, dass dein Autorisierungsserver die gew√§hrten Berechtigungen im Zugangstoken eintr√§gt
4. Die Berechtigungen sind √ºblicherweise im `scope`-Anspruch des JWT-Zugangstokens enthalten

Siehe die Dokumentation deines Anbieters f√ºr Details zu:

- Wie du Berechtigungen definierst und verwaltest
- Wie Berechtigungen im Zugangstoken enthalten sind
- Zus√§tzliche RBAC-Funktionen wie Rollenverwaltung

</TabItem>
</Tabs>

### Tokens validieren und Berechtigungen pr√ºfen \{#validating-tokens-and-checking-permissions}

Nach der neuesten MCP-Spezifikation agiert der MCP-Server als **Ressourcenserver (Resource Server)** im OAuth 2.0-Framework. Als Ressourcenserver hat der MCP-Server folgende Aufgaben:

1. **Token-Validierung**: √úberpr√ºfe die Echtheit und Integrit√§t der von MCP-Clients erhaltenen Zugangstokens
2. **Berechtigungsdurchsetzung**: Extrahiere und pr√ºfe die Berechtigungen aus dem Zugangstoken, um festzustellen, welche Operationen der Client ausf√ºhren darf
3. **Ressourcenschutz**: Gebe gesch√ºtzte Ressourcen (Tools ausf√ºhren) nur frei, wenn der Client g√ºltige Tokens mit ausreichenden Berechtigungen vorlegt

Wenn dein MCP-Server eine Anfrage erh√§lt, l√§uft der Validierungsprozess wie folgt ab:

1. Extrahiere das Zugangstoken aus dem `Authorization`-Header (Bearer-Token-Format)
2. √úberpr√ºfe die Signatur und das Ablaufdatum des Zugangstokens
3. Extrahiere die Berechtigungen und Benutzerinformationen aus dem validierten Token
4. Pr√ºfe, ob das Token die erforderlichen Berechtigungen f√ºr die angeforderte Operation enth√§lt

Beispiel: Wenn ein Benutzer einen neuen Todo-Eintrag erstellen m√∂chte, muss sein Zugangstoken die Berechtigung `create:todos` enthalten. So funktioniert der Validierungs-Flow des Ressourcenservers:

```mermaid
sequenceDiagram
    participant Client as MCP-Client
    participant Server as MCP-Server<br/>(Ressourcenserver)
    participant Auth as Autorisierungsserver

    Client->>Server: Anfrage mit Zugangstoken<br/>(Authorization: Bearer <token>)

    alt JWT-Validierung (bevorzugt)
        Server->>Auth: JWKS abrufen (falls nicht im Cache)
        Auth-->>Server: JWKS zur√ºckgeben
        Server->>Server: JWT-Signatur & Claims lokal validieren
    else Token-Introspektion (Fallback)
        Server->>Auth: POST /introspect<br/>(token=access_token)
        Auth-->>Server: Token-Info zur√ºckgeben<br/>(active, scope, user_id, etc.)
    end

    Server->>Server: Berechtigungen & Benutzerkontext<br/>aus validiertem Token extrahieren

    alt Hat erforderliche Berechtigungen
        Server->>Server: Angeforderte Operation ausf√ºhren
        Server->>Client: Operationsergebnis zur√ºckgeben
    else Fehlende Berechtigungen
        Server->>Client: 403 Verboten<br/>(insufficient_scope error)
    end
```

### Dynamische Client-Registrierung \{#dynamic-client-registration}

Die dynamische Client-Registrierung ist f√ºr dieses Tutorial nicht erforderlich, kann aber n√ºtzlich sein, wenn du den MCP-Client-Registrierungsprozess mit deinem Autorisierungsserver automatisieren m√∂chtest. Siehe [Ist Dynamic Client Registration erforderlich?](/provider-list#is-dcr-required) f√ºr weitere Details.

## Verstehe RBAC im Todo-Manager \{#understand-rbac-in-todo-manager}

Zu Demonstrationszwecken implementieren wir ein einfaches rollenbasiertes Zugangskontrollsystem (RBAC) in unserem Todo-Manager-MCP-Server. Das zeigt dir die Grundprinzipien von RBAC bei √ºberschaubarer Implementierung.

:::note
Auch wenn dieses Tutorial RBAC-basierte Berechtigungsverwaltung demonstriert, ist es wichtig zu wissen, dass nicht alle Authentifizierungsanbieter die Berechtigungsverwaltung √ºber Rollen implementieren. Manche Anbieter haben eigene Mechanismen zur Verwaltung von Zugangskontrolle und Berechtigungen.
:::

### Tools und Berechtigungen \{#tools-and-scopes}

Unser Todo-Manager-MCP-Server stellt drei Haupttools bereit:

- `create-todo`: Einen neuen Todo-Eintrag erstellen
- `get-todos`: Alle Todos auflisten
- `delete-todo`: Ein Todo anhand der ID l√∂schen

Zur Zugriffskontrolle auf diese Tools definieren wir folgende Berechtigungen:

- `create:todos`: Erlaubt das Erstellen neuer Todo-Eintr√§ge
- `delete:todos`: Erlaubt das L√∂schen bestehender Todo-Eintr√§ge
- `read:todos`: Erlaubt das Abfragen und Abrufen aller Todo-Eintr√§ge

### Rollen und Berechtigungen \{#roles-and-permissions}

Wir definieren zwei Rollen mit unterschiedlichen Zugriffsrechten:

| Rolle  | create:todos | read:todos | delete:todos |
| ------ | ------------ | ---------- | ------------ |
| Admin  | ‚úÖ           | ‚úÖ         | ‚úÖ           |
| User   | ‚úÖ           |            |              |

- **User**: Ein normaler Benutzer, der Todo-Eintr√§ge erstellen und nur seine eigenen Todos ansehen oder l√∂schen kann
- **Admin**: Ein Administrator, der alle Todo-Eintr√§ge erstellen, ansehen und l√∂schen kann, unabh√§ngig vom Eigent√ºmer

### Ressourcenbesitz \{#resource-ownership}

Obwohl die obige Berechtigungstabelle die explizit zugewiesenen Berechtigungen pro Rolle zeigt, gibt es ein wichtiges Prinzip des Ressourcenbesitzes:

- **Benutzer** haben nicht die Berechtigungen `read:todos` oder `delete:todos`, k√∂nnen aber trotzdem:
  - Ihre eigenen Todo-Eintr√§ge lesen
  - Ihre eigenen Todo-Eintr√§ge l√∂schen
- **Admins** haben volle Berechtigungen (`read:todos` und `delete:todos`) und k√∂nnen:
  - Alle Todo-Eintr√§ge im System sehen
  - Jeden Todo-Eintrag l√∂schen, unabh√§ngig vom Eigent√ºmer

Das demonstriert ein h√§ufiges Muster in RBAC-Systemen, bei dem der Besitz einer Ressource implizite Rechte f√ºr eigene Ressourcen gew√§hrt, w√§hrend administrative Rollen explizite Rechte f√ºr alle Ressourcen erhalten.

:::tip Mehr erfahren
Um tiefer in RBAC-Konzepte und Best Practices einzutauchen, siehe [Mastering RBAC: A Comprehensive Real-World Example](https://blog.logto.io/mastering-rbac).
:::

## Autorisierung im Anbieter konfigurieren \{#configure-authorization-in-your-provider}

Um das oben beschriebene Zugangskontrollsystem zu implementieren, musst du deinen Autorisierungsserver so konfigurieren, dass er die ben√∂tigten Berechtigungen unterst√ºtzt. So geht es mit verschiedenen Anbietern:

<Tabs groupId="provider">
<TabItem value="logto" label="Logto">

[Logto](https://logto.io) bietet RBAC-Unterst√ºtzung durch seine API-Ressourcen und Rollenfunktionen. So richtest du es ein:

1. Melde dich bei der [Logto Console](https://cloud.logto.io) (oder deiner selbst gehosteten Logto Console) an.

2. Erstelle API-Ressource und Berechtigungen:

   - Gehe zu "API-Ressourcen"
   - Erstelle eine neue API-Ressource namens "Todo Manager" und verwende `http://localhost:3001` als Ressourcenindikator.
     - **Wichtig**: Der Ressourcenindikator muss mit der URL deines MCP-Servers √ºbereinstimmen. F√ºr dieses Tutorial verwenden wir `http://localhost:3001`, da unser MCP-Server auf Port 3001 l√§uft. In Produktion verwende deine tats√§chliche MCP-Server-URL (z. B. `https://your-mcp-server.example.com`).
   - Erstelle folgende Berechtigungen:
     - `create:todos`: "Neue Todo-Eintr√§ge erstellen"
     - `read:todos`: "Alle Todo-Eintr√§ge lesen"
     - `delete:todos`: "Beliebigen Todo-Eintrag l√∂schen"

3. Erstelle Rollen (empfohlen f√ºr einfachere Verwaltung):

   - Gehe zu "Rollen"
   - Erstelle eine "Admin"-Rolle und weise alle Berechtigungen zu (`create:todos`, `read:todos`, `delete:todos`)
   - Erstelle eine "User"-Rolle und weise nur die Berechtigung `create:todos` zu
   - Wechsle auf der Detailseite der "User"-Rolle zum Tab "Allgemein" und setze die "User"-Rolle als "Standardrolle".

4. Benutzerrollen und Berechtigungen verwalten:
   - F√ºr neue Benutzer:
     - Sie erhalten automatisch die "User"-Rolle, da wir sie als Standardrolle gesetzt haben
   - F√ºr bestehende Benutzer:
     - Gehe zu "Benutzerverwaltung"
     - W√§hle einen Benutzer aus
     - Weise dem Benutzer Rollen im Tab "Rollen" zu

:::tip Programmatische Rollenverwaltung
Du kannst auch die [Management API](https://docs.logto.io/integrate-logto/interact-with-management-api) von Logto verwenden, um Benutzerrollen programmatisch zu verwalten. Das ist besonders n√ºtzlich f√ºr automatisierte Benutzerverwaltung oder beim Bau von Admin-Panels.
:::

Beim Anfordern eines Zugangstokens wird Logto die Berechtigungen im `scope`-Anspruch des Tokens basierend auf den Rollenzuweisungen des Benutzers eintragen.

</TabItem>
<TabItem value="oauth-or-oidc" label="OAuth 2 / OIDC">

F√ºr OAuth 2.0- oder OpenID Connect-Anbieter musst du die Berechtigungen konfigurieren, die verschiedene Rechte repr√§sentieren. Die genauen Schritte h√§ngen vom Anbieter ab, aber im Allgemeinen:

1. Berechtigungen definieren:

   - Konfiguriere deinen Autorisierungsserver so, dass er unterst√ºtzt:
     - `create:todos`
     - `read:todos`
     - `delete:todos`

2. Client konfigurieren:

   - Registriere oder aktualisiere deinen Client, damit diese Berechtigungen angefordert werden
   - Stelle sicher, dass die Berechtigungen im Zugangstoken enthalten sind

3. Berechtigungen zuweisen:
   - Verwende die Oberfl√§che deines Anbieters, um Benutzern passende Berechtigungen zuzuweisen
   - Manche Anbieter unterst√ºtzen rollenbasierte Verwaltung, andere direkte Berechtigungszuweisung
   - Siehe die Dokumentation deines Anbieters f√ºr den empfohlenen Ansatz

:::tip
Die meisten Anbieter werden die gew√§hrten Berechtigungen im `scope`-Anspruch des Zugangstokens eintragen. Das Format ist typischerweise eine durch Leerzeichen getrennte Zeichenkette von Berechtigungswerten.
:::

</TabItem>
</Tabs>

Nach der Konfiguration deines Autorisierungsservers erhalten Benutzer Zugangstokens mit ihren gew√§hrten Berechtigungen. Der MCP-Server verwendet diese Berechtigungen, um zu bestimmen:

- Ob ein Benutzer neue Todos erstellen darf (`create:todos`)
- Ob ein Benutzer alle Todos (`read:todos`) oder nur seine eigenen sehen darf
- Ob ein Benutzer beliebige Todos (`delete:todos`) oder nur seine eigenen l√∂schen darf

## MCP-Server einrichten \{#set-up-the-mcp-server}

Wir verwenden die [offiziellen MCP-SDKs](https://github.com/modelcontextprotocol), um unseren Todo-Manager-MCP-Server zu erstellen.

### Neues Projekt erstellen \{#create-a-new-project}

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

Neues Python-Projekt einrichten:

```bash
mkdir mcp-todo-server
cd mcp-todo-server

# Neues Python-Projekt initialisieren
uv init

# Neue virtuelle Umgebung mit uv erstellen
uv venv

# Virtuelle Umgebung aktivieren (optional bei 'uv run')
source .venv/bin/activate
```

:::note
Dieses Projekt verwendet `uv` f√ºr das Paketmanagement, aber du kannst auch andere Paketmanager wie `pip`, `poetry` oder `conda` verwenden.
:::

</TabItem>
<TabItem value="node" label="Node.js">

Neues Node.js-Projekt einrichten:

```bash
mkdir mcp-server
cd mcp-server
npm init -y # Oder `pnpm init` verwenden
npm pkg set type="module"
npm pkg set main="todo-manager.ts"
npm pkg set scripts.start="node --experimental-strip-types todo-manager.ts"
```

:::note
Wir verwenden TypeScript in unseren Beispielen, da Node.js v22.6.0+ TypeScript nativ mit dem Flag `--experimental-strip-types` unterst√ºtzt. Wenn du JavaScript verwendest, ist der Code √§hnlich ‚Äì stelle nur sicher, dass du Node.js v22.6.0 oder neuer verwendest. Siehe Node.js-Dokumentation f√ºr Details.
:::

</TabItem>
</Tabs>

### MCP-SDK und Abh√§ngigkeiten installieren \{#install-the-mcp-sdk-and-dependencies}

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

Installiere die ben√∂tigten Abh√§ngigkeiten:

```bash
uv add "mcp[cli]" uvicorn starlette
```

</TabItem>
<TabItem value="node" label="Node.js">

```bash
npm install @modelcontextprotocol/sdk express zod
```

Oder einen anderen Paketmanager deiner Wahl, wie `pnpm` oder `yarn`.

</TabItem>
</Tabs>

### MCP-Server erstellen \{#create-the-mcp-server}

Erstelle zun√§chst einen Basis-MCP-Server mit den Tool-Definitionen:

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

Erstelle eine Datei namens `server.py` und f√ºge folgenden Code hinzu:

```python
# server.py

import contextlib
from typing import Any
from mcp.server.fastmcp import FastMCP
from starlette.applications import Starlette
from starlette.routing import Mount

# Initialisiere den FastMCP-Server
mcp = FastMCP(name="Todo Manager", stateless_http=True, streamable_http_path='/')

@mcp.tool()
def create_todo(content: str) -> dict[str, Any]:
    """Neues Todo erstellen. Erfordert 'create:todos'-Berechtigung."""
    return {"error": "Not implemented"}

@mcp.tool()
def get_todos() -> dict[str, Any]:
    """Todos auflisten. Benutzer mit 'read:todos'-Berechtigung sehen alle Todos."""
    return {"error": "Not implemented"}

@mcp.tool()
def delete_todo(id: str) -> dict[str, Any]:
    """Todo anhand der ID l√∂schen. Benutzer k√∂nnen ihre eigenen Todos l√∂schen."""
    return {"error": "Not implemented"}

@contextlib.asynccontextmanager
async def lifespan(app: Starlette):
    async with contextlib.AsyncExitStack() as stack:
        await stack.enter_async_context(mcp.session_manager.run())
        yield

# App erstellen
app = Starlette(
    routes=[
        Mount("/", app=mcp.streamable_http_app()),
    ],
    lifespan=lifespan,
)
```

Starte den Server mit:

```bash
# Todo Manager Server mit uvicorn starten
uvicorn server:app --host 127.0.0.1 --port 3001

# Oder mit uv:
# uv run uvicorn server:app --host 127.0.0.1 --port 3001
```

</TabItem>
<TabItem value="node" label="Node.js">

Erstelle eine Datei namens `todo-manager.ts` und f√ºge folgenden Code hinzu:

```ts
// todo-manager.ts

import { z } from 'zod';
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { StreamableHTTPServerTransport } from '@modelcontextprotocol/sdk/server/streamableHttp.js';
import express, { type Request, type Response } from 'express';

// MCP-Server erstellen
const server = new McpServer({
  name: 'Todo Manager',
  version: '0.0.0',
});

server.tool('create-todo', 'Neues Todo erstellen', { content: z.string() }, async ({ content }) => {
  return {
    content: [{ type: 'text', text: JSON.stringify({ error: 'Not implemented' }) }],
  };
});

server.tool('get-todos', 'Alle Todos auflisten', async () => {
  return {
    content: [{ type: 'text', text: JSON.stringify({ error: 'Not implemented' }) }],
  };
});

server.tool('delete-todo', 'Todo anhand der ID l√∂schen', { id: z.string() }, async ({ id }) => {
  return {
    content: [{ type: 'text', text: JSON.stringify({ error: 'Not implemented' }) }],
  };
});

// Boilerplate-Code aus der MCP-SDK-Dokumentation
const PORT = 3001;
const app = express();

app.post('/', async (request: Request, response: Response) => {
  // Im stateless-Modus f√ºr jede Anfrage eine neue Instanz von Transport und Server erstellen,
  // um vollst√§ndige Isolation zu gew√§hrleisten. Eine einzelne Instanz w√ºrde zu Request-ID-Kollisionen f√ºhren,
  // wenn mehrere Clients gleichzeitig verbinden.

  try {
    const transport: StreamableHTTPServerTransport = new StreamableHTTPServerTransport({
      sessionIdGenerator: undefined,
    });
    response.on('close', async () => {
      console.log('Request closed');
      await transport.close();
      await server.close();
    });
    await server.connect(transport);
    await transport.handleRequest(request, response, request.body);
  } catch (error) {
    console.error('Fehler bei der MCP-Anfrage:', error);
    if (!response.headersSent) {
      response.status(500).json({
        jsonrpc: '2.0',
        error: {
          code: -32_603,
          message: 'Internal server error',
        },
        id: null,
      });
    }
  }
});

// SSE-Benachrichtigungen werden im stateless-Modus nicht unterst√ºtzt
app.get('/', async (request: Request, response: Response) => {
  console.log('GET-MCP-Anfrage erhalten');
  response.writeHead(405).end(
    JSON.stringify({
      jsonrpc: '2.0',
      error: {
        code: -32_000,
        message: 'Method not allowed.',
      },
      id: null,
    })
  );
});

// Sitzungsbeendigung im stateless-Modus nicht erforderlich
app.delete('/', async (request: Request, response: Response) => {
  console.log('DELETE-MCP-Anfrage erhalten');
  response.writeHead(405).end(
    JSON.stringify({
      jsonrpc: '2.0',
      error: {
        code: -32_000,
        message: 'Method not allowed.',
      },
      id: null,
    })
  );
});

app.listen(PORT);
```

Starte den Server mit:

```bash
npm start
```

</TabItem>
</Tabs>

### MCP-Server inspizieren \{#inspect-the-mcp-server}

#### MCP Inspector klonen und starten \{#clone-and-run-mcp-inspector}

Nachdem der MCP-Server l√§uft, k√∂nnen wir den MCP Inspector verwenden, um zu pr√ºfen, ob Tools verf√ºgbar sind.

Die offizielle MCP Inspector v0.16.2 hat einige Bugs, die die Authentifizierungsfunktionalit√§t beeintr√§chtigen. Um diese Probleme zu beheben, haben wir eine [gepatchte Version des MCP Inspectors](https://github.com/mcp-auth/inspector/tree/patch/0.16.2-fixes) erstellt, die notwendige Fixes f√ºr OAuth/OIDC-Authentifizierungsflows enth√§lt. Wir haben auch Pull Requests an das offizielle Repository eingereicht, um diese Fixes beizutragen.

Um den MCP Inspector zu starten, verwende folgenden Befehl (Node.js erforderlich):

```bash
git clone https://github.com/mcp-auth/inspector.git -b patch/0.16.2-fixes
cd inspector
npm install
npm run dev
```

Der MCP Inspector √∂ffnet sich automatisch im Standardbrowser, oder du kannst ihn manuell √ºber den Link aus der Terminalausgabe aufrufen (achte darauf, den Link mit dem Parameter `MCP_PROXY_AUTH_TOKEN` zu verwenden, z. B. `http://localhost:6274/?MCP_PROXY_AUTH_TOKEN=458ae4a4...acab1907`).

#### MCP Inspector mit dem MCP-Server verbinden \{#connect-mcp-inspector-to-the-mcp-server}

Vor dem Fortfahren pr√ºfe folgende Konfiguration im MCP Inspector:

- **Transport-Typ**: Setze auf `Streamable HTTP`.
- **URL**: Setze auf die URL deines MCP-Servers. In unserem Fall: `http://localhost:3001`.

Jetzt kannst du auf den "Connect"-Button klicken, um zu sehen, ob der MCP Inspector eine Verbindung zum MCP-Server herstellen kann. Wenn alles funktioniert, siehst du den Status "Connected" im MCP Inspector.

#### Checkpoint: Todo-Manager-Tools ausf√ºhren \{#checkpoint-run-todo-manager-tools}

1. Klicke im oberen Men√º des MCP Inspectors auf den Tab "Tools".
2. Klicke auf den Button "List Tools".
3. Du solltest die Tools `create-todo`, `get-todos` und `delete-todo` aufgelistet sehen. Klicke darauf, um die Tool-Details zu √∂ffnen.
4. Rechts solltest du den Button "Run Tool" sehen. Klicke darauf und gib die erforderlichen Parameter ein, um das Tool auszuf√ºhren.
5. Du solltest das Tool-Ergebnis mit der JSON-Antwort `{"error": "Not implemented"}` sehen.

![MCP Inspector erster Lauf](/docs-assets/images/tutorials/todo-manager/inspector-first-run.png)

## Integration mit deinem Autorisierungsserver \{#integrate-with-your-authorization-server}

F√ºr diesen Abschnitt gibt es einige √úberlegungen:

<details>
<summary>**Die Issuer-URL deines Autorisierungsservers**</summary>

Dies ist normalerweise die Basis-URL deines Autorisierungsservers, z. B. `https://auth.example.com`. Manche Anbieter haben einen Pfad wie `https://example.logto.app/oidc`, pr√ºfe daher die Dokumentation deines Anbieters.

</details>

<details>
<summary>**Wie du die Metadaten des Autorisierungsservers abrufst**</summary>

- Wenn dein Autorisierungsserver dem [OAuth 2.0 Authorization Server Metadata](https://datatracker.ietf.org/doc/html/rfc8414) oder [OpenID Connect Discovery](https://openid.net/specs/openid-connect-discovery-1_0.html) entspricht, kannst du die eingebauten Utilities von MCP Auth verwenden, um die Metadaten automatisch abzurufen.
- Wenn dein Autorisierungsserver diese Standards nicht unterst√ºtzt, musst du die Metadaten-URL oder Endpunkte manuell in der MCP-Server-Konfiguration angeben. Siehe die Dokumentation deines Anbieters f√ºr die spezifischen Endpunkte.

</details>

<details>
<summary>**Wie du den MCP Inspector als Client im Autorisierungsserver registrierst**</summary>

- Wenn dein Autorisierungsserver [Dynamic Client Registration](https://datatracker.ietf.org/doc/html/rfc7591) unterst√ºtzt, kannst du diesen Schritt √ºberspringen, da der MCP Inspector sich automatisch als Client registriert.
- Wenn dein Autorisierungsserver Dynamic Client Registration nicht unterst√ºtzt, musst du den MCP Inspector manuell als Client im Autorisierungsserver registrieren.

</details>

<details>
<summary>**Verstehe Token-Request-Parameter**</summary>

Beim Anfordern von Zugangstokens von verschiedenen Autorisierungsservern gibt es verschiedene Ans√§tze, um die Zielressource und Berechtigungen anzugeben. Hier die Hauptmuster:

- **Ressourcenindikator-basiert**:

  - Verwendet den Parameter `resource`, um die Ziel-API anzugeben (siehe [RFC 8707: Resource Indicators for OAuth 2.0](https://datatracker.ietf.org/doc/html/rfc8707))
  - H√§ufig in modernen OAuth 2.0-Implementierungen
  - Beispielanfrage:
    ```json
    {
      "resource": "http://localhost:3001",
      "scope": "create:todos read:todos"
    }
    ```
  - Der Server gibt Tokens aus, die speziell an die angeforderte Ressource gebunden sind

- **Audience-basiert**:

  - Verwendet den Parameter `audience`, um den beabsichtigten Token-Empf√§nger anzugeben
  - √Ñhnlich wie Ressourcenindikatoren, aber mit anderen Semantiken
  - Beispielanfrage:
    ```json
    {
      "audience": "todo-api",
      "scope": "create:todos read:todos"
    }
    ```

- **Nur Scope-basiert**:
  - Verwendet ausschlie√ülich Berechtigungen ohne resource/audience-Parameter
  - Traditioneller OAuth 2.0-Ansatz
  - Beispielanfrage:
    ```json
    {
      "scope": "todo-api:create todo-api:read openid profile"
    }
    ```
  - Oft werden Pr√§fixe verwendet, um Berechtigungen zu namespacen
  - H√§ufig in einfacheren OAuth 2.0-Implementierungen

:::tip Best Practices

- Pr√ºfe die Dokumentation deines Anbieters auf unterst√ºtzte Parameter
- Manche Anbieter unterst√ºtzen mehrere Ans√§tze gleichzeitig
- Ressourcenindikatoren bieten bessere Sicherheit durch Audience-Restriktion
- Verwende Ressourcenindikatoren, wenn verf√ºgbar, f√ºr bessere Zugangskontrolle
  :::

</details>

Auch wenn jeder Anbieter eigene Anforderungen hat, f√ºhren dich die folgenden Schritte durch die Integration des MCP Inspectors und MCP Servers mit anbieter-spezifischen Konfigurationen.

### MCP Inspector als Client registrieren \{#register-mcp-inspector-as-a-client}

<Tabs groupId="provider">
<TabItem value="logto" label="Logto">

Die Integration des Todo-Managers mit [Logto](https://logto.io) ist einfach, da es ein OpenID Connect-Anbieter ist, der Ressourcenindikatoren und Berechtigungen unterst√ºtzt. So kannst du deine Todo-API mit `http://localhost:3001` als Ressourcenindikator absichern.

Da Logto noch keine Dynamic Client Registration unterst√ºtzt, musst du den MCP Inspector manuell als Client in deinem Logto-Tenant registrieren:

1. √ñffne deinen MCP Inspector, gehe zur Authentifizierungskonfiguration und klicke auf die "OAuth2.0 Flow"-Konfiguration. Kopiere den **Redirect URI**-Wert, z. B. `http://localhost:6274/oauth/callback`.
2. Melde dich bei der [Logto Console](https://cloud.logto.io) (oder deiner selbst gehosteten Logto Console) an.
3. Navigiere zum Tab "Anwendungen", klicke auf "Anwendung erstellen". Unten auf der Seite klicke auf "App ohne Framework erstellen".
4. F√ºlle die Anwendungsdetails aus und klicke auf "Anwendung erstellen":
   - **Anwendungstyp ausw√§hlen**: "Single-page application" w√§hlen.
   - **Anwendungsname**: Z. B. "MCP Inspector".
5. Im Bereich "Einstellungen / Redirect URIs" f√ºge den kopierten **Redirect URI** ein. Klicke dann unten auf "√Ñnderungen speichern".
6. Im oberen Bereich siehst du den Wert "App ID". Kopiere ihn.
7. Gehe zur√ºck zum MCP Inspector und f√ºge die "App ID" in der Authentifizierungskonfiguration unter "OAuth2.0 Flow" im Feld "Client ID" ein.
8. Im Feld "Scope" gib ein: `create:todos read:todos delete:todos`. So enth√§lt das Zugangstoken von Logto die n√∂tigen Berechtigungen f√ºr den Todo-Manager.

</TabItem>
<TabItem value="oauth-oidc" label="OAuth 2.0 / OIDC">

:::note
Dies ist eine generische Anleitung f√ºr OAuth 2.0 / OpenID Connect-Anbieter. Beide folgen √§hnlichen Schritten, da OIDC auf OAuth 2.0 aufbaut. Siehe die Dokumentation deines Anbieters f√ºr Details.
:::

Wenn dein Anbieter Dynamic Client Registration unterst√ºtzt, kannst du direkt zu Schritt 8 unten gehen; andernfalls musst du den MCP Inspector manuell als Client registrieren:

1. √ñffne deinen MCP Inspector, gehe zur Authentifizierungskonfiguration und klicke auf die "OAuth2.0 Flow"-Konfiguration. Kopiere den **Redirect URI**-Wert, z. B. `http://localhost:6274/oauth/callback`.

2. Melde dich in der Konsole deines Anbieters an.

3. Navigiere zum Bereich "Anwendungen" oder "Clients" und erstelle eine neue Anwendung oder einen neuen Client.

4. Falls erforderlich, w√§hle als Client-Typ "Single-page application" oder "Public client".

5. Nach dem Erstellen der Anwendung musst du den Redirect URI konfigurieren. F√ºge den kopierten **Redirect URI** ein.

6. Finde die "Client ID" oder "Application ID" der neuen Anwendung und kopiere sie.

7. Gehe zur√ºck zum MCP Inspector und f√ºge die "Client ID" in der Authentifizierungskonfiguration unter "OAuth2.0 Flow" im Feld "Client ID" ein.

8. Im Feld "Scope" gib folgende Berechtigungen ein, um die n√∂tigen Rechte f√ºr Todo-Operationen anzufordern:

```text
create:todos read:todos delete:todos
```

</TabItem>
</Tabs>

### MCP Auth einrichten \{#set-up-mcp-auth}

Installiere zun√§chst das MCP Auth SDK in deinem MCP-Server-Projekt.

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

```bash
uv add mcpauth==0.2.0b1
```

</TabItem>
<TabItem value="node" label="Node.js">

```bash
npm install mcp-auth@0.2.0-beta.1
```

</TabItem>
</Tabs>

Jetzt m√ºssen wir MCP Auth im MCP-Server initialisieren. Das umfasst zwei Hauptschritte:

1. **Metadaten des Autorisierungsservers abrufen**: Wird f√ºr die sp√§tere MCP Auth-√úberpr√ºfung der vom Autorisierungsserver ausgegebenen Zugangstokens verwendet und um die Issuer-ID des Auth-Servers in den Ressourcenmetadaten einzutragen
2. **Gesch√ºtzte Ressourcenmetadaten konfigurieren**: Definiere die Ressourcenkennung deines MCP-Servers und unterst√ºtzte Berechtigungen

#### Schritt 1: Metadaten des Autorisierungsservers abrufen \{#step-1-fetch-authorization-server-metadata\}

Laut OAuth / OIDC-Spezifikation k√∂nnen wir die Metadaten des Autorisierungsservers anhand der Issuer-URL abrufen.

<Tabs groupId="provider">

<TabItem value="logto" label="Logto">

In Logto findest du die Issuer-URL auf der Anwendungsdetailseite in der Logto Console unter "Endpoints & Credentials / Issuer endpoint". Sie sieht aus wie `https://my-project.logto.app/oidc`.

</TabItem>

<TabItem value="oauth-oidc" label="OAuth 2.0 / OIDC">

F√ºr OAuth 2.0-Anbieter musst du:

1. Die Dokumentation deines Anbieters nach der Autorisierungsserver-URL (oft Issuer-URL oder Basis-URL genannt) durchsuchen
2. Manche Anbieter stellen dies unter `https://{your-domain}/.well-known/oauth-authorization-server` bereit
3. Im Admin-Panel deines Anbieters unter OAuth/API-Einstellungen nachsehen

</TabItem>

</Tabs>

Jetzt rufe die Metadaten des Autorisierungsservers mit der MCP Auth Utility-Funktion ab:

<Tabs groupId="sdk">

<TabItem value="python" label="Python">
```python
from mcpauth import MCPAuth
from mcpauth.config import AuthServerType
from mcpauth.utils import fetch_server_config

issuer_url = "<issuer-url>"  # Ersetze durch die Issuer-URL deines Autorisierungsservers

# Autorisierungsserver-Konfiguration abrufen
auth_server_config = fetch_server_config(issuer_url, AuthServerType.OIDC) # oder AuthServerType.OAUTH
```

</TabItem>
<TabItem value="node" label="Node.js">
```js
import { MCPAuth, fetchServerConfig } from 'mcp-auth';

const issuerUrl = '<issuer-url>'; // Ersetze durch die Issuer-URL deines Autorisierungsservers

// Autorisierungsserver-Konfiguration abrufen (OIDC Discovery)
const authServerConfig = await fetchServerConfig(issuerUrl, { type: 'oidc' }); // oder { type: 'oauth' }
```

</TabItem>
</Tabs>

Wenn du alternative Wege ben√∂tigst, um die Metadaten des Autorisierungsservers abzurufen oder die Konfiguration anpassen m√∂chtest, siehe [Andere Wege zur Konfiguration der Autorisierungsserver-Metadaten](/docs/configure-server/mcp-auth#other-ways).

#### Schritt 2: Gesch√ºtzte Ressourcenmetadaten konfigurieren \{#step-2-configure-protected-resource-metadata}

Als n√§chstes konfigurieren wir die Protected Resource Metadata beim Erstellen der MCP Auth-Instanz. Anschlie√üend stellt der MCP-Server die in MCP Auth konfigurierten Ressourcenmetadaten bereit.

<Tabs groupId="sdk">

<TabItem value="python" label="Python">
```python
# server.py

# weitere Importe...
from mcpauth.types import ResourceServerConfig, ResourceServerMetadata

# Ressourcenkennung f√ºr diesen MCP-Server definieren
resource_id = "http://localhost:3001"

mcp_auth = MCPAuth(
    protected_resources=ResourceServerConfig(
        metadata=ResourceServerMetadata(
            resource=resource_id,
            # Autorisierungsserver-Metadaten aus dem vorherigen Schritt
            authorization_servers=[auth_server_config],
            # Unterst√ºtzte Berechtigungen dieses MCP-Servers
            scopes_supported=[
                "create:todos",
                "read:todos",
                "delete:todos"
            ]
        )
    )
)
```
</TabItem>

<TabItem value="node" label="Node.js">
```js
// todo-manager.ts

// Ressourcenkennung f√ºr diesen MCP-Server definieren
const resourceId = 'http://localhost:3001';

// MCP Auth mit Ressourcenmetadaten konfigurieren
const mcpAuth = new MCPAuth({
  protectedResources: {
    metadata: {
      resource: resourceId,
      // Autorisierungsserver-Metadaten aus dem vorherigen Schritt
      authorizationServers: [authServerConfig],
      // Unterst√ºtzte Berechtigungen dieses MCP-Servers
      scopesSupported: [
        "create:todos",
        "read:todos",
        "delete:todos"
      ]
    }
  }
});
```
</TabItem>

</Tabs>

### MCP-Server aktualisieren \{#update-mcp-server}

Fast geschafft! Jetzt aktualisieren wir den MCP-Server, um die MCP Auth-Route und Middleware-Funktion anzuwenden und die berechtigungsbasierte Zugriffskontrolle f√ºr die Todo-Manager-Tools basierend auf den Benutzerberechtigungen zu implementieren.

Jetzt Protected Resource Metadata-Routen anwenden, damit MCP-Clients die erwarteten Ressourcenmetadaten vom MCP-Server abrufen k√∂nnen.

<Tabs groupId="sdk">
<TabItem value="python" label="Python">
```python
# server.py

# ..weitere Codes

app = Starlette(
    routes=[
        # Protected Resource Metadata-Routen einrichten
        # Stellt Metadaten √ºber diesen Ressourcenserver f√ºr OAuth-Clients bereit
        *mcp_auth.resource_metadata_router().routes,
        Mount("/", app=mcp.streamable_http_app()),
    ],
    lifespan=lifespan,
)
```
</TabItem>
<TabItem value="node" label="Node.js">

```ts
// todo-manager.ts

// Protected Resource Metadata-Routen einrichten
// Stellt Metadaten √ºber diesen Ressourcenserver f√ºr OAuth-Clients bereit
app.use(mcpAuth.protectedResourceMetadataRouter());

```
</TabItem>
</Tabs>

Als n√§chstes wenden wir die MCP Auth-Middleware auf den MCP-Server an. Diese Middleware √ºbernimmt Authentifizierung und Autorisierung f√ºr eingehende Anfragen und stellt sicher, dass nur autorisierte Benutzer Zugriff auf die Todo-Manager-Tools haben.

<Tabs groupId="sdk">
<TabItem value="python" label="Python">
```python
# server.py

# weitere Importe...
from starlette.middleware import Middleware

# weitere Codes...

# Middleware erstellen
bearer_auth = Middleware(mcp_auth.bearer_auth_middleware('jwt', resource=resource_id, audience=resource_id))

app = Starlette(
    routes=[
        *mcp_auth.resource_metadata_router().routes,
        # MCP Auth-Middleware anwenden
        Mount("/", app=mcp.streamable_http_app(), middleware=[bearer_auth]),
    ],
    lifespan=lifespan,
)
```
</TabItem>
<TabItem value="node" label="Node.js">

```ts
// todo-manager.ts

app.use(mcpAuth.protectedResourceMetadataRouter());

// MCP Auth-Middleware anwenden
app.use(
  mcpAuth.bearerAuth('jwt', {
    resource: resourceId,
    audience: resourceId,
  })
);
```
</TabItem>
</Tabs>

Jetzt k√∂nnen wir die Todo-Manager-Tools so aktualisieren, dass sie die MCP Auth-Middleware f√ºr Authentifizierung und Autorisierung nutzen.

Aktualisiere die Implementierung der Tools wie folgt.

<Tabs groupId="sdk">
<TabItem value="python" label="Python">
```python
# server.py

# weitere Importe...

from typing import Any, List, Optional
from mcpauth.exceptions import MCPAuthBearerAuthException, BearerAuthExceptionCode
from mcpauth.types import AuthInfo, ResourceServerConfig, ResourceServerMetadata

# Wird im n√§chsten Abschnitt erw√§hnt
from service import TodoService

def assert_user_id(auth_info: Optional[AuthInfo]) -> str:
    """Stellt sicher, dass auth_info eine g√ºltige Benutzer-ID enth√§lt und gibt sie zur√ºck."""
    if not auth_info or not auth_info.subject:
        raise Exception("Invalid auth info")
    return auth_info.subject

def has_required_scopes(user_scopes: List[str], required_scopes: List[str]) -> bool:
    """Pr√ºft, ob der Benutzer alle erforderlichen Berechtigungen hat."""
    return all(scope in user_scopes for scope in required_scopes)

# TodoService-Instanz erstellen
todo_service = TodoService()

@mcp.tool()
def create_todo(content: str) -> dict[str, Any]:
    """Neues Todo erstellen. Erfordert 'create:todos'-Berechtigung."""
    auth_info = mcp_auth.auth_info
    user_id = assert_user_id(auth_info)
    
    # Nur Benutzer mit 'create:todos'-Berechtigung d√ºrfen Todos erstellen
    user_scopes = auth_info.scopes if auth_info else []
    if not has_required_scopes(user_scopes, ["create:todos"]):
        raise MCPAuthBearerAuthException(BearerAuthExceptionCode.MISSING_REQUIRED_SCOPES)
    
    created_todo = todo_service.create_todo(content=content, owner_id=user_id)
    return created_todo

@mcp.tool()
def get_todos() -> dict[str, Any]:
    """
    Todos auflisten. Benutzer mit 'read:todos'-Berechtigung sehen alle Todos,
    sonst nur ihre eigenen Todos.
    """
    auth_info = mcp_auth.auth_info
    user_id = assert_user_id(auth_info)
    
    # Mit 'read:todos'-Berechtigung Zugriff auf alle Todos,
    # sonst nur eigene Todos
    user_scopes = auth_info.scopes if auth_info else []
    todo_owner_id = None if has_required_scopes(user_scopes, ["read:todos"]) else user_id
    
    todos = todo_service.get_all_todos(todo_owner_id)
    return {"todos": todos}

@mcp.tool()
def delete_todo(id: str) -> dict[str, Any]:
    """
    Todo anhand der ID l√∂schen. Benutzer k√∂nnen ihre eigenen Todos l√∂schen.
    Benutzer mit 'delete:todos'-Berechtigung k√∂nnen beliebige Todos l√∂schen.
    """
    auth_info = mcp_auth.auth_info
    user_id = assert_user_id(auth_info)
    
    todo = todo_service.get_todo_by_id(id)
    
    if not todo:
        return {"error": "Failed to delete todo"}
    
    # Benutzer k√∂nnen nur ihre eigenen Todos l√∂schen
    # Benutzer mit 'delete:todos'-Berechtigung k√∂nnen beliebige Todos l√∂schen
    user_scopes = auth_info.scopes if auth_info else []
    if todo.owner_id != user_id and not has_required_scopes(user_scopes, ["delete:todos"]):
        return {"error": "Failed to delete todo"}
    
    deleted_todo = todo_service.delete_todo(id)
    
    if deleted_todo:
        return {
            "message": f"Todo {id} deleted",
            "details": deleted_todo
        }
    else:
        return {"error": "Failed to delete todo"}
```
</TabItem>

<TabItem value="node" label="Node.js">
```js
// todo-manager.ts

// weitere Importe...
import assert from 'node:assert';
import { fetchServerConfig, MCPAuth, MCPAuthBearerAuthError } from 'mcp-auth';
import { type AuthInfo } from '@modelcontextprotocol/sdk/server/auth/types.js';

// Wird im n√§chsten Abschnitt erw√§hnt
import { TodoService } from './todo-service.js';

const assertUserId = (authInfo?: AuthInfo) => {
  const { subject } = authInfo ?? {};
  assert(subject, 'Invalid auth info');
  return subject;
};

const hasRequiredScopes = (userScopes: string[], requiredScopes: string[]): boolean => {
  return requiredScopes.every((scope) => userScopes.includes(scope));
};

const todoService = new TodoService();

server.tool(
  'create-todo',
  'Neues Todo erstellen',
  { content: z.string() },
  ({ content }: { content: string }, { authInfo }) => {
    const userId = assertUserId(authInfo);

    /**
     * Nur Benutzer mit 'create:todos'-Berechtigung d√ºrfen Todos erstellen
     */
    if (!hasRequiredScopes(authInfo?.scopes ?? [], ['create:todos'])) {
      throw new MCPAuthBearerAuthError('missing_required_scopes');
    }

    const createdTodo = todoService.createTodo({ content, ownerId: userId });

    return {
      content: [{ type: 'text', text: JSON.stringify(createdTodo) }],
    };
  }
);

server.tool('get-todos', 'Alle Todos auflisten', ({ authInfo }) => {
  const userId = assertUserId(authInfo);

  /**
   * Mit 'read:todos'-Berechtigung Zugriff auf alle Todos (todoOwnerId = undefined)
   * Ohne 'read:todos'-Berechtigung nur eigene Todos (todoOwnerId = userId)
   */
  const todoOwnerId = hasRequiredScopes(authInfo?.scopes ?? [], ['read:todos'])
    ? undefined
    : userId;

  const todos = todoService.getAllTodos(todoOwnerId);

  return {
    content: [{ type: 'text', text: JSON.stringify(todos) }],
  };
});

server.tool(
  'delete-todo',
  'Todo anhand der ID l√∂schen',
  { id: z.string() },
  ({ id }: { id: string }, { authInfo }) => {
    const userId = assertUserId(authInfo);

    const todo = todoService.getTodoById(id);

    if (!todo) {
      return {
        content: [{ type: 'text', text: JSON.stringify({ error: 'Failed to delete todo' }) }],
      };
    }

    /**
     * Benutzer k√∂nnen nur ihre eigenen Todos l√∂schen
     * Benutzer mit 'delete:todos'-Berechtigung k√∂nnen beliebige Todos l√∂schen
     */
    if (todo.ownerId !== userId && !hasRequiredScopes(authInfo?.scopes ?? [], ['delete:todos'])) {
      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify({ error: 'Failed to delete todo' }),
          },
        ],
      };
    }

    const deletedTodo = todoService.deleteTodo(id);

    return {
      content: [
        {
          type: 'text',
          text: JSON.stringify({
            message: `Todo ${id} deleted`,
            details: deletedTodo,
          }),
        },
      ],
    };
  }
);
```
</TabItem>
</Tabs>

Jetzt erstelle den "Todo-Service", der in obigem Code verwendet wird, um die zugeh√∂rige Funktionalit√§t zu implementieren:

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

Erstelle die Datei `service.py` f√ºr den Todo-Service:

```python
"""
Ein einfacher Todo-Service zu Demonstrationszwecken.
Verwendet eine In-Memory-Liste zur Speicherung der Todos.
"""

from datetime import datetime
from typing import List, Optional, Dict, Any
import random
import string

class Todo:
    """Repr√§sentiert einen Todo-Eintrag."""
    
    def __init__(self, id: str, content: str, owner_id: str, created_at: str):
        self.id = id
        self.content = content
        self.owner_id = owner_id
        self.created_at = created_at
    
    def to_dict(self) -> Dict[str, Any]:
        """Todo in ein Dictionary f√ºr JSON-Serialisierung umwandeln."""
        return {
            "id": self.id,
            "content": self.content,
            "ownerId": self.owner_id,
            "createdAt": self.created_at
        }


class TodoService:
    """Ein einfacher Todo-Service zu Demonstrationszwecken."""
    
    def __init__(self):
        self._todos: List[Todo] = []
    
    def get_all_todos(self, owner_id: Optional[str] = None) -> List[Dict[str, Any]]:
        """
        Gibt alle Todos zur√ºck, optional gefiltert nach owner_id.
        
        Args:
            owner_id: Falls angegeben, nur Todos dieses Benutzers zur√ºckgeben
            
        Returns:
            Liste von Todo-Dictionaries
        """
        if owner_id:
            filtered_todos = [todo for todo in self._todos if todo.owner_id == owner_id]
            return [todo.to_dict() for todo in filtered_todos]
        return [todo.to_dict() for todo in self._todos]
    
    def get_todo_by_id(self, todo_id: str) -> Optional[Todo]:
        """
        Gibt ein Todo anhand seiner ID zur√ºck.
        
        Args:
            todo_id: Die ID des Todos
            
        Returns:
            Todo-Objekt falls gefunden, sonst None
        """
        for todo in self._todos:
            if todo.id == todo_id:
                return todo
        return None
    
    def create_todo(self, content: str, owner_id: str) -> Dict[str, Any]:
        """
        Erstellt ein neues Todo.
        
        Args:
            content: Inhalt des Todos
            owner_id: ID des Benutzers, dem das Todo geh√∂rt
            
        Returns:
            Dictionary-Darstellung des erstellten Todos
        """
        todo = Todo(
            id=self._generate_id(),
            content=content,
            owner_id=owner_id,
            created_at=datetime.now().isoformat()
        )
        self._todos.append(todo)
        return todo.to_dict()
    
    def delete_todo(self, todo_id: str) -> Optional[Dict[str, Any]]:
        """
        L√∂scht ein Todo anhand seiner ID.
        
        Args:
            todo_id: Die ID des zu l√∂schenden Todos
            
        Returns:
            Dictionary-Darstellung des gel√∂schten Todos falls gefunden, sonst None
        """
        for i, todo in enumerate(self._todos):
            if todo.id == todo_id:
                deleted_todo = self._todos.pop(i)
                return deleted_todo.to_dict()
        return None
    
    def _generate_id(self) -> str:
        """Generiert eine zuf√§llige ID f√ºr ein Todo."""
        return ''.join(random.choices(string.ascii_lowercase + string.digits, k=8))
```

</TabItem>
<TabItem value="node" label="Node.js">

Erstelle die Datei `todo-service.ts` f√ºr den Todo-Service:

```ts
// todo-service.ts

type Todo = {
  id: string;
  content: string;
  ownerId: string;
  createdAt: string;
};

/**
 * Ein einfacher Todo-Service zu Demonstrationszwecken.
 * Verwendet ein In-Memory-Array zur Speicherung der Todos
 */
export class TodoService {
  private readonly todos: Todo[] = [];

  getAllTodos(ownerId?: string): Todo[] {
    if (ownerId) {
      return this.todos.filter((todo) => todo.ownerId === ownerId);
    }
    return this.todos;
  }

  getTodoById(id: string): Todo | undefined {
    return this.todos.find((todo) => todo.id === id);
  }

  createTodo({ content, ownerId }: { content: string; ownerId: string }): Todo {
    const todo: Todo = {
      id: this.genId(),
      content,
      ownerId,
      createdAt: new Date().toISOString(),
    };

    // eslint-disable-next-line @silverhand/fp/no-mutating-methods
    this.todos.push(todo);
    return todo;
  }

  deleteTodo(id: string): Todo | undefined {
    const index = this.todos.findIndex((todo) => todo.id === id);

    if (index === -1) {
      return undefined;
    }

    // eslint-disable-next-line @silverhand/fp/no-mutating-methods
    const [deleted] = this.todos.splice(index, 1);
    return deleted;
  }

  private genId(): string {
    return Math.random().toString(36).slice(2, 10);
  }
}
```

</TabItem>
</Tabs>

üéâ Gl√ºckwunsch! Wir haben erfolgreich einen vollst√§ndigen MCP-Server mit Authentifizierung und Autorisierung implementiert!

Du kannst auch unseren Beispielcode als Referenz ansehen:

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

:::info
Siehe das [MCP Auth Python SDK Repository](https://github.com/mcp-auth/python/tree/master/samples/current/todo-manager) f√ºr den vollst√§ndigen Code des MCP-Servers (OIDC-Version).
:::

</TabItem>
<TabItem value="node" label="Node.js">

:::info
Siehe das [MCP Auth Node.js SDK Repository](https://github.com/mcp-auth/js/blob/master/packages/sample-servers/src) f√ºr den vollst√§ndigen Code des MCP-Servers (OIDC-Version).
:::

</TabItem>
</Tabs>

## Checkpoint: Die `todo-manager`-Tools ausf√ºhren \{#checkpoint-run-the-todo-manager-tools}

Starte deinen MCP-Server neu und √∂ffne den MCP Inspector im Browser. Wenn du auf den "Connect"-Button klickst, solltest du zur Anmeldeseite deines Autorisierungsservers weitergeleitet werden.

Nach der Anmeldung und R√ºckkehr zum MCP Inspector wiederhole die Aktionen aus dem vorherigen Checkpoint, um die Todo-Manager-Tools auszuf√ºhren. Dieses Mal kannst du die Tools mit deiner authentifizierten Benutzeridentit√§t nutzen. Das Verhalten der Tools h√§ngt von den Rollen und Berechtigungen ab, die deinem Benutzer zugewiesen sind:

- Wenn du als **User** (nur mit `create:todos`-Berechtigung) angemeldet bist:

  - Du kannst neue Todos mit dem Tool `create-todo` erstellen
  - Du kannst nur deine eigenen Todos ansehen und l√∂schen
  - Du kannst keine Todos anderer Benutzer sehen oder l√∂schen

- Wenn du als **Admin** (mit allen Berechtigungen: `create:todos`, `read:todos`, `delete:todos`) angemeldet bist:
  - Du kannst neue Todos erstellen
  - Du kannst alle Todos im System mit dem Tool `get-todos` ansehen
  - Du kannst beliebige Todos mit dem Tool `delete-todo` l√∂schen, unabh√§ngig davon, wer sie erstellt hat

Du kannst diese unterschiedlichen Berechtigungsstufen testen, indem du:

1. Die aktuelle Sitzung abmeldest (klicke auf "Disconnect" im MCP Inspector)
2. Dich mit einem anderen Benutzerkonto anmeldest, das andere Rollen/Berechtigungen hat
3. Die gleichen Tools erneut ausprobierst, um zu sehen, wie sich das Verhalten je nach Benutzerberechtigungen √§ndert

Das demonstriert, wie rollenbasierte Zugangskontrolle (RBAC) in der Praxis funktioniert, wobei verschiedene Benutzer unterschiedliche Zugriffsebenen auf die Systemfunktionen haben.

![MCP Inspector Todo-Manager-Tool-Ergebnis](/docs-assets/images/tutorials/todo-manager/result.png)

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

:::info
Siehe das [MCP Auth Python SDK Repository](https://github.com/mcp-auth/python) f√ºr den vollst√§ndigen Code des MCP-Servers (OIDC-Version).
:::

</TabItem>
<TabItem value="node" label="Node.js">

:::info
Siehe das [MCP Auth Node.js SDK Repository](https://github.com/mcp-auth/js/blob/master/packages/sample-servers/src) f√ºr den vollst√§ndigen Code des MCP-Servers (OIDC-Version).
:::

</TabItem>
</Tabs>

## Abschlie√üende Hinweise \{#closing-notes}

üéä Gl√ºckwunsch! Du hast das Tutorial erfolgreich abgeschlossen. Lass uns zusammenfassen, was wir gemacht haben:

- Einen Basis-MCP-Server mit Todo-Management-Tools (`create-todo`, `get-todos`, `delete-todo`) eingerichtet
- Rollenbasierte Zugangskontrolle (RBAC) mit unterschiedlichen Berechtigungsstufen f√ºr Benutzer und Admins implementiert
- Den MCP-Server mit einem Autorisierungsserver √ºber MCP Auth integriert
- Den MCP Inspector so konfiguriert, dass Benutzer authentifiziert werden und Zugangstokens mit Berechtigungen zum Aufruf der Tools verwendet werden

Sieh dir auch andere Tutorials und die Dokumentation an, um das Beste aus MCP Auth herauszuholen.

---
sidebar_position: 1
sidebar_label: 'Tutorial: Wer bin ich?'
---

import TabItem from '@theme/TabItem';
import Tabs from '@theme/Tabs';

import SetupOauth from './_setup-oauth.mdx';
import SetupOidc from './_setup-oidc.mdx';

# Tutorial: Wer bin ich? (Who am I?)

Dieses Tutorial f√ºhrt dich durch den Prozess der Einrichtung von MCP Auth, um Benutzer zu authentifizieren und deren Identit√§tsinformationen vom Autorisierungsserver abzurufen.

Nach Abschluss dieses Tutorials hast du:

- ‚úÖ Ein grundlegendes Verst√§ndnis davon, wie du MCP Auth zur Authentifizierung von Benutzern verwendest.
- ‚úÖ Einen MCP-Server, der ein Tool zum Abrufen von Benutzeridentit√§tsinformationen bereitstellt.

## √úberblick \{#overview}

Das Tutorial umfasst die folgenden Komponenten:

- **MCP-Server**: Ein einfacher MCP-Server, der die offiziellen MCP SDKs verwendet, um Anfragen zu verarbeiten.
- **MCP Inspector**: Ein visuelles Test-Tool f√ºr MCP-Server. Es fungiert auch als OAuth / OIDC-Client, um den Autorisierungsfluss zu starten und Zugangstokens abzurufen.
- **Autorisierungsserver**: Ein OAuth 2.1- oder OpenID Connect-Anbieter, der Benutzeridentit√§ten verwaltet und Zugangstokens ausstellt.

Hier ist ein √úberblicksdiagramm der Interaktion zwischen diesen Komponenten:

```mermaid
sequenceDiagram
    participant Client as MCP Inspector
    participant Server as MCP-Server
    participant Auth as Autorisierungsserver

    Client->>Server: Tool `whoami` anfordern
    Server->>Client: 401 Nicht autorisiert zur√ºckgeben
    Client->>Auth: Autorisierungsfluss initiieren
    Auth->>Auth: Autorisierungsfluss abschlie√üen
    Auth->>Client: Mit Autorisierungscode zur√ºckleiten
    Client->>Auth: Code gegen Zugangstoken eintauschen
    Auth->>Client: Zugangstoken zur√ºckgeben
    Client->>Server: `whoami` mit Zugangstoken anfordern
    Server->>Auth: Benutzeridentit√§t mit Zugangstoken abrufen
    Auth->>Server: Benutzeridentit√§t zur√ºckgeben
    Server->>Client: Benutzeridentit√§t zur√ºckgeben
```

## Deinen Autorisierungsserver verstehen \{#understand-your-authorization-server}

### Benutzeridentit√§tsinformationen abrufen \{#retrieving-user-identity-information}

Um dieses Tutorial abzuschlie√üen, sollte dein Autorisierungsserver eine API zum Abrufen von Benutzeridentit√§tsinformationen bereitstellen:

<Tabs groupId="provider">
<TabItem value="logto" label="Logto">

[Logto](https://logto.io) ist ein OpenID Connect-Anbieter, der den Standard-[userinfo endpoint](https://openid.net/specs/openid-connect-core-1_0.html#UserInfo) unterst√ºtzt, um Benutzeridentit√§tsinformationen abzurufen.

Um ein Zugangstoken zu erhalten, das f√ºr den Zugriff auf den userinfo endpoint verwendet werden kann, sind mindestens zwei Berechtigungen (`scopes`) erforderlich: `openid` und `profile`. Du kannst weiterlesen, da wir die Berechtigungskonfiguration sp√§ter behandeln.

</TabItem>
<TabItem value="keycloak" label="Keycloak">

[Keycloak](https://www.keycloak.org) ist eine Open-Source-L√∂sung f√ºr Identit√§ts- und Zugriffsmanagement, die mehrere Protokolle unterst√ºtzt, darunter OpenID Connect (OIDC). Als OIDC-Anbieter implementiert es den Standard-[userinfo endpoint](https://openid.net/specs/openid-connect-core-1_0.html#UserInfo), um Benutzeridentit√§tsinformationen abzurufen.

Um ein Zugangstoken zu erhalten, das f√ºr den Zugriff auf den userinfo endpoint verwendet werden kann, sind mindestens zwei Berechtigungen (`scopes`) erforderlich: `openid` und `profile`. Du kannst weiterlesen, da wir die Berechtigungskonfiguration sp√§ter behandeln.

</TabItem>

<TabItem value="asgardeo" label="Asgardeo">

[Asgardeo](https://wso2.com/asgardeo) ist eine cloud-native Identity-as-a-Service (IDaaS)-Plattform, die OAuth 2.0 und OpenID Connect (OIDC) unterst√ºtzt und robustes Identit√§ts- und Zugriffsmanagement f√ºr moderne Anwendungen bietet.

Benutzerinformationen sind im ID-Token codiert, das zusammen mit dem Zugangstoken zur√ºckgegeben wird. Aber als OIDC-Anbieter stellt Asgardeo einen [UserInfo endpoint](https://wso2.com/asgardeo/docs/guides/authentication/oidc/request-user-info/) bereit, der es Anwendungen erm√∂glicht, Anspr√ºche √ºber den authentifizierten Benutzer im Payload abzurufen.

Du kannst diesen Endpunkt auch dynamisch √ºber den [OIDC discovery endpoint](https://wso2.com/asgardeo/docs/guides/authentication/oidc/discover-oidc-configs) entdecken oder indem du im Asgardeo Console zur Registerkarte 'Info' der Anwendung navigierst.

Um ein Zugangstoken zu erhalten, das f√ºr den Zugriff auf den userinfo endpoint verwendet werden kann, sind mindestens zwei Berechtigungen (`scopes`) erforderlich: `openid` und `profile`.
</TabItem>
<TabItem value="oidc" label="OIDC">

Die meisten OpenID Connect-Anbieter unterst√ºtzen den [userinfo endpoint](https://openid.net/specs/openid-connect-core-1_0.html#UserInfo), um Benutzeridentit√§tsinformationen abzurufen.

Pr√ºfe die Dokumentation deines Anbieters, ob dieser Endpunkt unterst√ºtzt wird. Wenn dein Anbieter [OpenID Connect Discovery](https://openid.net/specs/openid-connect-discovery-1_0.html) unterst√ºtzt, kannst du auch pr√ºfen, ob der `userinfo_endpoint` im Discovery-Dokument (Antwort vom `.well-known/openid-configuration`-Endpunkt) enthalten ist.

Um ein Zugangstoken zu erhalten, das f√ºr den Zugriff auf den userinfo endpoint verwendet werden kann, sind mindestens zwei Berechtigungen (`scopes`) erforderlich: `openid` und `profile`. Pr√ºfe die Dokumentation deines Anbieters, um die Zuordnung der Berechtigungen zu Benutzeridentit√§tsanspr√ºchen zu sehen.

</TabItem>
<TabItem value="oauth" label="OAuth 2">

W√§hrend OAuth 2.0 keine standardisierte Methode zum Abrufen von Benutzeridentit√§tsinformationen definiert, implementieren viele Anbieter eigene Endpunkte daf√ºr. Pr√ºfe die Dokumentation deines Anbieters, um zu erfahren, wie du Benutzeridentit√§tsinformationen mit einem Zugangstoken abrufen kannst und welche Parameter erforderlich sind, um ein solches Zugangstoken beim Aufruf des Autorisierungsflusses zu erhalten.

</TabItem>
</Tabs>

### Dynamische Client-Registrierung \{#dynamic-client-registration}

Die dynamische Client-Registrierung ist f√ºr dieses Tutorial nicht erforderlich, kann aber n√ºtzlich sein, wenn du den MCP-Client-Registrierungsprozess mit deinem Autorisierungsserver automatisieren m√∂chtest. Siehe [Ist Dynamic Client Registration erforderlich?](../../provider-list.mdx#is-dcr-required) f√ºr weitere Details.

## MCP-Server einrichten \{#set-up-the-mcp-server}

Wir verwenden die [offiziellen MCP SDKs](https://github.com/modelcontextprotocol), um einen MCP-Server mit einem `whoami`-Tool zu erstellen, das Benutzeridentit√§tsinformationen vom Autorisierungsserver abruft.

### Ein neues Projekt erstellen \{#create-a-new-project}

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

```bash
mkdir mcp-server
cd mcp-server
uv init # Oder verwende `pipenv` oder `poetry`, um eine neue virtuelle Umgebung zu erstellen
```

</TabItem>
<TabItem value="node" label="Node.js">

Richte ein neues Node.js-Projekt ein:

```bash
mkdir mcp-server
cd mcp-server
npm init -y # Oder verwende `pnpm init`
npm pkg set type="module"
npm pkg set main="whoami.js"
npm pkg set scripts.start="node whoami.js"
```

</TabItem>
</Tabs>

### MCP SDK und Abh√§ngigkeiten installieren \{#install-the-mcp-sdk-and-dependencies}

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

```bash
pip install "mcp[cli]" starlette uvicorn
```

Oder ein anderer Paketmanager deiner Wahl, wie `uv` oder `poetry`.

</TabItem>
<TabItem value="node" label="Node.js">

```bash
npm install @modelcontextprotocol/sdk express
```

Oder ein anderer Paketmanager deiner Wahl, wie `pnpm` oder `yarn`.

</TabItem>
</Tabs>

### Den MCP-Server erstellen \{#create-the-mcp-server}

Erstelle zun√§chst einen MCP-Server, der ein `whoami`-Tool implementiert.

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

Erstelle eine Datei namens `whoami.py` und f√ºge folgenden Code hinzu:

```python
from mcp.server.fastmcp import FastMCP
from starlette.applications import Starlette
from starlette.routing import Mount
from typing import Any

mcp = FastMCP("WhoAmI")

@mcp.tool()
def whoami() -> dict[str, Any]:
    """Ein Tool, das die Informationen des aktuellen Benutzers zur√ºckgibt."""
    return {"error": "Nicht authentifiziert"}

app = Starlette(
    routes=[Mount('/', app=mcp.sse_app())]
)
```

Starte den Server mit:

```bash
uvicorn whoami:app --host 0.0.0.0 --port 3001
```

</TabItem>
<TabItem value="node" label="Node.js">

:::note
Da die aktuelle MCP Inspector-Implementierung keine Autorisierungsfl√ºsse behandelt, verwenden wir den SSE-Ansatz, um den MCP-Server einzurichten. Wir aktualisieren den Code hier, sobald der MCP Inspector Autorisierungsfl√ºsse unterst√ºtzt.
:::

Du kannst auch `pnpm` oder `yarn` verwenden, wenn du m√∂chtest.

Erstelle eine Datei namens `whoami.js` und f√ºge folgenden Code hinzu:

```js
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { SSEServerTransport } from '@modelcontextprotocol/sdk/server/sse.js';
import express from 'express';

// Erstelle einen MCP-Server
const server = new McpServer({
  name: 'WhoAmI',
  version: '0.0.0',
});

// F√ºge dem Server ein Tool hinzu, das die Informationen des aktuellen Benutzers zur√ºckgibt
server.tool('whoami', async () => {
  return {
    content: [{ type: 'text', text: JSON.stringify({ error: 'Nicht authentifiziert' }) }],
  };
});

// Nachfolgend der Boilerplate-Code aus der MCP SDK-Dokumentation
const PORT = 3001;
const app = express();

const transports = {};

app.get('/sse', async (_req, res) => {
  const transport = new SSEServerTransport('/messages', res);
  transports[transport.sessionId] = transport;

  res.on('close', () => {
    delete transports[transport.sessionId];
  });

  await server.connect(transport);
});

app.post('/messages', async (req, res) => {
  const sessionId = String(req.query.sessionId);
  const transport = transports[sessionId];
  if (transport) {
    await transport.handlePostMessage(req, res, req.body);
  } else {
    res.status(400).send('Kein Transport f√ºr sessionId gefunden');
  }
});

app.listen(PORT);
```

Starte den Server mit:

```bash
npm start
```

</TabItem>
</Tabs>

## Den MCP-Server inspizieren \{#inspect-the-mcp-server}

### MCP Inspector klonen und ausf√ºhren \{#clone-and-run-mcp-inspector}

Nachdem der MCP-Server l√§uft, k√∂nnen wir den MCP Inspector verwenden, um zu sehen, ob das `whoami`-Tool verf√ºgbar ist.

Aufgrund der aktuellen Implementierung haben wir den [MCP Inspector](https://github.com/mcp-auth/inspector) geforkt, um ihn flexibler und skalierbarer f√ºr Authentifizierung und Autorisierung zu machen. Wir haben auch einen Pull Request an das Original-Repository eingereicht, um unsere √Ñnderungen einzubringen.

Um den MCP Inspector auszuf√ºhren, kannst du folgenden Befehl verwenden (Node.js wird ben√∂tigt):

```bash
git clone https://github.com/mcp-auth/inspector.git
cd inspector
npm install
npm run dev
```

√ñffne dann deinen Browser und navigiere zu `http://localhost:6274/` (oder einer anderen im Terminal angezeigten URL), um auf den MCP Inspector zuzugreifen.

### MCP Inspector mit dem MCP-Server verbinden \{#connect-mcp-inspector-to-the-mcp-server}

Bevor wir fortfahren, pr√ºfe folgende Konfiguration im MCP Inspector:

- **Transporttyp**: Setze auf `SSE`.
- **URL**: Setze auf die URL deines MCP-Servers. In unserem Fall sollte das `http://localhost:3001/sse` sein.

Jetzt kannst du auf die Schaltfl√§che "Connect" klicken, um zu sehen, ob der MCP Inspector eine Verbindung zum MCP-Server herstellen kann. Wenn alles in Ordnung ist, solltest du den Status "Connected" im MCP Inspector sehen.

### Checkpoint: Das `whoami`-Tool ausf√ºhren \{#checkpoint-run-the-whoami-tool}

1. Klicke im oberen Men√º des MCP Inspectors auf die Registerkarte "Tools".
2. Klicke auf die Schaltfl√§che "List Tools".
3. Du solltest das `whoami`-Tool auf der Seite sehen. Klicke darauf, um die Tool-Details zu √∂ffnen.
4. Du solltest auf der rechten Seite die Schaltfl√§che "Run Tool" sehen. Klicke darauf, um das Tool auszuf√ºhren.
5. Du solltest das Tool-Ergebnis mit der JSON-Antwort `{"error": "Nicht authentifiziert"}` sehen.

![MCP Inspector erster Lauf](/docs-assets/images/tutorials/whoami/inspector-first-run.png)

## Integration mit deinem Autorisierungsserver \{#integrate-with-your-authorization-server}

Um diesen Abschnitt abzuschlie√üen, sind mehrere √úberlegungen zu beachten:

<details>
<summary>**Die Issuer-URL deines Autorisierungsservers**</summary>

Dies ist in der Regel die Basis-URL deines Autorisierungsservers, z. B. `https://auth.example.com`. Einige Anbieter haben einen Pfad wie `https://example.logto.app/oidc`, pr√ºfe daher die Dokumentation deines Anbieters.

</details>

<details>
<summary>**Wie du die Metadaten des Autorisierungsservers abrufst**</summary>

- Wenn dein Autorisierungsserver dem Standard f√ºr [OAuth 2.0 Authorization Server Metadata](https://datatracker.ietf.org/doc/html/rfc8414) oder [OpenID Connect Discovery](https://openid.net/specs/openid-connect-discovery-1_0.html) entspricht, kannst du die eingebauten Utilities von MCP Auth verwenden, um die Metadaten automatisch abzurufen.
- Wenn dein Autorisierungsserver diese Standards nicht unterst√ºtzt, musst du die Metadaten-URL oder Endpunkte manuell in der MCP-Server-Konfiguration angeben. Pr√ºfe die Dokumentation deines Anbieters f√ºr die spezifischen Endpunkte.

</details>

<details>
<summary>**Wie du den MCP Inspector als Client in deinem Autorisierungsserver registrierst**</summary>

- Wenn dein Autorisierungsserver [Dynamic Client Registration](https://datatracker.ietf.org/doc/html/rfc7591) unterst√ºtzt, kannst du diesen Schritt √ºberspringen, da sich der MCP Inspector automatisch als Client registriert.
- Wenn dein Autorisierungsserver keine Dynamic Client Registration unterst√ºtzt, musst du den MCP Inspector manuell als Client in deinem Autorisierungsserver registrieren.

</details>

<details>
<summary>**Wie du Benutzeridentit√§tsinformationen abrufst und wie du die Parameter der Autorisierungsanfrage konfigurierst**</summary>

- F√ºr OpenID Connect-Anbieter: In der Regel musst du beim Starten des Autorisierungsflusses mindestens die Berechtigungen `openid` und `profile` anfordern. Dadurch wird sichergestellt, dass das vom Autorisierungsserver zur√ºckgegebene Zugangstoken die notwendigen Berechtigungen enth√§lt, um auf den [userinfo endpoint](https://openid.net/specs/openid-connect-core-1_0.html#UserInfo) zuzugreifen und Benutzeridentit√§tsinformationen abzurufen.

  Hinweis: Einige Anbieter unterst√ºtzen den userinfo endpoint m√∂glicherweise nicht.

- F√ºr OAuth 2.0 / OAuth 2.1-Anbieter: Pr√ºfe die Dokumentation deines Anbieters, um zu erfahren, wie du Benutzeridentit√§tsinformationen mit einem Zugangstoken abrufen kannst und welche Parameter erforderlich sind, um ein solches Zugangstoken beim Aufruf des Autorisierungsflusses zu erhalten.

</details>

Auch wenn jeder Anbieter eigene Anforderungen hat, f√ºhren dich die folgenden Schritte durch den Prozess der Integration von MCP Inspector und MCP-Server mit anbieter-spezifischen Konfigurationen.

### MCP Inspector als Client registrieren \{#register-mcp-inspector-as-a-client}

<Tabs groupId="provider">
<TabItem value="logto" label="Logto">

Die Integration mit [Logto](https://logto.io) ist unkompliziert, da es ein OpenID Connect-Anbieter ist, der den Standard-[userinfo endpoint](https://openid.net/specs/openid-connect-core-1_0.html#UserInfo) unterst√ºtzt, um Benutzeridentit√§tsinformationen abzurufen.

Da Logto derzeit keine Dynamic Client Registration unterst√ºtzt, musst du den MCP Inspector manuell als Client in deinem Logto-Tenant registrieren:

1. √ñffne deinen MCP Inspector, klicke auf die Schaltfl√§che "OAuth Configuration". Kopiere den **Redirect URL (auto-populated)**-Wert, der etwa so aussieht: `http://localhost:6274/oauth/callback`.
2. Melde dich bei der [Logto Console](https://cloud.logto.io) (oder deiner selbst gehosteten Logto Console) an.
3. Navigiere zum Tab "Applications", klicke auf "Create application". Klicke unten auf der Seite auf "Create app without framework".
4. F√ºlle die Anwendungsdetails aus und klicke dann auf "Create application":
   - **W√§hle einen Anwendungstyp**: W√§hle "Single-page application".
   - **Anwendungsname**: Gib einen Namen f√ºr deine Anwendung ein, z. B. "MCP Inspector".
5. Im Abschnitt "Settings / Redirect URIs" f√ºge den zuvor kopierten **Redirect URL (auto-populated)**-Wert ein. Klicke dann unten auf "Save changes".
6. Im oberen Bereich siehst du den Wert "App ID". Kopiere ihn.
7. Gehe zur√ºck zum MCP Inspector und f√ºge den "App ID"-Wert im Abschnitt "OAuth Configuration" unter "Client ID" ein.
8. Gib den Wert `{"scope": "openid profile email"}` im Feld "Auth Params" ein. Dadurch wird sichergestellt, dass das von Logto zur√ºckgegebene Zugangstoken die notwendigen Berechtigungen f√ºr den Zugriff auf den userinfo endpoint enth√§lt.

</TabItem>
<TabItem value="keycloak" label="Keycloak">

[Keycloak](https://www.keycloak.org) ist eine Open-Source-L√∂sung f√ºr Identit√§ts- und Zugriffsmanagement, die das OpenID Connect-Protokoll unterst√ºtzt.

Obwohl Keycloak die dynamische Client-Registrierung unterst√ºtzt, unterst√ºtzt sein Client-Registrierungsendpunkt kein CORS, was die direkte Registrierung der meisten MCP-Clients verhindert. Daher m√ºssen wir unseren Client manuell registrieren.

:::note
Obwohl Keycloak auf [verschiedene Arten](https://www.keycloak.org/guides#getting-started) (Bare Metal, Kubernetes, usw.) installiert werden kann, verwenden wir f√ºr dieses Tutorial Docker f√ºr eine schnelle und unkomplizierte Einrichtung.
:::

So richtest du eine Keycloak-Instanz ein und konfigurierst sie f√ºr unsere Zwecke:

1. Starte eine Keycloak-Instanz mit Docker gem√§√ü der [offiziellen Dokumentation](https://www.keycloak.org/getting-started/getting-started-docker):

```bash
docker run -p 8080:8080 -e KC_BOOTSTRAP_ADMIN_USERNAME=admin -e KC_BOOTSTRAP_ADMIN_PASSWORD=admin quay.io/keycloak/keycloak:26.2.4 start-dev
```

2. Greife auf die Keycloak Admin Console zu (http://localhost:8080/admin) und melde dich mit diesen Zugangsdaten an:

   - Benutzername: `admin`
   - Passwort: `admin`

3. Erstelle ein neues Realm:

   - Klicke oben links auf "Create Realm"
   - Gib `mcp-realm` im Feld "Realm name" ein
   - Klicke auf "Create"

4. Erstelle einen Testbenutzer:

   - Klicke im linken Men√º auf "Users"
   - Klicke auf "Create new user"
   - F√ºlle die Benutzerdetails aus:
     - Benutzername: `testuser`
     - Vorname und Nachname k√∂nnen beliebig sein
   - Klicke auf "Create"
   - Setze im Tab "Credentials" ein Passwort und deaktiviere "Temporary"

5. Registriere den MCP Inspector als Client:

   - √ñffne deinen MCP Inspector, klicke auf die Schaltfl√§che "OAuth Configuration". Kopiere den **Redirect URL (auto-populated)**-Wert, z. B. `http://localhost:6274/oauth/callback`.
   - In der Keycloak Admin Console, klicke im linken Men√º auf "Clients"
   - Klicke auf "Create client"
   - F√ºlle die Client-Details aus:
     - Client-Typ: W√§hle "OpenID Connect"
     - Client ID: Gib `mcp-inspector` ein
     - Klicke auf "Next"
   - Auf der Seite "Capability config":
     - Stelle sicher, dass "Standard flow" aktiviert ist
     - Klicke auf "Next"
   - Auf der Seite "Login settings":
     - F√ºge die zuvor kopierte MCP Inspector Callback-URL in "Valid redirect URIs" ein
     - Gib `http://localhost:6274` bei "Web origins" ein
     - Klicke auf "Save"
   - Kopiere die "Client ID" (das ist `mcp-inspector`)

6. Zur√ºck im MCP Inspector:
   - F√ºge die kopierte Client ID in das Feld "Client ID" im Abschnitt "OAuth Configuration" ein
   - Gib folgenden Wert im Feld "Auth Params" ein, um die notwendigen Berechtigungen anzufordern:

```json
{ "scope": "openid profile email" }
```

 </TabItem>
<TabItem value="asgardeo" label="Asgardeo">

Obwohl Asgardeo die dynamische Client-Registrierung √ºber eine Standard-API unterst√ºtzt, ist der Endpunkt gesch√ºtzt und erfordert ein Zugangstoken mit den notwendigen Berechtigungen. In diesem Tutorial registrieren wir den Client manuell √ºber die Asgardeo Console.

:::note
Wenn du noch kein Asgardeo-Konto hast, kannst du dich [kostenlos registrieren](https://asgardeo.io).
:::

Folge diesen Schritten, um Asgardeo f√ºr den MCP Inspector zu konfigurieren:

1. Melde dich in der [Asgardeo Console](https://console.asgardeo.io) an und w√§hle deine Organisation aus.

2. Erstelle eine neue Anwendung:
    - Gehe zu **Applications** ‚Üí **New Application**
    - W√§hle **Single-Page Application**
    - Gib einen Anwendungsnamen wie `MCP Inspector` ein
    - Im Feld **Authorized Redirect URLs** f√ºge die **Redirect URL** ein, die du aus der MCP Inspector Client-Anwendung kopiert hast (z. B.: `http://localhost:6274/oauth/callback`)
    - Klicke auf **Create**

3. Konfiguriere die Protokolleinstellungen:
    - Unter dem Tab **Protocol**:
    - Kopiere die automatisch generierte **Client ID**
    - Stelle sicher, dass du auf `JWT` f√ºr den `Token Type` im Abschnitt **Access Token** umstellst
    - Klicke auf **Update**

4. In der MCP Inspector Client-Anwendung:
    - √ñffne den Abschnitt **OAuth Configuration**
    - F√ºge die kopierte **Client ID** ein
    - Gib Folgendes im Feld **Auth Params** ein, um die notwendigen Berechtigungen anzufordern:

```json
{ "scope": "openid profile email" }
```
 </TabItem>
<TabItem value="oidc" label="OIDC">

:::note
Dies ist eine generische Anleitung zur Integration eines OpenID Connect-Anbieters. Pr√ºfe die Dokumentation deines Anbieters f√ºr spezifische Details.
:::

Wenn dein OpenID Connect-Anbieter Dynamic Client Registration unterst√ºtzt, kannst du direkt zu Schritt 8 unten gehen, um den MCP Inspector zu konfigurieren; andernfalls musst du den MCP Inspector manuell als Client in deinem OpenID Connect-Anbieter registrieren:

1. √ñffne deinen MCP Inspector, klicke auf die Schaltfl√§che "OAuth Configuration". Kopiere den **Redirect URL (auto-populated)**-Wert, z. B. `http://localhost:6274/oauth/callback`.
2. Melde dich in der Konsole deines OpenID Connect-Anbieters an.
3. Navigiere zum Abschnitt "Applications" oder "Clients" und erstelle eine neue Anwendung oder einen neuen Client.
4. Wenn dein Anbieter einen Client-Typ verlangt, w√§hle "Single-page application" oder "Public client".
5. Nach dem Erstellen der Anwendung musst du die Redirect URI konfigurieren. F√ºge den zuvor kopierten **Redirect URL (auto-populated)**-Wert ein.
6. Finde die "Client ID" oder "Application ID" der neu erstellten Anwendung und kopiere sie.
7. Gehe zur√ºck zum MCP Inspector und f√ºge die "Client ID" im Abschnitt "OAuth Configuration" unter "Client ID" ein.
8. F√ºr Standard-OpenID-Connect-Anbieter kannst du folgenden Wert im Feld "Auth Params" eingeben, um die notwendigen Berechtigungen f√ºr den Zugriff auf den userinfo endpoint anzufordern:

```json
{ "scope": "openid profile email" }
```

</TabItem>
<TabItem value="oauth" label="OAuth 2">

:::note
Dies ist eine generische Anleitung zur Integration eines OAuth 2.0 / OAuth 2.1-Anbieters. Pr√ºfe die Dokumentation deines Anbieters f√ºr spezifische Details.
:::

Wenn dein OAuth 2.0 / OAuth 2.1-Anbieter Dynamic Client Registration unterst√ºtzt, kannst du direkt zu Schritt 8 unten gehen, um den MCP Inspector zu konfigurieren; andernfalls musst du den MCP Inspector manuell als Client in deinem OAuth 2.0 / OAuth 2.1-Anbieter registrieren:

1. √ñffne deinen MCP Inspector, klicke auf die Schaltfl√§che "OAuth Configuration". Kopiere den **Redirect URL (auto-populated)**-Wert, z. B. `http://localhost:6274/oauth/callback`.
2. Melde dich in der Konsole deines OAuth 2.0 / OAuth 2.1-Anbieters an.
3. Navigiere zum Abschnitt "Applications" oder "Clients" und erstelle eine neue Anwendung oder einen neuen Client.
4. Wenn dein Anbieter einen Client-Typ verlangt, w√§hle "Single-page application" oder "Public client".
5. Nach dem Erstellen der Anwendung musst du die Redirect URI konfigurieren. F√ºge den zuvor kopierten **Redirect URL (auto-populated)**-Wert ein.
6. Finde die "Client ID" oder "Application ID" der neu erstellten Anwendung und kopiere sie.
7. Gehe zur√ºck zum MCP Inspector und f√ºge die "Client ID" im Abschnitt "OAuth Configuration" unter "Client ID" ein.
8. Lies die Dokumentation deines Anbieters, um zu erfahren, wie du Zugangstokens f√ºr Benutzeridentit√§tsinformationen abrufst. M√∂glicherweise musst du die Berechtigungen oder Parameter angeben, die f√ºr das Abrufen des Zugangstokens erforderlich sind. Wenn dein Anbieter z. B. die Berechtigung `profile` f√ºr den Zugriff auf Benutzeridentit√§tsinformationen verlangt, kannst du folgenden Wert im Feld "Auth Params" eingeben:

```json
{ "scope": "profile" }
```

</TabItem>
</Tabs>

### MCP Auth einrichten \{#set-up-mcp-auth}

In deinem MCP-Server-Projekt musst du das MCP Auth SDK installieren und so konfigurieren, dass es die Metadaten deines Autorisierungsservers verwendet.

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

Installiere zun√§chst das `mcpauth`-Paket:

```bash
pip install mcpauth
```

Oder ein anderer Paketmanager deiner Wahl, wie `uv` oder `poetry`.

</TabItem>
<TabItem value="node" label="Node.js">

Installiere zun√§chst das `mcp-auth`-Paket:

```bash
npm install mcp-auth
```

</TabItem>
</Tabs>

MCP Auth ben√∂tigt die Metadaten des Autorisierungsservers, um initialisiert werden zu k√∂nnen. Je nach Anbieter:

<Tabs groupId="provider">

<TabItem value="logto" label="Logto">

Die Issuer-URL findest du auf der Anwendungsdetailseite in der Logto Console im Abschnitt "Endpoints & Credentials / Issuer endpoint". Sie sollte etwa so aussehen: `https://my-project.logto.app/oidc`.

<SetupOidc />

</TabItem>

<TabItem value="keycloak" label="Keycloak">

Die Issuer-URL findest du in der Keycloak Admin Console. In deinem 'mcp-realm' navigiere zum Abschnitt "Realm settings / Endpoints" und klicke auf den Link "OpenID Endpoint Configuration". Das Feld `issuer` im JSON-Dokument enth√§lt deine Issuer-URL, die etwa so aussieht: `http://localhost:8080/realms/mcp-realm`.

<SetupOidc />

</TabItem>

<TabItem value="asgardeo" label="Asgardeo">

    Die Issuer-URL findest du in der Asgardeo Console. Navigiere zur erstellten Anwendung und √∂ffne den Tab **Info**. Das Feld **Issuer** wird dort angezeigt und sollte wie folgt aussehen:
    `https://api.asgardeo.io/t/<your-organization-name>/oauth2/token`
    
    <SetupOidc />

</TabItem>

<TabItem value="oidc" label="OIDC">

Der folgende Code geht davon aus, dass der Autorisierungsserver den [userinfo endpoint](https://openid.net/specs/openid-connect-core-1_0.html#UserInfo) unterst√ºtzt, um Benutzeridentit√§tsinformationen abzurufen. Wenn dein Anbieter diesen Endpunkt nicht unterst√ºtzt, pr√ºfe die Dokumentation deines Anbieters f√ºr den spezifischen Endpunkt und ersetze die userinfo endpoint-Variable durch die korrekte URL.

<SetupOidc showAlternative />

</TabItem>
<TabItem value="oauth" label="OAuth 2">

Wie bereits erw√§hnt, definiert OAuth 2.0 keine standardisierte Methode zum Abrufen von Benutzeridentit√§tsinformationen. Der folgende Code geht davon aus, dass dein Anbieter einen spezifischen Endpunkt zum Abrufen von Benutzeridentit√§tsinformationen mit einem Zugangstoken bereitstellt. Pr√ºfe die Dokumentation deines Anbieters f√ºr den spezifischen Endpunkt und ersetze die userinfo endpoint-Variable durch die korrekte URL.

<SetupOauth />

</TabItem>
</Tabs>

### MCP-Server aktualisieren \{#update-mcp-server}

Wir sind fast fertig! Jetzt ist es an der Zeit, den MCP-Server zu aktualisieren, um die MCP Auth-Route und Middleware-Funktion anzuwenden und das `whoami`-Tool so zu gestalten, dass es die tats√§chlichen Benutzeridentit√§tsinformationen zur√ºckgibt.

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

```python
@mcp.tool()
def whoami() -> dict[str, Any]:
    """Ein Tool, das die Informationen des aktuellen Benutzers zur√ºckgibt."""
    return (
        mcp_auth.auth_info.claims
        if mcp_auth.auth_info # Dies wird von der Bearer-Auth-Middleware bef√ºllt
        else {"error": "Nicht authentifiziert"}
    )

# ...

bearer_auth = Middleware(mcp_auth.bearer_auth_middleware(verify_access_token))
app = Starlette(
    routes=[
        # F√ºge die Metadaten-Route hinzu (`/.well-known/oauth-authorization-server`)
        mcp_auth.metadata_route(),
        # Sch√ºtze den MCP-Server mit der Bearer-Auth-Middleware
        Mount('/', app=mcp.sse_app(), middleware=[bearer_auth]),
    ],
)
```

</TabItem>
<TabItem value="node" label="Node.js">

```js
server.tool('whoami', ({ authInfo }) => {
  return {
    content: [
      { type: 'text', text: JSON.stringify(authInfo?.claims ?? { error: 'Nicht authentifiziert' }) },
    ],
  };
});

// ...

app.use(mcpAuth.delegatedRouter());
app.use(mcpAuth.bearerAuth(verifyToken));
```

</TabItem>
</Tabs>

## Checkpoint: Das `whoami`-Tool mit Authentifizierung ausf√ºhren \{#checkpoint-run-the-whoami-tool-with-authentication}

Starte deinen MCP-Server neu und √∂ffne den MCP Inspector in deinem Browser. Wenn du auf die Schaltfl√§che "Connect" klickst, solltest du zur Anmeldeseite deines Autorisierungsservers weitergeleitet werden.

Nachdem du dich angemeldet hast und zum MCP Inspector zur√ºckgekehrt bist, wiederhole die Schritte aus dem vorherigen Checkpoint, um das `whoami`-Tool auszuf√ºhren. Dieses Mal solltest du die vom Autorisierungsserver zur√ºckgegebenen Benutzeridentit√§tsinformationen sehen.

![MCP Inspector whoami Tool Ergebnis](/docs-assets/images/tutorials/whoami/result.png)

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

:::info
Sieh dir das [MCP Auth Python SDK Repository](https://github.com/mcp-auth/python/blob/master/samples/server/whoami.py) f√ºr den vollst√§ndigen Code des MCP-Servers (OIDC-Version) an.
:::

</TabItem>
<TabItem value="node" label="Node.js">

:::info
Sieh dir das [MCP Auth Node.js SDK Repository](https://github.com/mcp-auth/js/blob/master/packages/sample-servers/src) f√ºr den vollst√§ndigen Code des MCP-Servers (OIDC-Version) an. Dieses Verzeichnis enth√§lt sowohl TypeScript- als auch JavaScript-Versionen des Codes.
:::

</TabItem>
</Tabs>

## Abschlie√üende Hinweise \{#closing-notes}

üéä Gl√ºckwunsch! Du hast das Tutorial erfolgreich abgeschlossen. Lass uns zusammenfassen, was wir gemacht haben:

- Einen grundlegenden MCP-Server mit dem `whoami`-Tool eingerichtet
- Den MCP-Server mit einem Autorisierungsserver √ºber MCP Auth integriert
- Den MCP Inspector so konfiguriert, dass Benutzer authentifiziert und deren Identit√§tsinformationen abgerufen werden

Du kannst auch einige fortgeschrittene Themen erkunden, darunter:

- Die Verwendung von [JWT (JSON Web Token)](https://auth.wiki/jwt) f√ºr Authentifizierung und Autorisierung
- Die Nutzung von [Ressourcenindikatoren (RFC 8707)](https://auth-wiki.logto.io/resource-indicator), um die zuzugreifenden Ressourcen anzugeben
- Die Implementierung eigener Zugangskontrollmechanismen, wie [rollenbasierte Zugangskontrolle (RBAC)](https://auth.wiki/rbac) oder [attributbasierte Zugangskontrolle (ABAC)](https://auth.wiki/abac)

Sieh dir unbedingt weitere Tutorials und die Dokumentation an, um das Beste aus MCP Auth herauszuholen.

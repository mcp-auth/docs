---
sidebar_position: 1
sidebar_label: MCP Auth
---

import TabItem from '@theme/TabItem';
import Tabs from '@theme/Tabs';

# Configura MCP Auth en el servidor MCP

Con la última [Especificación MCP (2025-06-18)](https://modelcontextprotocol.io/specification/2025-06-18), tu servidor MCP actúa como un **Servidor de Recursos** que valida los tokens de acceso emitidos por servidores de autorización externos.

Para configurar MCP Auth, necesitas dos pasos principales:
1. **Configurar los metadatos del servidor de autorización** - Define qué servidores de autorización pueden emitir tokens válidos para tu servidor MCP y guía a los clientes MCP sobre dónde obtener tokens de acceso
2. **Configurar los metadatos del recurso protegido** - Define tu servidor MCP como un recurso protegido con los alcances soportados

## Paso 1: Configura los metadatos del servidor de autorización \{#configure-authorization-server-metadata}

### Obtención automática de metadatos \{#automatic-metadata-fetching}

La forma más sencilla de configurar los metadatos del servidor de autorización es utilizando las funciones integradas que obtienen los metadatos desde URLs bien conocidas. Si tu proveedor cumple con uno de los siguientes estándares:

- [Metadatos del servidor de autorización OAuth 2.0](https://datatracker.ietf.org/doc/html/rfc8414)
- [Descubrimiento de OpenID Connect](https://openid.net/specs/openid-connect-discovery-1_0.html)

Puedes usar `fetchServerConfig` para recuperar automáticamente los metadatos proporcionando la URL del `issuer`:

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

```python
from mcpauth.config import AuthServerType
from mcpauth.utils import fetch_server_config

# Obtener los metadatos del servidor de autorización
auth_server_config = fetch_server_config(
    "https://auth.logto.io/oidc",
    AuthServerType.OIDC  # o AuthServerType.OAUTH
)
```

</TabItem>
<TabItem value="node" label="Node.js">

```ts
import { fetchServerConfig } from 'mcp-auth';

// Obtener los metadatos del servidor de autorización
const authServerConfig = await fetchServerConfig('https://auth.logto.io/oidc', { type: 'oidc' }); // o 'oauth'
```

</TabItem>
</Tabs>

Si tu issuer incluye una ruta, el comportamiento difiere ligeramente entre OAuth 2.0 y OpenID Connect:

- **OAuth 2.0**: La URL bien conocida se añade al **dominio** del issuer. Por ejemplo, si tu issuer es `https://my-project.logto.app/oauth`, la URL bien conocida será `https://auth.logto.io/.well-known/oauth-authorization-server/oauth`.
- **OpenID Connect**: La URL bien conocida se añade directamente al **issuer**. Por ejemplo, si tu issuer es `https://my-project.logto.app/oidc`, la URL bien conocida será `https://auth.logto.io/oidc/.well-known/openid-configuration`.

### Otras formas de configurar los metadatos del servidor de autorización \{#other-ways}

#### Transpilación personalizada de datos \{#custom-data-transpilation}

En algunos casos, los metadatos devueltos por el proveedor pueden no ajustarse al formato esperado. Si estás seguro de que el proveedor es compatible, puedes usar la opción `transpile_data` para modificar los metadatos antes de que se utilicen:

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

```python
from mcpauth.config import AuthServerType
from mcpauth.utils import fetch_server_config

auth_server_config = fetch_server_config(
    '<auth-server-url>',
    type=AuthServerType.OIDC,
    transpile_data=lambda data: {**data, 'response_types_supported': ['code']} # [!code highlight]
)
```

</TabItem>
<TabItem value="node" label="Node.js">

```ts
import { fetchServerConfig } from 'mcp-auth';

const authServerConfig = await fetchServerConfig('<auth-server-issuer>', {
  type: 'oidc',
  transpileData: (data) => ({ ...data, response_types_supported: ['code'] }), // [!code highlight]
});
```

</TabItem>
</Tabs>

Esto te permite modificar el objeto de metadatos antes de que sea utilizado por MCP Auth. Por ejemplo, puedes añadir o eliminar campos, cambiar sus valores o convertirlos a un formato diferente.

#### Obtener metadatos desde una URL específica \{#fetch-metadata-from-a-specific-url}

Si tu proveedor tiene una URL de metadatos específica en lugar de las estándar, puedes usarla de manera similar:

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

```python
from mcpauth.config import AuthServerType
from mcpauth.utils import fetch_server_config_by_well_known_url

auth_server_config = fetch_server_config_by_well_known_url(
    '<metadata-url>',
    type=AuthServerType.OIDC # o AuthServerType.OAUTH
)
```

</TabItem>
<TabItem value="node" label="Node.js">

```ts
import { fetchServerConfigByWellKnownUrl } from 'mcp-auth';

const authServerConfig = await fetchServerConfigByWellKnownUrl('<metadata-url>', { type: 'oidc' }); // o 'oauth'
```

</TabItem>
</Tabs>

#### Obtener metadatos desde una URL específica con transpilación personalizada de datos \{#fetch-metadata-from-a-specific-url-with-custom-data-transpilation}

En algunos casos, la respuesta del proveedor puede estar malformada o no ajustarse al formato de metadatos esperado. Si estás seguro de que el proveedor es compatible, puedes transpilar los metadatos mediante la opción de configuración:

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

```python
from mcpauth.config import AuthServerType, fetch_server_config_by_well_known_url

auth_server_config = fetch_server_config_by_well_known_url(
    '<metadata-url>',
    type=AuthServerType.OIDC,
    transpile_data=lambda data: {**data, 'response_types_supported': ['code']} # [!code highlight]
)
```

</TabItem>
<TabItem value="node" label="Node.js">

```ts
const authServerConfig = await fetchServerConfigByWellKnownUrl('<metadata-url>', {
  type: 'oidc',
  transpileData: (data) => ({ ...data, response_types_supported: ['code'] }), // [!code highlight]
});
```

</TabItem>
</Tabs>

#### Proporcionar manualmente los metadatos \{#manually-provide-metadata}

Si tu proveedor no admite la obtención de metadatos, puedes proporcionar manualmente el objeto de metadatos:

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

```python
from mcpauth.config import AuthServerConfig, AuthServerType, AuthorizationServerMetadata

auth_server_config = AuthServerConfig(
    type=AuthServerType.OIDC,  # o AuthServerType.OAUTH
    metadata=AuthorizationServerMetadata(
        issuer='<issuer-url>',
        authorization_endpoint='<authorization-endpoint-url>',
        # ... otros campos de metadatos
    ),
)
```

</TabItem>
<TabItem value="node" label="Node.js">

```ts
const authServerConfig = {
  metadata: {
    issuer: '<issuer-url>',
    // Los campos de metadatos deben estar en camelCase
    authorizationEndpoint: '<authorization-endpoint-url>',
    // ... otros campos de metadatos
  },
  type: 'oidc', // o 'oauth'
};
```

</TabItem>
</Tabs>

## Paso 2: Configura los metadatos del recurso protegido \{#configure-protected-resource-metadata}

Después de configurar los metadatos del servidor de autorización, necesitas inicializar MCPAuth como un Servidor de Recursos definiendo los metadatos de tus recursos protegidos.

Este paso sigue la especificación [RFC 9728 (Metadatos de recursos protegidos OAuth 2.0)](https://datatracker.ietf.org/doc/html/rfc9728) para describir tu servidor MCP como un recurso protegido:

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

```python
from mcpauth import MCPAuth
from mcpauth.config import ResourceServerConfig, ResourceServerMetadata

# Define tu identificador de recurso
resource_id = "https://api.example.com/notes"

# Inicializa MCPAuth en modo servidor de recursos
mcp_auth = MCPAuth(
    protected_resources=ResourceServerConfig(
        metadata=ResourceServerMetadata(
            resource=resource_id,
            authorization_servers=[auth_server_config],  # Usando la configuración del Paso 1
            scopes_supported=[
                "read:notes",
                "write:notes",
            ],
        )
    )
)
```

</TabItem>
<TabItem value="node" label="Node.js">

```ts
import { MCPAuth } from 'mcp-auth';

// Define tu identificador de recurso
const resourceIdentifier = 'https://api.example.com/notes';

// Inicializa MCPAuth en modo servidor de recursos
const mcpAuth = new MCPAuth({
  protectedResources: [
    {
      metadata: {
        resource: resourceIdentifier,
        authorizationServers: [authServerConfig], // Usando la configuración del Paso 1
        scopesSupported: ['read:notes', 'write:notes'],
      },
    },
  ],
});
```

</TabItem>
</Tabs>

Para múltiples recursos, puedes proporcionar un array de recursos protegidos, cada uno con su propia configuración de metadatos.

La configuración mostrada arriba cubre la configuración básica. Para parámetros de metadatos más avanzados, consulta la [RFC 9728](https://datatracker.ietf.org/doc/html/rfc9728#name-protected-resource-metadata).

## Paso 3: Monta el endpoint de metadatos del recurso protegido \{#mount-the-protected-resource-metadata-endpoint}

Monta el router para servir el endpoint de metadatos del recurso protegido. La ruta del endpoint se determina automáticamente por el componente de ruta de tu identificador de recurso:

- **Sin ruta**: `https://api.example.com` → `/.well-known/oauth-protected-resource`
- **Con ruta**: `https://api.example.com/notes` → `/.well-known/oauth-protected-resource/notes`

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

```python
from starlette.applications import Starlette
from mcpauth import MCPAuth

mcp_auth = MCPAuth({/* ... */})

app = Starlette(routes=[
    *mcp_auth.resource_metadata_router().routes,
])
```

</TabItem>
<TabItem value="node" label="Node.js">

```ts
import express from 'express';

const app = express();

const mcpAuth = new MCPAuth({/* ... */});

app.use(mcpAuth.protectedResourceMetadataRouter());
```

</TabItem>
</Tabs>
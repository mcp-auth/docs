---
sidebar_position: 2
sidebar_label: 'Tutoriel : Cr√©er un gestionnaire de t√¢ches'
---

import TabItem from '@theme/TabItem';
import Tabs from '@theme/Tabs';

import SetupOauthOrOidc from './_setup-oauth-or-oidc.mdx';
import SetupOidc from './_setup-oidc.mdx';

# Tutoriel : Cr√©er un gestionnaire de t√¢ches

Dans ce tutoriel, nous allons construire un serveur MCP de gestionnaire de t√¢ches avec authentification et autorisation des utilisateurs.

Apr√®s avoir termin√© ce tutoriel, vous aurez :

- ‚úÖ Une compr√©hension de base de la configuration du contr√¥le d‚Äôacc√®s bas√© sur les r√¥les (RBAC) dans votre serveur MCP.
- ‚úÖ Un serveur MCP capable de g√©rer des listes de t√¢ches personnelles.

:::note
Avant de commencer, nous vous recommandons fortement de suivre d'abord le [tutoriel Who am I](./whoami) si vous n'√™tes pas familier avec le serveur MCP et OAuth 2.
:::

## Aper√ßu \{#overview}

Le tutoriel impliquera les composants suivants :

- **Serveur MCP** : Un serveur MCP simple qui utilise les SDK officiels MCP pour g√©rer les requ√™tes, avec un service Todo int√©gr√© pour g√©rer les t√¢ches de l'utilisateur.
- **Inspecteur MCP** : Un outil de test visuel pour les serveurs MCP. Il agit √©galement comme un client OAuth / OIDC pour initier le flux d‚Äôautorisation et r√©cup√©rer les jetons d‚Äôacc√®s.
- **Serveur d‚Äôautorisation** : Un fournisseur OAuth 2.1 ou OpenID Connect qui g√®re les identit√©s des utilisateurs et d√©livre les jetons d‚Äôacc√®s.

Voici un sch√©ma de haut niveau de l‚Äôinteraction entre ces composants :

```mermaid
sequenceDiagram
    participant Client as Inspecteur MCP
    participant Server as Serveur MCP
    participant Auth as Serveur d‚Äôautorisation

    Client->>Server: Demander une op√©ration todo
    Server->>Client: Retourner 401 Non autoris√©
    Client->>Auth: Initier le flux d‚Äôautorisation
    Auth->>Auth: Compl√©ter le flux d‚Äôautorisation
    Auth->>Client: Rediriger avec le code d‚Äôautorisation
    Client->>Auth: √âchanger le code contre un jeton d‚Äôacc√®s
    Auth->>Client: Retourner le jeton d‚Äôacc√®s
    Client->>Server: Demander une op√©ration todo avec le jeton d‚Äôacc√®s
    Server->>Server: Valider le jeton d‚Äôacc√®s et obtenir les port√©es utilisateur depuis le jeton d‚Äôacc√®s
    Note over Server: Ex√©cuter l‚Äôop√©ration todo
    Server->>Client: Retourner le r√©sultat de l‚Äôop√©ration todo
```

## Comprendre votre serveur d‚Äôautorisation \{#understand-your-authorization-server}

### Jetons d‚Äôacc√®s avec port√©es \{#access-tokens-with-scopes}

Pour mettre en ≈ìuvre le [contr√¥le d‚Äôacc√®s bas√© sur les r√¥les (RBAC)](https://auth.wiki/rbac) dans votre serveur MCP, votre serveur d‚Äôautorisation doit prendre en charge l‚Äô√©mission de jetons d‚Äôacc√®s avec des port√©es. Les port√©es repr√©sentent les permissions accord√©es √† un utilisateur.

<Tabs groupId="provider">
<TabItem value="logto" label="Logto">

[Logto](https://logto.io) fournit la prise en charge du RBAC via ses ressources API (conformes √† [RFC 8707 : Indicateurs de ressource pour OAuth 2.0](https://datatracker.ietf.org/doc/html/rfc8707)) et ses fonctionnalit√©s de r√¥les. Voici comment le configurer :

1. Connectez-vous √† [Logto Console](https://cloud.logto.io) (ou √† votre propre instance Logto Console)

2. Cr√©ez une ressource API et des port√©es :

   - Allez dans "Ressources API"
   - Cr√©ez une nouvelle ressource API nomm√©e "Todo Manager"
   - Ajoutez les port√©es suivantes :
     - `create:todos` : "Cr√©er de nouvelles t√¢ches"
     - `read:todos` : "Lire toutes les t√¢ches"
     - `delete:todos` : "Supprimer n‚Äôimporte quelle t√¢che"

3. Cr√©ez des r√¥les (recommand√© pour une gestion plus simple) :

   - Allez dans "R√¥les"
   - Cr√©ez un r√¥le "Admin" et assignez toutes les port√©es (`create:todos`, `read:todos`, `delete:todos`)
   - Cr√©ez un r√¥le "User" et assignez uniquement la port√©e `create:todos`

4. Assignez les permissions :
   - Allez dans "Utilisateurs"
   - S√©lectionnez un utilisateur
   - Vous pouvez soit :
     - Assigner des r√¥les dans l‚Äôonglet "R√¥les" (recommand√©)
     - Ou assigner directement des port√©es dans l‚Äôonglet "Permissions"

Les port√©es seront incluses dans la revendication `scope` du jeton d‚Äôacc√®s JWT sous forme de cha√Æne s√©par√©e par des espaces.

</TabItem>
<TabItem value="oauth-oidc" label="OAuth 2.0 / OIDC">

Les fournisseurs OAuth 2.0 / OIDC prennent g√©n√©ralement en charge le contr√¥le d‚Äôacc√®s bas√© sur les port√©es. Lors de la mise en ≈ìuvre du RBAC :

1. D√©finissez les port√©es requises dans votre serveur d‚Äôautorisation
2. Configurez votre client pour demander ces port√©es lors du flux d‚Äôautorisation
3. Assurez-vous que votre serveur d‚Äôautorisation inclut les port√©es accord√©es dans le jeton d‚Äôacc√®s
4. Les port√©es sont g√©n√©ralement incluses dans la revendication `scope` du jeton d‚Äôacc√®s JWT

Consultez la documentation de votre fournisseur pour les d√©tails sp√©cifiques sur :

- Comment d√©finir et g√©rer les port√©es
- Comment les port√©es sont incluses dans le jeton d‚Äôacc√®s
- Toute fonctionnalit√© RBAC suppl√©mentaire comme la gestion des r√¥les

</TabItem>
</Tabs>

### Validation des jetons et v√©rification des permissions \{#validating-tokens-and-checking-permissions}

Lorsque votre serveur MCP re√ßoit une requ√™te, il doit :

1. Valider la signature et l‚Äôexpiration du jeton d‚Äôacc√®s
2. Extraire les port√©es du jeton valid√©
3. V√©rifier si le jeton poss√®de les port√©es requises pour l‚Äôop√©ration demand√©e

Par exemple, si un utilisateur souhaite cr√©er une nouvelle t√¢che, son jeton d‚Äôacc√®s doit inclure la port√©e `create:todos`. Voici comment fonctionne le flux :

```mermaid
sequenceDiagram
    participant Client
    participant MCP Server
    participant Auth Server

    Client->>MCP Server: Requ√™te avec jeton d‚Äôacc√®s

    alt Validation JWT
        MCP Server->>Auth Server: R√©cup√©rer JWKS
        Auth Server-->>MCP Server: Retourner JWKS
        MCP Server->>MCP Server: Valider le JWT localement
    else Introspection du jeton
        MCP Server->>Auth Server: POST /introspect<br/>(token=access_token)
        Auth Server-->>MCP Server: Retourner les infos du jeton<br/>(active, scope, etc.)
    end

    MCP Server->>MCP Server: Extraire & v√©rifier les port√©es

    alt Poss√®de les port√©es requises
        MCP Server->>Client: Autoriser l‚Äôop√©ration
    else Port√©es manquantes
        MCP Server->>Client: Retourner 403 Interdit
    end
```

### Enregistrement dynamique de client \{#dynamic-client-registration}

L‚Äôenregistrement dynamique de client n‚Äôest pas requis pour ce tutoriel, mais il peut √™tre utile si vous souhaitez automatiser le processus d‚Äôenregistrement du client MCP aupr√®s de votre serveur d‚Äôautorisation. Consultez [L‚Äôenregistrement dynamique de client est-il requis ?](../../provider-list.mdx#is-dcr-required) pour plus de d√©tails.

## Comprendre le RBAC dans le gestionnaire de t√¢ches \{#understand-rbac-in-todo-manager}

√Ä des fins de d√©monstration, nous allons mettre en ≈ìuvre un syst√®me simple de contr√¥le d‚Äôacc√®s bas√© sur les r√¥les (RBAC) dans notre serveur MCP gestionnaire de t√¢ches. Cela vous montrera les principes de base du RBAC tout en gardant l‚Äôimpl√©mentation simple.

:::note
Bien que ce tutoriel d√©montre la gestion des port√©es bas√©e sur le RBAC, il est important de noter que tous les fournisseurs d‚Äôauthentification n‚Äôimpl√©mentent pas la gestion des port√©es via les r√¥les. Certains fournisseurs peuvent avoir leurs propres m√©canismes uniques pour g√©rer le contr√¥le d‚Äôacc√®s et les permissions.
:::

### Outils et port√©es \{#tools-and-scopes}

Notre serveur MCP gestionnaire de t√¢ches fournit trois outils principaux :

- `create-todo` : Cr√©er une nouvelle t√¢che
- `get-todos` : Lister toutes les t√¢ches
- `delete-todo` : Supprimer une t√¢che par ID

Pour contr√¥ler l‚Äôacc√®s √† ces outils, nous d√©finissons les port√©es suivantes :

- `create:todos` : Autorise la cr√©ation de nouvelles t√¢ches
- `delete:todos` : Autorise la suppression de t√¢ches existantes
- `read:todos` : Autorise la consultation et la r√©cup√©ration de la liste de toutes les t√¢ches

### R√¥les et permissions \{#roles-and-permissions}

Nous allons d√©finir deux r√¥les avec diff√©rents niveaux d‚Äôacc√®s :

| R√¥le  | create:todos | read:todos | delete:todos |
| ----- | ------------ | ---------- | ------------ |
| Admin | ‚úÖ           | ‚úÖ         | ‚úÖ           |
| User  | ‚úÖ           |            |              |

- **User** : Un utilisateur r√©gulier qui peut cr√©er des t√¢ches et voir ou supprimer uniquement ses propres t√¢ches
- **Admin** : Un administrateur qui peut cr√©er, voir et supprimer toutes les t√¢ches, quel que soit le propri√©taire

### Propri√©t√© des ressources \{#resource-ownership}

Bien que le tableau des permissions ci-dessus montre les port√©es explicites attribu√©es √† chaque r√¥le, il y a un principe important de propri√©t√© des ressources √† consid√©rer :

- **Les utilisateurs** n‚Äôont pas les port√©es `read:todos` ou `delete:todos`, mais ils peuvent quand m√™me :
  - Lire leurs propres t√¢ches
  - Supprimer leurs propres t√¢ches
- **Les admins** ont toutes les permissions (`read:todos` et `delete:todos`), ce qui leur permet de :
  - Voir toutes les t√¢ches du syst√®me
  - Supprimer n‚Äôimporte quelle t√¢che, quel que soit le propri√©taire

Cela illustre un sch√©ma courant dans les syst√®mes RBAC o√π la propri√©t√© d‚Äôune ressource accorde des permissions implicites aux utilisateurs pour leurs propres ressources, tandis que les r√¥les administratifs re√ßoivent des permissions explicites pour toutes les ressources.

:::tip En savoir plus
Pour approfondir les concepts et bonnes pratiques du RBAC, consultez [Ma√Ætriser le RBAC : Un exemple complet du monde r√©el](https://blog.logto.io/mastering-rbac).
:::

## Configurer l‚Äôautorisation dans votre fournisseur \{#configure-authorization-in-your-provider}

Pour mettre en ≈ìuvre le syst√®me de contr√¥le d‚Äôacc√®s d√©crit pr√©c√©demment, vous devrez configurer votre serveur d‚Äôautorisation pour prendre en charge les port√©es requises. Voici comment faire avec diff√©rents fournisseurs :

<Tabs groupId="provider">
<TabItem value="logto" label="Logto">

[Logto](https://logto.io) fournit la prise en charge du RBAC via ses ressources API et ses fonctionnalit√©s de r√¥les. Voici comment le configurer :

1. Connectez-vous √† [Logto Console](https://cloud.logto.io) (ou √† votre propre instance Logto Console)

2. Cr√©ez une ressource API et des port√©es :

   - Allez dans "Ressources API"
   - Cr√©ez une nouvelle ressource API nomm√©e "Todo Manager" et utilisez `https://todo.mcp-server.app` (√† des fins de d√©monstration) comme indicateur.
   - Cr√©ez les port√©es suivantes :
     - `create:todos` : "Cr√©er de nouvelles t√¢ches"
     - `read:todos` : "Lire toutes les t√¢ches"
     - `delete:todos` : "Supprimer n‚Äôimporte quelle t√¢che"

3. Cr√©ez des r√¥les (recommand√© pour une gestion plus simple) :

   - Allez dans "R√¥les"
   - Cr√©ez un r√¥le "Admin" et assignez toutes les port√©es (`create:todos`, `read:todos`, `delete:todos`)
   - Cr√©ez un r√¥le "User" et assignez uniquement la port√©e `create:todos`
   - Dans la page de d√©tails du r√¥le "User", passez √† l‚Äôonglet "G√©n√©ral" et d√©finissez le r√¥le "User" comme "R√¥le par d√©faut".

4. G√©rez les r√¥les et permissions des utilisateurs :
   - Pour les nouveaux utilisateurs :
     - Ils recevront automatiquement le r√¥le "User" puisque nous l‚Äôavons d√©fini comme r√¥le par d√©faut
   - Pour les utilisateurs existants :
     - Allez dans "Gestion des utilisateurs"
     - S√©lectionnez un utilisateur
     - Assignez des r√¥les √† l‚Äôutilisateur dans l‚Äôonglet "R√¥les"

:::tip Gestion programmatique des r√¥les
Vous pouvez √©galement utiliser la [Management API](https://docs.logto.io/integrate-logto/interact-with-management-api) de Logto pour g√©rer les r√¥les des utilisateurs de mani√®re programmatique. Ceci est particuli√®rement utile pour la gestion automatis√©e des utilisateurs ou lors de la cr√©ation de panneaux d‚Äôadministration.
:::

Lors de la demande d‚Äôun jeton d‚Äôacc√®s, Logto inclura les port√©es dans la revendication `scope` du jeton en fonction des permissions de r√¥le de l‚Äôutilisateur.

</TabItem>
<TabItem value="keycloak" label="Keycloak">

Dans [Keycloak](https://www.keycloak.org), vous pouvez configurer les permissions requises √† l‚Äôaide des port√©es client :

1. Cr√©ez des port√©es client :

   - Dans votre realm, allez dans "Client scopes"
   - Cr√©ez trois nouvelles port√©es client :
     - `create:todos`
     - `read:todos`
     - `delete:todos`

2. Configurez le client :

   - Allez dans les param√®tres de votre client
   - Dans l‚Äôonglet "Client scopes", ajoutez toutes les port√©es que vous avez cr√©√©es
   - Assurez-vous que le mappage du jeton est configur√© pour inclure les port√©es

3. Optionnel : Utilisez les r√¥les pour une gestion plus simple
   - Si vous pr√©f√©rez la gestion bas√©e sur les r√¥les :
     - Cr√©ez des r√¥les de realm pour diff√©rents niveaux d‚Äôacc√®s
     - Mappez les port√©es aux r√¥les
     - Assignez les r√¥les aux utilisateurs
   - Sinon, vous pouvez assigner directement les port√©es aux utilisateurs ou via les permissions au niveau du client

Keycloak inclura les port√©es accord√©es dans la revendication `scope` du jeton d‚Äôacc√®s.

</TabItem>
<TabItem value="oauth-or-oidc" label="OAuth 2 / OIDC">

Pour les fournisseurs OAuth 2.0 ou OpenID Connect, vous devrez configurer les port√©es qui repr√©sentent diff√©rentes permissions. Les √©tapes exactes d√©pendront de votre fournisseur, mais g√©n√©ralement :

1. D√©finissez les port√©es :

   - Configurez votre serveur d‚Äôautorisation pour prendre en charge :
     - `create:todos`
     - `read:todos`
     - `delete:todos`

2. Configurez le client :

   - Enregistrez ou mettez √† jour votre client pour demander ces port√©es
   - Assurez-vous que les port√©es sont incluses dans le jeton d‚Äôacc√®s

3. Assignez les permissions :
   - Utilisez l‚Äôinterface de votre fournisseur pour accorder les port√©es appropri√©es aux utilisateurs
   - Certains fournisseurs peuvent prendre en charge la gestion bas√©e sur les r√¥les, tandis que d‚Äôautres utilisent des attributions directes de port√©es
   - Consultez la documentation de votre fournisseur pour l‚Äôapproche recommand√©e

:::tip
La plupart des fournisseurs incluront les port√©es accord√©es dans la revendication `scope` du jeton d‚Äôacc√®s. Le format est g√©n√©ralement une cha√Æne de valeurs de port√©es s√©par√©es par des espaces.
:::

</TabItem>
</Tabs>

Apr√®s avoir configur√© votre serveur d‚Äôautorisation, les utilisateurs recevront des jetons d‚Äôacc√®s contenant leurs port√©es accord√©es. Le serveur MCP utilisera ces port√©es pour d√©terminer :

- Si un utilisateur peut cr√©er de nouvelles t√¢ches (`create:todos`)
- Si un utilisateur peut voir toutes les t√¢ches (`read:todos`) ou seulement les siennes
- Si un utilisateur peut supprimer n‚Äôimporte quelle t√¢che (`delete:todos`) ou seulement les siennes

## Mettre en place le serveur MCP \{#set-up-the-mcp-server}

Nous allons utiliser les [SDK officiels MCP](https://github.com/modelcontextprotocol) pour cr√©er notre serveur MCP gestionnaire de t√¢ches.

### Cr√©er un nouveau projet \{#create-a-new-project}

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

```bash
mkdir mcp-server
cd mcp-server
uv init # Ou utilisez `pipenv` ou `poetry` pour cr√©er un nouvel environnement virtuel
```

</TabItem>
<TabItem value="node" label="Node.js">

Cr√©ez un nouveau projet Node.js :

```bash
mkdir mcp-server
cd mcp-server
npm init -y # Ou utilisez `pnpm init`
npm pkg set type="module"
npm pkg set main="todo-manager.ts"
npm pkg set scripts.start="node --experimental-strip-types todo-manager.ts"
```

:::note
Nous utilisons TypeScript dans nos exemples car Node.js v22.6.0+ prend en charge l‚Äôex√©cution native de TypeScript avec l‚Äôoption `--experimental-strip-types`. Si vous utilisez JavaScript, le code sera similaire ‚Äì assurez-vous simplement d‚Äôutiliser Node.js v22.6.0 ou ult√©rieur. Voir la documentation Node.js pour plus de d√©tails.
:::

</TabItem>
</Tabs>

### Installer le SDK MCP et les d√©pendances \{#install-the-mcp-sdk-and-dependencies}

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

```bash
pip install "mcp[cli]" starlette uvicorn
```

Ou tout autre gestionnaire de paquets que vous pr√©f√©rez, comme `uv` ou `poetry`.

</TabItem>
<TabItem value="node" label="Node.js">

```bash
npm install @modelcontextprotocol/sdk express zod
```

Ou tout autre gestionnaire de paquets que vous pr√©f√©rez, comme `pnpm` ou `yarn`.

</TabItem>
</Tabs>

### Cr√©er le serveur MCP \{#create-the-mcp-server}

Commen√ßons par cr√©er un serveur MCP de base avec la d√©finition des outils :

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

Cr√©ez un fichier nomm√© `todo-manager.py` et ajoutez le code suivant :

```python
from typing import Any
from mcp.server.fastmcp import FastMCP
from starlette.applications import Starlette
from starlette.routing import Mount

mcp = FastMCP("Todo Manager")

@mcp.tool()
def create_todo(content: str) -> dict[str, Any]:
    """Cr√©er une nouvelle t√¢che."""
    return {"error": "Non impl√©ment√©"}

@mcp.tool()
def get_todos() -> dict[str, Any]:
    """Lister toutes les t√¢ches."""
    return {"error": "Non impl√©ment√©"}

@mcp.tool()
def delete_todo(id: str) -> dict[str, Any]:
    """Supprimer une t√¢che par id."""
    return {"error": "Non impl√©ment√©"}

app = Starlette(
    routes=[Mount('/', app=mcp.sse_app())]
)
```

Lancez le serveur avec :

```bash
uvicorn todo_manager:app --host 0.0.0.0 --port 3001
```

</TabItem>
<TabItem value="node" label="Node.js">

:::note
Comme l‚Äôimpl√©mentation actuelle de l‚Äôinspecteur MCP ne g√®re pas les flux d‚Äôautorisation, nous utiliserons l‚Äôapproche SSE pour mettre en place le serveur MCP. Nous mettrons √† jour le code ici d√®s que l‚Äôinspecteur MCP prendra en charge les flux d‚Äôautorisation.
:::

Vous pouvez √©galement utiliser `pnpm` ou `yarn` si vous pr√©f√©rez.

Cr√©ez un fichier nomm√© `todo-manager.ts` et ajoutez le code suivant :

```ts
// todo-manager.ts

import { z } from 'zod';
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { SSEServerTransport } from '@modelcontextprotocol/sdk/server/sse.js';
import express from 'express';

// Cr√©er un serveur MCP
const server = new McpServer({
  name: 'Todo Manager',
  version: '0.0.0',
});

server.tool('create-todo', 'Cr√©er une nouvelle t√¢che', { content: z.string() }, async ({ content }) => {
  return {
    content: [{ type: 'text', text: JSON.stringify({ error: 'Non impl√©ment√©' }) }],
  };
});

server.tool('get-todos', 'Lister toutes les t√¢ches', async () => {
  return {
    content: [{ type: 'text', text: JSON.stringify({ error: 'Non impl√©ment√©' }) }],
  };
});

server.tool('delete-todo', 'Supprimer une t√¢che par id', { id: z.string() }, async ({ id }) => {
  return {
    content: [{ type: 'text', text: JSON.stringify({ error: 'Non impl√©ment√©' }) }],
  };
});

// Ci-dessous le code standard issu de la documentation du SDK MCP
const PORT = 3001;
const app = express();

const transports = {};

app.get('/sse', async (_req, res) => {
  const transport = new SSEServerTransport('/messages', res);
  transports[transport.sessionId] = transport;

  res.on('close', () => {
    delete transports[transport.sessionId];
  });

  await server.connect(transport);
});

app.post('/messages', async (req, res) => {
  const sessionId = String(req.query.sessionId);
  const transport = transports[sessionId];
  if (transport) {
    await transport.handlePostMessage(req, res, req.body);
  } else {
    res.status(400).send('Aucun transport trouv√© pour ce sessionId');
  }
});

app.listen(PORT);
```

Lancez le serveur avec :

```bash
npm start
```

</TabItem>
</Tabs>

## Inspecter le serveur MCP \{#inspect-the-mcp-server}

### Cloner et lancer l‚Äôinspecteur MCP \{#clone-and-run-mcp-inspector}

Maintenant que nous avons le serveur MCP en fonctionnement, nous pouvons utiliser l‚Äôinspecteur MCP pour v√©rifier si l‚Äôoutil `whoami` est disponible.

En raison des limitations de l‚Äôimpl√©mentation actuelle, nous avons fork√© l‚Äô[inspecteur MCP](https://github.com/mcp-auth/inspector) pour le rendre plus flexible et √©volutif pour l‚Äôauthentification et l‚Äôautorisation. Nous avons √©galement soumis une pull request au d√©p√¥t original pour inclure nos modifications.

Pour lancer l‚Äôinspecteur MCP, vous pouvez utiliser la commande suivante (Node.js requis) :

```bash
git clone https://github.com/mcp-auth/inspector.git
cd inspector
npm install
npm run dev
```

Ensuite, ouvrez votre navigateur et allez sur `http://localhost:6274/` (ou l‚ÄôURL affich√©e dans le terminal) pour acc√©der √† l‚Äôinspecteur MCP.

### Connecter l‚Äôinspecteur MCP au serveur MCP \{#connect-mcp-inspector-to-the-mcp-server}

Avant de continuer, v√©rifiez la configuration suivante dans l‚Äôinspecteur MCP :

- **Type de transport** : R√©glez sur `SSE`.
- **URL** : R√©glez sur l‚ÄôURL de votre serveur MCP. Dans notre cas, cela devrait √™tre `http://localhost:3001/sse`.

Vous pouvez maintenant cliquer sur le bouton "Connecter" pour voir si l‚Äôinspecteur MCP peut se connecter au serveur MCP. Si tout est correct, vous devriez voir le statut "Connect√©" dans l‚Äôinspecteur MCP.

### Point de contr√¥le : Ex√©cuter les outils du gestionnaire de t√¢ches \{#checkpoint-run-todo-manager-tools}

1. Dans le menu sup√©rieur de l‚Äôinspecteur MCP, cliquez sur l‚Äôonglet "Outils".
2. Cliquez sur le bouton "Lister les outils".
3. Vous devriez voir les outils `create-todo`, `get-todos` et `delete-todo` list√©s sur la page. Cliquez dessus pour ouvrir les d√©tails de l‚Äôoutil.
4. Vous devriez voir le bouton "Ex√©cuter l‚Äôoutil" √† droite. Cliquez dessus et saisissez les param√®tres requis pour ex√©cuter l‚Äôoutil.
5. Vous devriez voir le r√©sultat de l‚Äôoutil avec la r√©ponse JSON `{"error": "Non impl√©ment√©"}`.

![Premi√®re ex√©cution de l‚Äôinspecteur MCP](/docs-assets/images/tutorials/todo-manager/inspector-first-run.png)

## Int√©grer avec votre serveur d‚Äôautorisation \{#integrate-with-your-authorization-server}

Pour compl√©ter cette section, plusieurs points sont √† prendre en compte :

<details>
<summary>**L‚ÄôURL de l‚Äô√©metteur de votre serveur d‚Äôautorisation**</summary>

Il s‚Äôagit g√©n√©ralement de l‚ÄôURL de base de votre serveur d‚Äôautorisation, comme `https://auth.example.com`. Certains fournisseurs peuvent avoir un chemin comme `https://example.logto.app/oidc`, alors assurez-vous de v√©rifier la documentation de votre fournisseur.

</details>

<details>
<summary>**Comment r√©cup√©rer les m√©tadonn√©es du serveur d‚Äôautorisation**</summary>

- Si votre serveur d‚Äôautorisation est conforme √† [OAuth 2.0 Authorization Server Metadata](https://datatracker.ietf.org/doc/html/rfc8414) ou [OpenID Connect Discovery](https://openid.net/specs/openid-connect-discovery-1_0.html), vous pouvez utiliser les utilitaires int√©gr√©s de MCP Auth pour r√©cup√©rer automatiquement les m√©tadonn√©es.
- Si votre serveur d‚Äôautorisation n‚Äôest pas conforme √† ces standards, vous devrez sp√©cifier manuellement l‚ÄôURL des m√©tadonn√©es ou les points de terminaison dans la configuration du serveur MCP. Consultez la documentation de votre fournisseur pour les points de terminaison sp√©cifiques.

</details>

<details>
<summary>**Comment enregistrer l‚Äôinspecteur MCP comme client dans votre serveur d‚Äôautorisation**</summary>

- Si votre serveur d‚Äôautorisation prend en charge [l‚Äôenregistrement dynamique de client](https://datatracker.ietf.org/doc/html/rfc7591), vous pouvez passer cette √©tape car l‚Äôinspecteur MCP s‚Äôenregistrera automatiquement comme client.
- Si votre serveur d‚Äôautorisation ne prend pas en charge l‚Äôenregistrement dynamique de client, vous devrez enregistrer manuellement l‚Äôinspecteur MCP comme client dans votre serveur d‚Äôautorisation.

</details>

<details>
<summary>**Comprendre les param√®tres de la requ√™te de jeton**</summary>

Lorsque vous demandez des jetons d‚Äôacc√®s √† diff√©rents serveurs d‚Äôautorisation, vous rencontrerez diverses approches pour sp√©cifier la ressource cible et les permissions. Voici les principaux sch√©mas :

- **Bas√© sur l‚Äôindicateur de ressource** :

  - Utilise le param√®tre `resource` pour sp√©cifier l‚ÄôAPI cible (voir [RFC 8707 : Indicateurs de ressource pour OAuth 2.0](https://datatracker.ietf.org/doc/html/rfc8707))
  - Courant dans les impl√©mentations OAuth 2.0 modernes
  - Exemple de requ√™te :
    ```json
    {
      "resource": "https://todo.mcp-server.app",
      "scope": "create:todos read:todos"
    }
    ```
  - Le serveur d√©livre des jetons li√©s sp√©cifiquement √† la ressource demand√©e

- **Bas√© sur l‚Äôaudience** :

  - Utilise le param√®tre `audience` pour sp√©cifier le destinataire du jeton
  - Semblable aux indicateurs de ressource mais avec une s√©mantique diff√©rente
  - Exemple de requ√™te :
    ```json
    {
      "audience": "todo-api",
      "scope": "create:todos read:todos"
    }
    ```

- **Bas√© uniquement sur les port√©es** :
  - S‚Äôappuie uniquement sur les port√©es sans param√®tres de ressource / audience
  - Approche OAuth 2.0 traditionnelle
  - Exemple de requ√™te :
    ```json
    {
      "scope": "todo-api:create todo-api:read openid profile"
    }
    ```
  - Utilise souvent des port√©es pr√©fix√©es pour nommer les permissions
  - Courant dans les impl√©mentations OAuth 2.0 plus simples

:::tip Bonnes pratiques

- Consultez la documentation de votre fournisseur pour les param√®tres pris en charge
- Certains fournisseurs prennent en charge plusieurs approches simultan√©ment
- Les indicateurs de ressource offrent une meilleure s√©curit√© via la restriction d‚Äôaudience
- Privil√©giez les indicateurs de ressource lorsque disponibles pour un meilleur contr√¥le d‚Äôacc√®s
  :::

</details>

Bien que chaque fournisseur puisse avoir ses propres exigences sp√©cifiques, les √©tapes suivantes vous guideront dans l‚Äôint√©gration de l‚Äôinspecteur MCP et du serveur MCP avec des configurations sp√©cifiques au fournisseur.

### Enregistrer l‚Äôinspecteur MCP comme client \{#register-mcp-inspector-as-a-client}

<Tabs groupId="provider">
<TabItem value="logto" label="Logto">

L‚Äôint√©gration du gestionnaire de t√¢ches avec [Logto](https://logto.io) est simple car il s‚Äôagit d‚Äôun fournisseur OpenID Connect qui prend en charge les indicateurs de ressource et les port√©es, vous permettant de s√©curiser votre API todo avec `https://todo.mcp-server.app` comme indicateur de ressource.

Comme Logto ne prend pas encore en charge l‚Äôenregistrement dynamique de client, vous devrez enregistrer manuellement l‚Äôinspecteur MCP comme client dans votre tenant Logto :

1. Ouvrez votre inspecteur MCP, cliquez sur le bouton "Configuration OAuth". Copiez la valeur **Redirect URL (auto-populated)**, qui devrait ressembler √† `http://localhost:6274/oauth/callback`.
2. Connectez-vous √† [Logto Console](https://cloud.logto.io) (ou √† votre propre instance Logto Console).
3. Acc√©dez √† l‚Äôonglet "Applications", cliquez sur "Cr√©er une application". En bas de la page, cliquez sur "Cr√©er une application sans framework".
4. Remplissez les d√©tails de l‚Äôapplication, puis cliquez sur "Cr√©er l‚Äôapplication" :
   - **S√©lectionnez un type d‚Äôapplication** : Choisissez "Application monopage".
   - **Nom de l‚Äôapplication** : Saisissez un nom pour votre application, par exemple "MCP Inspector".
5. Dans la section "Param√®tres / URI de redirection", collez la valeur **Redirect URL (auto-populated)** que vous avez copi√©e depuis l‚Äôinspecteur MCP. Cliquez ensuite sur "Enregistrer les modifications" dans la barre du bas.
6. Dans la carte du haut, vous verrez la valeur "App ID". Copiez-la.
7. Retournez dans l‚Äôinspecteur MCP et collez la valeur "App ID" dans la section "Configuration OAuth" sous "Client ID".
8. Saisissez la valeur `{"scope": "create:todos read:todos delete:todos", "resource": "https://todo.mcp-server.app"}` dans le champ "Auth Params". Cela garantira que le jeton d‚Äôacc√®s retourn√© par Logto contient les port√©es n√©cessaires pour acc√©der au gestionnaire de t√¢ches.

</TabItem>
<TabItem value="oauth-oidc" label="OAuth 2.0 / OIDC">

:::note
Ceci est un guide g√©n√©rique d‚Äôint√©gration pour les fournisseurs OAuth 2.0 / OpenID Connect. Les deux suivent des √©tapes similaires car OIDC est construit sur OAuth 2.0. Consultez la documentation de votre fournisseur pour les d√©tails sp√©cifiques.
:::

Si votre fournisseur prend en charge l‚Äôenregistrement dynamique de client, vous pouvez passer directement √† l‚Äô√©tape 8 ci-dessous pour configurer l‚Äôinspecteur MCP ; sinon, vous devrez enregistrer manuellement l‚Äôinspecteur MCP comme client :

1. Ouvrez votre inspecteur MCP, cliquez sur le bouton "Configuration OAuth". Copiez la valeur **Redirect URL (auto-populated)**, qui devrait ressembler √† `http://localhost:6274/oauth/callback`.

2. Connectez-vous √† la console de votre fournisseur.

3. Acc√©dez √† la section "Applications" ou "Clients", puis cr√©ez une nouvelle application ou client.

4. Si votre fournisseur demande un type de client, s√©lectionnez "Application monopage" ou "Client public".

5. Apr√®s avoir cr√©√© l‚Äôapplication, vous devrez configurer l‚ÄôURI de redirection. Collez la valeur **Redirect URL (auto-populated)** que vous avez copi√©e depuis l‚Äôinspecteur MCP.

6. Trouvez le "Client ID" ou "Application ID" de la nouvelle application et copiez-le.

7. Retournez dans l‚Äôinspecteur MCP et collez la valeur "Client ID" dans la section "Configuration OAuth" sous "Client ID".

8. Saisissez la valeur suivante dans le champ "Auth Params" pour demander les port√©es n√©cessaires aux op√©rations todo :

```json
{ "scope": "create:todos read:todos delete:todos" }
```

</TabItem>
</Tabs>

### Configurer MCP Auth \{#set-up-mcp-auth}

Dans votre projet serveur MCP, vous devez installer le SDK MCP Auth et le configurer pour utiliser les m√©tadonn√©es de votre serveur d‚Äôautorisation.

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

D‚Äôabord, installez le paquet `mcpauth` :

```bash
pip install mcpauth
```

Ou tout autre gestionnaire de paquets que vous pr√©f√©rez, comme `uv` ou `poetry`.

</TabItem>
<TabItem value="node" label="Node.js">

D‚Äôabord, installez le paquet `mcp-auth` :

```bash
npm install mcp-auth
```

</TabItem>
</Tabs>

MCP Auth n√©cessite les m√©tadonn√©es du serveur d‚Äôautorisation pour pouvoir s‚Äôinitialiser. Selon votre fournisseur :

<Tabs groupId="provider">

<TabItem value="logto" label="Logto">

L‚ÄôURL de l‚Äô√©metteur peut √™tre trouv√©e dans la page de d√©tails de votre application dans Logto Console, dans la section "Endpoints & Credentials / Issuer endpoint". Elle devrait ressembler √† `https://my-project.logto.app/oidc`.

<SetupOidc />

</TabItem>

<TabItem value="oauth-oidc" label="OAuth 2.0 / OIDC">

Pour les fournisseurs OAuth 2.0, vous devrez :

1. V√©rifier la documentation de votre fournisseur pour l‚ÄôURL du serveur d‚Äôautorisation (souvent appel√©e issuer URL ou base URL)
2. Certains fournisseurs exposent cela √† `https://{your-domain}/.well-known/oauth-authorization-server`
3. Cherchez dans la console d‚Äôadministration de votre fournisseur sous les param√®tres OAuth/API

<SetupOauthOrOidc />

</TabItem>

</Tabs>

<Tabs groupId="sdk">

<TabItem value="python" label="Python">

Mettez √† jour le fichier `todo-manager.py` pour inclure la configuration MCP Auth :

```python
from mcpauth import MCPAuth
from mcpauth.config import AuthServerType
from mcpauth.utils import fetch_server_config

auth_issuer = '<issuer-endpoint>'  # Remplacez par votre endpoint issuer
auth_server_config = fetch_server_config(auth_issuer, type=AuthServerType.OIDC)
mcp_auth = MCPAuth(server=auth_server_config)
```

</TabItem>
<TabItem value="node" label="Node.js">

Mettez √† jour le fichier `todo-manager.ts` pour inclure la configuration MCP Auth :

```ts
// todo-manager.ts

import { MCPAuth, fetchServerConfig } from 'mcp-auth';

const authIssuer = '<issuer-endpoint>'; // Remplacez par votre endpoint issuer
const mcpAuth = new MCPAuth({
  server: await fetchServerConfig(authIssuer, { type: 'oidc' }),
});
```

</TabItem>
</Tabs>

### Mettre √† jour le serveur MCP \{#update-mcp-server}

Nous y sommes presque ! Il est temps de mettre √† jour le serveur MCP pour appliquer la route et le middleware MCP Auth, puis d‚Äôimpl√©menter le contr√¥le d‚Äôacc√®s bas√© sur les permissions pour les outils du gestionnaire de t√¢ches en fonction des port√©es de l‚Äôutilisateur.

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

```python
@mcp.tool()
def create_todo(content: str) -> dict[str, Any]:
    """Cr√©er une nouvelle t√¢che."""
    return (
        mcp_auth.auth_info.scopes
        if mcp_auth.auth_info # Ceci sera renseign√© par le middleware Bearer auth
        else {"error": "Non authentifi√©"}
    )

# ...

bearer_auth = Middleware(mcp_auth.bearer_auth_middleware("jwt"))
app = Starlette(
    routes=[
        # Ajouter la route metadata (`/.well-known/oauth-authorization-server`)
        mcp_auth.metadata_route(),
        # Prot√©ger le serveur MCP avec le middleware Bearer auth
        Mount('/', app=mcp.sse_app(), middleware=[bearer_auth]),
    ],
)
```

</TabItem>
<TabItem value="node" label="Node.js">

```js
server.tool(
  'create-todo',
  'Cr√©er une nouvelle t√¢che',
  { content: z.string() },
  async ({ content, authInfo }) => {
    return {
      content: [
        { type: 'text', text: JSON.stringify(authInfo?.scopes ?? { error: 'Non authentifi√©' }) },
      ],
    };
  }
);

// ...

app.use(mcpAuth.delegatedRouter());
app.use(mcpAuth.bearerAuth('jwt'));
```

</TabItem>
</Tabs>

Ensuite, impl√©mentons les outils sp√©cifiques.

Commen√ßons par cr√©er un service de t√¢ches simple pour fournir des op√©rations CRUD de base pour la gestion des t√¢ches en m√©moire.

<Tabs groupId="sdk">
<TabItem value="python" label="Python">
```python
# service.py

"""
Un service Todo simple √† des fins de d√©monstration.
Utilise une liste en m√©moire pour stocker les t√¢ches.
"""

from datetime import datetime
from typing import List, Optional, Dict, Any
import random
import string

class Todo:
"""Repr√©sente une t√¢che."""

    def __init__(self, id: str, content: str, owner_id: str, created_at: str):
        self.id = id
        self.content = content
        self.owner_id = owner_id
        self.created_at = created_at

    def to_dict(self) -> Dict[str, Any]:
        """Convertir la t√¢che en dictionnaire pour la s√©rialisation JSON."""
        return {
            "id": self.id,
            "content": self.content,
            "ownerId": self.owner_id,
            "createdAt": self.created_at
        }

class TodoService:
"""Un service Todo simple √† des fins de d√©monstration."""

    def __init__(self):
        self._todos: List[Todo] = []

    def get_all_todos(self, owner_id: Optional[str] = None) -> List[Dict[str, Any]]:
        """
        Obtenir toutes les t√¢ches, √©ventuellement filtr√©es par owner_id.

        Args:
            owner_id: Si fourni, ne retourne que les t√¢ches appartenant √† cet utilisateur

        Returns:
            Liste de dictionnaires de t√¢ches
        """
        if owner_id:
            filtered_todos = [todo for todo in self._todos if todo.owner_id == owner_id]
            return [todo.to_dict() for todo in filtered_todos]
        return [todo.to_dict() for todo in self._todos]

    def get_todo_by_id(self, todo_id: str) -> Optional[Todo]:
        """
        Obtenir une t√¢che par son ID.

        Args:
            todo_id: L‚ÄôID de la t√¢che √† r√©cup√©rer

        Returns:
            Objet Todo si trouv√©, None sinon
        """
        for todo in self._todos:
            if todo.id == todo_id:
                return todo
        return None

    def create_todo(self, content: str, owner_id: str) -> Dict[str, Any]:
        """
        Cr√©er une nouvelle t√¢che.

        Args:
            content: Le contenu de la t√¢che
            owner_id: L‚ÄôID de l‚Äôutilisateur propri√©taire de cette t√¢che

        Returns:
            Dictionnaire repr√©sentant la t√¢che cr√©√©e
        """
        todo = Todo(
            id=self._generate_id(),
            content=content,
            owner_id=owner_id,
            created_at=datetime.now().isoformat()
        )
        self._todos.append(todo)
        return todo.to_dict()

    def delete_todo(self, todo_id: str) -> Optional[Dict[str, Any]]:
        """
        Supprimer une t√¢che par son ID.

        Args:
            todo_id: L‚ÄôID de la t√¢che √† supprimer

        Returns:
            Dictionnaire repr√©sentant la t√¢che supprim√©e si trouv√©e, None sinon
        """
        for i, todo in enumerate(self._todos):
            if todo.id == todo_id:
                deleted_todo = self._todos.pop(i)
                return deleted_todo.to_dict()
        return None

    def _generate_id(self) -> str:
        """G√©n√©rer un ID al√©atoire pour une t√¢che."""
        return ''.join(random.choices(string.ascii_lowercase + string.digits, k=8))

````


</TabItem>
<TabItem value="node" label="Node.js">

```ts
// todo-service.ts

type Todo = {
  id: string;
  content: string;
  ownerId: string;
  createdAt: string;
};

/**
 * Un service Todo simple √† des fins de d√©monstration.
 * Utilise un tableau en m√©moire pour stocker les t√¢ches
 */
export class TodoService {
  private readonly todos: Todo[] = [];

  getAllTodos(ownerId?: string): Todo[] {
    if (ownerId) {
      return this.todos.filter((todo) => todo.ownerId === ownerId);
    }
    return this.todos;
  }

  getTodoById(id: string): Todo | undefined {
    return this.todos.find((todo) => todo.id === id);
  }

  createTodo({ content, ownerId }: { content: string; ownerId: string }): Todo {
    const todo: Todo = {
      id: this.genId(),
      content,
      ownerId,
      createdAt: new Date().toISOString(),
    };

    // eslint-disable-next-line @silverhand/fp/no-mutating-methods
    this.todos.push(todo);
    return todo;
  }

  deleteTodo(id: string): Todo | undefined {
    const index = this.todos.findIndex((todo) => todo.id === id);

    if (index === -1) {
      return undefined;
    }

    // eslint-disable-next-line @silverhand/fp/no-mutating-methods
    const [deleted] = this.todos.splice(index, 1);
    return deleted;
  }

  private genId(): string {
    return Math.random().toString(36).slice(2, 10);
  }
}
````

</TabItem>
</Tabs>

puis dans la couche outils, nous d√©terminerons si les op√©rations sont autoris√©es en fonction des port√©es de l‚Äôutilisateur :

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

```python
# todo-manager.py

from typing import Any, Optional
from mcpauth.errors import MCPAuthBearerAuthError

def assert_user_id(auth_info: Optional[dict]) -> str:
    """Extraire et valider l‚ÄôID utilisateur depuis les infos d‚Äôauth."""
    subject = auth_info.get('subject') if auth_info else None
    if not subject:
        raise ValueError('Invalid auth info')
    return subject

def has_required_scopes(user_scopes: list[str], required_scopes: list[str]) -> bool:
    """V√©rifier si l‚Äôutilisateur poss√®de toutes les port√©es requises."""
    return all(scope in user_scopes for scope in required_scopes)

# Cr√©er une instance de TodoService
todo_service = TodoService()

@mcp.tool()
def create_todo(content: str) -> dict[str, Any]:
    """Cr√©er une nouvelle t√¢che.

    Seuls les utilisateurs avec la port√©e 'create:todos' peuvent cr√©er des t√¢ches.
    """
    # Obtenir les infos d‚Äôauthentification
    auth_info = mcp_auth.auth_info

    # Valider l‚ÄôID utilisateur
    try:
        user_id = assert_user_id(auth_info)
    except ValueError as e:
        return {"error": str(e)}

    # V√©rifier si l‚Äôutilisateur a les permissions requises
    if not has_required_scopes(auth_info.scopes if auth_info else [], ['create:todos']):
        raise MCPAuthBearerAuthError('missing_required_scopes')

    # Cr√©er la nouvelle t√¢che
    created_todo = todo_service.create_todo(content=content, owner_id=user_id)

    # Retourner la t√¢che cr√©√©e
    return created_todo.__dict__

# ...
```

Vous pouvez consulter notre [code d‚Äôexemple](https://github.com/mcp-auth/python/tree/master/samples/server) pour toutes les autres impl√©mentations d√©taill√©es.

</TabItem>
<TabItem value="node" label="Node.js">

```ts
// todo-manager.ts

// ... autres imports
import assert from 'node:assert';
import { type AuthInfo } from '@modelcontextprotocol/sdk/server/auth/types.js';
import { TodoService } from './todo-service.js';

const todoService = new TodoService();

const assertUserId = (authInfo?: AuthInfo) => {
  const { subject } = authInfo ?? {};
  assert(subject, 'Invalid auth info');
  return subject;
};

/**
 * V√©rifie si l‚Äôutilisateur poss√®de toutes les port√©es requises pour une op√©ration
 */
const hasRequiredScopes = (userScopes: string[], requiredScopes: string[]): boolean => {
  return requiredScopes.every((scope) => userScopes.includes(scope));
};

server.tool(
  'create-todo',
  'Cr√©er une nouvelle t√¢che',
  { content: z.string() },
  ({ content }: { content: string }, { authInfo }) => {
    const userId = assertUserId(authInfo);

    /**
     * Seuls les utilisateurs avec la port√©e 'create:todos' peuvent cr√©er des t√¢ches
     */
    if (!hasRequiredScopes(authInfo?.scopes ?? [], ['create:todos'])) {
      throw new MCPAuthBearerAuthError('missing_required_scopes');
    }

    const createdTodo = todoService.createTodo({ content, ownerId: userId });

    return {
      content: [{ type: 'text', text: JSON.stringify(createdTodo) }],
    };
  }
);

// ...
```

Vous pouvez consulter notre [code d‚Äôexemple](https://github.com/mcp-auth/js/tree/master/packages/sample-servers/src/todo-manager) pour toutes les autres impl√©mentations d√©taill√©es.

</TabItem>
</Tabs>

## Point de contr√¥le : Ex√©cuter les outils `todo-manager` \{#checkpoint-run-the-todo-manager-tools}

Red√©marrez votre serveur MCP et ouvrez l‚Äôinspecteur MCP dans votre navigateur. Lorsque vous cliquez sur le bouton "Connecter", vous devriez √™tre redirig√© vers la page de connexion de votre serveur d‚Äôautorisation.

Une fois connect√© et de retour dans l‚Äôinspecteur MCP, r√©p√©tez les actions du point de contr√¥le pr√©c√©dent pour ex√©cuter les outils du gestionnaire de t√¢ches. Cette fois, vous pouvez utiliser ces outils avec votre identit√© utilisateur authentifi√©e. Le comportement des outils d√©pendra des r√¥les et permissions attribu√©s √† votre utilisateur :

- Si vous √™tes connect√© en tant que **User** (avec uniquement la port√©e `create:todos`) :

  - Vous pouvez cr√©er de nouvelles t√¢ches avec l‚Äôoutil `create-todo`
  - Vous ne pouvez voir et supprimer que vos propres t√¢ches
  - Vous ne pourrez pas voir ou supprimer les t√¢ches des autres utilisateurs

- Si vous √™tes connect√© en tant qu‚Äô**Admin** (avec toutes les port√©es : `create:todos`, `read:todos`, `delete:todos`) :
  - Vous pouvez cr√©er de nouvelles t√¢ches
  - Vous pouvez voir toutes les t√¢ches du syst√®me avec l‚Äôoutil `get-todos`
  - Vous pouvez supprimer n‚Äôimporte quelle t√¢che avec l‚Äôoutil `delete-todo`, quel que soit le cr√©ateur

Vous pouvez tester ces diff√©rents niveaux de permission en :

1. Vous d√©connectant de la session en cours (cliquez sur le bouton "D√©connecter" dans l‚Äôinspecteur MCP)
2. Vous connectant avec un autre compte utilisateur ayant des r√¥les / permissions diff√©rents
3. Essayant √† nouveau les m√™mes outils pour observer comment le comportement change selon les permissions de l‚Äôutilisateur

Cela d√©montre comment le contr√¥le d‚Äôacc√®s bas√© sur les r√¥les (RBAC) fonctionne en pratique, o√π diff√©rents utilisateurs ont diff√©rents niveaux d‚Äôacc√®s aux fonctionnalit√©s du syst√®me.

![R√©sultat de l‚Äôoutil todo manager dans l‚Äôinspecteur MCP](/docs-assets/images/tutorials/todo-manager/result.png)

<Tabs groupId="sdk">
<TabItem value="python" label="Python">

:::info
Consultez le [d√©p√¥t du SDK MCP Auth Python](https://github.com/mcp-auth/python/blob/master/samples/server/todo-manager/server.py) pour le code complet du serveur MCP (version OIDC).
:::

</TabItem>
<TabItem value="node" label="Node.js">

:::info
Consultez le [d√©p√¥t du SDK MCP Auth Node.js](https://github.com/mcp-auth/js/blob/master/packages/sample-servers/src) pour le code complet du serveur MCP (version OIDC).
:::

</TabItem>
</Tabs>

## Notes de cl√¥ture \{#closing-notes}

üéä F√©licitations ! Vous avez termin√© avec succ√®s le tutoriel. R√©capitulons ce que nous avons fait :

- Mise en place d‚Äôun serveur MCP de base avec des outils de gestion de t√¢ches (`create-todo`, `get-todos`, `delete-todo`)
- Impl√©mentation du contr√¥le d‚Äôacc√®s bas√© sur les r√¥les (RBAC) avec diff√©rents niveaux de permission pour les utilisateurs et les administrateurs
- Int√©gration du serveur MCP avec un serveur d‚Äôautorisation en utilisant MCP Auth
- Configuration de l‚Äôinspecteur MCP pour authentifier les utilisateurs et utiliser des jetons d‚Äôacc√®s avec des port√©es pour appeler les outils

N‚Äôh√©sitez pas √† consulter d‚Äôautres tutoriels et la documentation pour tirer le meilleur parti de MCP Auth.
